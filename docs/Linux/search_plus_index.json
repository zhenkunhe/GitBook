{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-08-12 03:45:00 "},"md/3-Docker/1-Basic/Readme.html":{"url":"md/3-Docker/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Docker tagsstop Introduction sudo docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb ubuntu:14.04 /bin/bash sudo docker exec -u root -it compassionate_snyder bash 'su' command in Docker returns 'must be run from terminal' When you are ssh-ing in or going in via php your session is not being allocated a pty. I have used each of the following solutions: ANSWER 3: use python to spawn a pty in your shell Quite a cute hack :) jenkins@e9fbe94d4c89:~$ su - su: must be run from a terminal $ echo \"import pty; pty.spawn('/bin/bash')\" > /tmp/asdf.py $ python /tmp/asdf.py $ su - Password: root@e9fbe94d4c89:~# 什麼是 Docker Docker 是一個開源專案，誕生於 2013 年初，最初是 dotCloud 公司內部的一個業餘專案。它基於 Google 公司推出的 Go 語言實作。 專案後來加入了 Linux 基金會，遵從了 Apache 2.0 協議，原始碼在 GitHub 上進行維護。 Docker 自開源後受到廣泛的關注和討論，以至於 dotCloud 公司後來都改名為 Docker Inc。Redhat 已經在其 RHEL6.5 中集中支援 Docker；Google 也在其 PaaS 產品中廣泛應用。 Docker 專案的目標是實作輕量級的作業系統虛擬化解決方案。 Docker 的基礎是 Linux 容器（LXC）等技術。 在 LXC 的基礎上 Docker 進行了進一步的封裝，讓使用者不需要去關心容器的管理，使得操作更為簡便。使用者操作 Docker 的容器就像操作一個快速輕量級的虛擬機一樣簡單。 下面的圖片比較了 Docker 和傳統虛擬化方式的不同之處，可見容器是在作業系統層面上實作虛擬化，直接使用本地主機的作業系統，而傳統方式則是在硬體層面實作。 Image 1 - 1 Image 2 - 2 How To Install and Use Docker on Ubuntu 16.04 sudo apt-get update sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D echo \"deb https://apt.dockerproject.org/repo ubuntu-xenial main\" | sudo tee /etc/apt/sources.list.d/docker.list sudo apt-get update apt-cache policy docker-engine docker-engine: Installed: (none) Candidate: 1.11.1-0~xenial Version table: 1.11.1-0~xenial 500 500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages 1.11.0-0~xenial 500 500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages sudo apt-get install -y docker-engine sudo systemctl status docker ● docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2016-05-01 06:53:52 CDT; 1 weeks 3 days ago Docs: https://docs.docker.com Main PID: 749 (docker) Install ubuntu oem@Alex:~$ sudo docker pull ubuntu [sudo] password for oem: Using default tag: latest latest: Pulling from library/ubuntu f069f1d21059: Pull complete ecbeec5633cf: Pull complete ea6f18256d63: Pull complete 54bde7b02897: Pull complete Digest: sha256:bbfd93a02a8487edb60f20316ebc966ddc7aa123c2e609185450b96971020097 Status: Downloaded newer image for ubuntu:latest 列出本機映像檔 $ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 12.04 74fe38d11401 4 weeks ago 209.6 MB ubuntu precise 74fe38d11401 4 weeks ago 209.6 MB ubuntu 14.04 99ec81b80c55 4 weeks ago 266 MB ubuntu latest 99ec81b80c55 4 weeks ago 266 MB ubuntu trusty 99ec81b80c55 4 weeks ago 266 MB 創造容器 sudo docker run -ti utuntu:14.04 bash 啟動容器 sudo docker start nostalgic_hypatia 進入容器 sudo docker exec -ti nostalgic_hypatia bash sudo docker attach nostalgic_hypatia 查看容器 oem@Alex:~$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8dd510fc3be5 ubuntu:14.04 \"/bin/bash\" About a minute ago Exited (0) About a minute ago happy_fermat 091a9c73d24e ubuntu:14.04 \"/bin/bash\" 57 minutes ago Up 57 minutes gigantic_knuth 刪除容器 oem@Alex:~$ sudo docker rm happy_fermat happy_fermat cp到容器內 sudo docker cp gstreamer_example/ gigantic_knuth:/ rename容器 sudo docker rename OLD_NAME NEW_NAME scratch -> debian -> busybox 如何進到docker container file system: start container get root if [ -z \"$1\" ] ; then echo 'docker-find-root $container_id_or_name ' exit 1 fi CID=$(docker inspect --format {{.Id}} $1) if [ -n \"$CID\" ] ; then if [ -f /var/lib/docker/image/aufs/layerdb/mounts/$CID/mount-id ] ; then F1=$(cat /var/lib/docker/image/aufs/layerdb/mounts/$CID/mount-id) d1=/var/lib/docker/aufs/mnt/$F1 fi if [ ! -d \"$d1\" ] ; then d1=/var/lib/docker/aufs/diff/$CID fi echo $d1 3, cd root path © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/7-Protocol/1-RTP體系.html":{"url":"md/7-Protocol/1-RTP體系.html","title":"RTP體系","keywords":"","body":"RTP、RTCP、RTSP tagsstart RTP RTCP RTSP Protocol tagsstop Introduction RTCP：應用層協定，同Http RTSP：應用RTP & RTCP協定的Framework 分為RTSP server & RTSP client © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/8-Memory/1-Memory_Leak/1-valgrind.html":{"url":"md/8-Memory/1-Memory_Leak/1-valgrind.html","title":"Valgrind","keywords":"","body":"valgrind tagsstart valgrind memory tagsstop Introduction Memory Leak: leak on the heap, memory allocation during runtime Frequent Memory Leak: a code include memory leak is used frequently (most dangerous but relatively easy to find) Occasional Memory Leak: memory leak happens in specific occasion (hard to find) One-Time Memory Leak: only leak once, like in a singleton class (not that dangerous) Implicit Memory Leak: always allocate memory during the runtime and only free memory until exit (hard to find and dangerous, may hold too much memory and lead to crush ) Examples Forget to free/delete void func() { char *oldString = \"Old String\"; char* newStrig = strdup(oldString); //be careful with c lib-functions which alloc memory inside char *textString = malloc(128*sizeof(char)); ClassTypeA *ptr = new ClassTypeA; return; } Be careful with logic branches BassClass * obj = new BaseClass； if（test something） return; else if (test something) do something; else do something; delete obj; return; 2.Careful with Inheritance, polymorphism BaseClass* obj_ptr = new DerivedClass; delete obj_ptr; /*If you are counting on the destructor to delete memory allocated in the constructor beware of this mistake as it will cause a memory leak. */ /*Use a virtual destructor to avoid this problem.*/ 3.Pointer re-assignment error char *a = malloc(128*sizeof(char)); char *b = malloc(128*sizeof(char)); b = a; free(a); free(b); // will not free the pointer to the original allocated memory. 4.Default copy constructor may not give correct results ClassA& operator=(const ClassA& right_hand_side); /*sallow copy, deep copy?*/ /*Memory allocated by copy constructors for pointer duplication. Check in destructor and delete if necessary. Memory allocated in passing class by value which invokes copy constructor. Also beware, the default copy constructor may not give you the results you want especially when dealing with pointers as the default copy constructor has no knowledge of how to copy the contents of what the pointer points to. To prohibit the use of the default copy constructor define a null assignment operator. And when there is allocation in class, define your own destructor*/ class GCharacter //Game Character { private: std::string name; int capacity; //the capacity of our tool array int used; //the nr of elements that we've actually used in that tool array std::string* toolHolder; //string pointer that will be able to reference our ToolArray; public: static const int DEFAULT_CAPACITY = 5; //Constructor GCharacter(std::string n = \"John\", int cap = DEFAULT_CAPACITY) :name(n), capacity(cap), used(0), toolHolder(new string[cap]) { } } int main() { GCharacter gc1(\"BoB\", 5); GCharacter gc2(\"Terry\", 5); gc2 = gc1; GCharacter gc3 = gc1; return 0; } Do not rely on STL containers vector objects; for (int i=0;i Yes, stl containers will call destruct functions. But in this case, the container dose not free any memory. vector objects; //when clear object in vector, the vector will call the destructor of T in this way *T->~T(); Implicit Memory Leak: free memory as soon as you don't need it(or need so large) another stl example: stl containers always know how and when to expand itself, but they never know when to shrink itself. { vector vec; for(int64_t i=0; i then the 1000000000000000000*sizeof(int) memory will hold forever. //if you don't need it vector().swap(vec) //instead of clear //if you want to shrink the container size vector(vec).swap(vec) Implicit Memory Leak: heap fragmentation（impossible to be found by tools） You think the code is memory leak free, but the memory usage always going up and then crush.... Applications that are free from memory leaks but perform dynamic memory allocation and deallocation frequently tend to show gradual performance degradation if they are kept running for long periods. Finally, they crash. Why is this? Recurrent allocation and deallocation of dynamic memory causes the heap to become fragmented, especially if the application allocates small memory chunks (int, an 8 byte object etc.). A fragmented heap can have many free blocks, but these blocks are small and non-contiguous. imagine that you have a \"large\" (32 bytes) expanse of free memory: | | Now, allocate some of it (5 allocations): |aaaabbccccccddeeee | Now, free the first four allocations but not the fifth: | eeee | Now, try to allocate 16 bytes. Oops, I can't, even though there's nearly double that much free. On systems with virtual memory, fragmentation is less of a problem than you might think, because large allocations only need to be contiguous in virtual address space, not in physical address space. So in my example, if I had virtual memory with a page size of 2 bytes then I could make my 16 byte allocation with no problem. Physical memory would look like this: | ffffffffffffffeeeeff | whereas virtual memory (being much bigger) could look like this: ------------------------------------------------------... | eeeeffffffffffffffff ------------------------------------------------------... The classic symptom of memory fragmentation is that you try to allocate a large block and you can't, even though you appear to have enough memory free. Another possible consequence is the inability of the process to release memory back to the OS (because there's some object still in use in all the blocks it has allocated from the OS, even though those blocks are now mostly unused). Method to avoid: 1.First of all, use dynamic memory as little as possible. In most cases, you can use static or automatic storage instead of allocating objects dynamically. 2.Secondly, try to allocate large chunks rather than small ones. For example, instead of allocating a single object, allocate an array of objects at once, and use these objects when they are needed. (Like use reserve() for stl containers) If all these tips don't solve the fragmentation problem, you should consider building a custom memory pool. Implicit Memory Leak: memory not release to OS When you call free() or delete(), it will NOT really release any memory back to OS. Instead, that memory is kept with the same process until it is terminated. However, this memory can be reused for any future allocations by the same process. documentation for libc's free: Occasionally, free can actually return memory to the operating system and make the process smaller. Usually, all it can do is allow a later call to malloc to reuse the space. In the meantime, the space remains in your program as part of a free-list used internally by malloc. a little deeper by looking at other malloc/free family of functions and saw 'mallopt', and that you can actually change the way malloc/free behave (especially if you're using GNU libc -- pointers about other platform implementations would be helpful). One option that is interesting to look at is M_TRIM_THRESHOLD which: This is the minimum size (in bytes) of the top-most, releasable chunk that will cause sbrk to be called with a negative argument in order to return memory to the system. 昨天晚上，我徒弟跑过来讲，他的程序的内存占用居高不下，愿意是std::map的clear()没有效果。于是我让他用erase(begin,end); 试试也不行。 代码如下： View Code 用命令 top -p ps -ef | grep abc | grep -v grep | awk {'print $2'}, 一查看，占了104M物理内存。 开始我猜测是stl用了自己的缓冲池，clear()并没有归还给系统。于是我用了boost::unordered_map试试，一查看，占了78M物理内存（看来hashmap比红黑树既快又省空间）。 于是上网查询资料，stl有很多种allocator，默认采用是的new_allocator，并没有使用内存缓冲池，针对不同的应用场合，STL中实现了不同的Allocator。 gnu_cxx::new_allocator Simply wraps ::operator new and ::operator delete. gnu_cxx::malloc_allocator Simply wraps malloc and free. There is also a hook for an out-of-memory handler gnu_cxx::debug_allocator A wrapper around an arbitrary allocator A. It passes on slightly increased size requests to A, and uses the extra memory to store size information. gnu_cxx::pool_alloc A high-performance, single pool allocator. The reusable memory is shared among identical instantiations of this type. gnu_cxx::mt_alloc A high-performance fixed-size allocatorthat was initially developed specifically to suit the needs of multi threaded applications gnu_cxx::bitmap_allocato A high-performance allocator that uses a bit-map to keep track of the used and unused memory locations 发现stl提供的malloc.h有监控功能，于是修改为下面代码： #include #include #include #include #include using namespace std; using namespace boost; void release_map(void) { malloc_stats(); map testmap; sleep(2); for(int i=0; i 发现clear() 其实已经归还内存了，内存的持有是 system bytes 。显然，malloc并没有把这些内存归还给系统，而是缓存起来了。所以说，这个例子的罪魁祸首并不是STL，而是glibc的malloc。好吧，既然找到问题，那就要解决它，虽然glibc的缓存也是一番好意，但是由于实际运行环境不能等到什么用户heap空间内连续空闲内存数据超出一个阈值时才将这片内存归还给内核。 glibc管理内存目前采用的是ptmalloc2，我测试了google的tcmalloc和Jason Evans的jemalloc。 测试很简单，把包downlaod下来并解压，./configure && make && make install即可。 export $LD_PRELOAD=\"/usr/local/lib/libtcmalloc.so” 或者 export $LD_PRELOAD=\"/usr/local/lib/libjemalloc.so” (这个要根据自己的实际情况选择路径) 然后编译后可以用ldd查看程序的依赖库。 测试结果：tcmalloc也不归还给系统，而jemalloc的clear后不再占用物理内存。 徒弟问了一句jemalloc靠谱么，我想想淘宝的Tengine，facebook的folly，redis，firefox，freebsd都是用这个，应该是很靠谱的。你上线去测试看看。 附上一张内存分配性能比较图片： Image 1 - Performance valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./pega_iot_gateway_bin hello_world_lin.json 可以看到 memory lost 分成幾種類型： definitely lost: 真的 memory leak 了 indirectly lost: 間接的 memory leak，structure 本身發生 memory leak，而內部的 member 如果是 allocate 的出來的，一樣會 memory leak，但是只要修好前面的問題，後面的問題也會跟著修復 possibly lost: allocate 一塊記憶體，並且放到指標 ptr，但事後又改變 ptr 指到這會計一體的中間 (這一點我目前也不是很清楚，建議看原文說明) still reachable: 程式結束時有未釋放的記憶體，不過卻還有指標指著，通常會發生在 global 變數 如果不想 show possibly lost，可以加下面的參數 3.9版 --show-leak-kinds=definite 3.7版 --show-possibly-lost=no © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/1-Basic.html":{"url":"md/0-Basic/1-Basic/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Linux tagsstop Introduction Linux是kernel,加上GNU社群裡面的一堆應用程式,就成了現在的OS發行版本 Windows大多直接使用administrator,是病毒氾濫的推手 root權限大到可以自殺 Tool 永中Office VLC GIMP(Photoshop) 主要分支 RedHat Red Hat Enterprise Linux(RHEL) Slackware SUSE Linux Enterprise(SUSE) Debian Ubuntu 建議用CentOS,因為KVM開發與測試環境都是在RHEL進行,而CentOS是RHEL open source的衍生(RHEL要收費,免費版無法升級或技術支援) 圖形介面 X是一種協定 xorg則是實現X協定,提供圖形化使用者介面服務的server軟體 系統開機之後自動執行xorg 1992~2004只有XFree86(GPL),後來公司改授權條款,造成GNU社群不滿,於是衍生出了xorg. X client軟體有兩個,一個叫Window Manager(WM),一個叫Display Manager(DM) 透過startx啟動xorg與default WM GNOME: Metacity KDE: K Win DM是負責圖形介面的使用者登入,開機第一個執行,且無人能關掉它 XDM KDM GDM Mac OS Ｘ協議與Linux X不同,前者是binary,後者是純文字 There is more than one way to define \"memory leak\". In particular, there are two primary definitions of \"memory leak\" that are in common usage among programmers. The first commonly used definition of \"memory leak\" is, \"Memory was allocated and was not subsequently freed before the program terminated.\" However, many programmers (rightly) argue that certain types of memory leaks that fit this definition don't actually pose any sort of problem, and therefore should not be considered true \"memory leaks\". An arguably stricter (and more useful) definition of \"memory leak\" is, \"Memory was allocated and cannot be subsequently freed because the program no longer has any pointers to the allocated memory block.\" In other words, you cannot free memory that you no longer have any pointers to. Such memory is therefore a \"memory leak\". Valgrind uses this stricter definition of the term \"memory leak\". This is the type of leak which can potentially cause significant heap depletion, especially for long lived processes. The \"still reachable\" category within Valgrind's leak report refers to allocations that fit only the first definition of \"memory leak\". These blocks were not freed, but they could have been freed (if the programmer had wanted to) because the program still was keeping track of pointers to those memory blocks. In general, there is no need to worry about \"still reachable\" blocks. They don't pose the sort of problem that true memory leaks can cause. For instance, there is normally no potential for heap exhaustion from \"still reachable\" blocks. This is because these blocks are usually one-time allocations, references to which are kept throughout the duration of the process's lifetime. While you could go through and ensure that your program frees all allocated memory, there is usually no practical benefit from doing so since the operating system will reclaim all of the process's memory after the process terminates, anyway. Contrast this with true memory leaks which, if left unfixed, could cause a process to run out of memory if left running long enough, or will simply cause a process to consume far more memory than is necessary. Probably the only time it is useful to ensure that all allocations have matching \"frees\" is if your leak detection tools cannot tell which blocks are \"still reachable\" (but Valgrind can do this) or if your operating system doesn't reclaim all of a terminating process's memory (all platforms which Valgrind has been ported to do this). © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/2-Shell.html":{"url":"md/0-Basic/1-Basic/2-Shell.html","title":"Shell","keywords":"","body":"Shell tagsstart Linux Shell tagsstop Command readelf -d -t iothub_client_sample_http find ~~~ | xargs rm diff $(readlink $(which sh)) xxd readlink -f /proc/20361/fd/1 tee lsof md5sum stty -a ctrl+w = alt+back ctrl+ cp --parent echo \"${PWD##*/}\" = basename ${PWD} tr -d '\\n' ldd nm This happens to me a lot, too, and this thread is one of the top results when googling for \"restart cinnamon\". Unfortunately, the instructions don't work for me (only because the display number is wrong!). For future visitors, here's what I do that always helps me. How do I restart Cinnamon from the tty? Cinnamon freezes Switch tty. I usually go to tty6, Ctrl+Alt+F6 If you need to login first, do so. Type w (yes, just the letter) and press enter. This commands does a lot of different things, but you need it to figure out the number of the display you are using. The display number is in the column FROM. Mine is :0 (yes, including the colon). Assuming that cinnamon is already dead (which you would notice by the windows lacking titles and that you can't move different windows around, and perhaps even not being able to use the keyboard), you type export DISPLAY=:0; cinnamon &, and don't forget the colon. I add the ampersand (&) only not to keep that tty busy. This always works for me, and I don't lose open windows. Also, I keep these instructions in a file called restartcinnamon, which is just a text file. I keep the file in my Dropbox folder, so no matter what machine I am on I can just type cat ~/Dropbox/restartcinnamon if I need to be reminded of how to do it. sed -i '/speech_language/s/value=\\\".*\\\"/value=\"zh-TW\"/' alextext.launch 查看进程pid (1) ps ux | grep prog_name (2) pgrep prog_name 查看线程tid (1) ps -efL | grep prog_name (2) ls /proc/pid/task 系統如何判斷 32bits / 64bits 在嘿嘿星期四的討論學到, Mat: 用 file /bin/bash, 結果非常淺顯易懂. sudo service network-manager restart © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/3-Makefile.html":{"url":"md/0-Basic/1-Basic/3-Makefile.html","title":"Makefile","keywords":"","body":"Makefile tagsstart Linux Makefile tagsstop 前言 $? $@ $ -Wall : 顯示所有的警告訊息 ZMQOPTS='-lzmq -lczmq' LDADD is used by NetBSD in the bsd.prog.mk Makefile, which is used to build programs of the base distribution and some of the programs in pkgsrc. LDLIBS is used by NetBSD in the sys.mk Makefile, which is used for implicit rules. LDLIBS is also used by GNU Make. LIBS is used by the GNU ./configure scripts. © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/4-Markdown.html":{"url":"md/0-Basic/1-Basic/4-Markdown.html","title":"Markdown","keywords":"","body":"Markdown tagsstart Markdown tagsstop 特殊 刪除線 至中 我是微软雅黑 color=gray 背景色是：orange 值班人员 星期一 星期二 星期三 李强 张明 王平 註腳1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/5-GDB.html":{"url":"md/0-Basic/1-Basic/5-GDB.html","title":"GDB","keywords":"","body":"GDB tagsstart Linux GDB tagsstop All-Stop Mode In all-stop mode, whenever your program stops under gdb for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot. Conversely, whenever you restart the program, all threads start executing. This is true even when single-stepping with commands like step or next. In particular, gdb cannot single-step all threads in lockstep. Since thread scheduling is up to your debugging target's operating system (not controlled by gdb), other threads may execute more than one statement while the current thread completes a single step. Moreover, in general other threads stop in the middle of a statement, rather than at a clean statement boundary, when the program stops. You might even find your program stopped in another thread after continuing or even single-stepping. This happens whenever some other thread runs into a breakpoint, a signal, or an exception before the first thread completes whatever you requested. Whenever gdb stops your program, due to a breakpoint or a signal, it automatically selects the thread where that breakpoint or signal happened. gdb alerts you to the context switch with a message such as ‘[Switching to Thread n]’ to identify the thread. On some OSes, you can modify gdb's default behavior by locking the OS scheduler to allow only a single thread to run. set scheduler-locking mode Set the scheduler locking mode. It applies to normal execution, record mode, and replay mode. If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may run when the inferior is resumed. The step mode optimizes for single-stepping; it prevents other threads from preempting the current thread while you are stepping, so that the focus of debugging does not change unexpectedly. Other threads never get a chance to run when you step, and they are completely free to run when you use commands like ‘continue’, ‘until’, or ‘finish’. However, unless another thread hits a breakpoint during its timeslice, gdb does not change the current thread away from the thread that you are debugging. The replay mode behaves like off in record mode and like on in replay mode. show scheduler-locking Display the current scheduler locking mode. By default, when you issue one of the execution commands such as continue, next or step, gdb allows only threads of the current inferior to run. For example, if gdb is attached to two inferiors, each with two threads, the continue command resumes only the two threads of the current inferior. This is useful, for example, when you debug a program that forks and you want to hold the parent stopped (so that, for instance, it doesn't run to exit), while you debug the child. In other situations, you may not be interested in inspecting the current state of any of the processes gdb is attached to, and you may want to resume them all until some breakpoint is hit. In the latter case, you can instruct gdb to allow all threads of all the inferiors to run with the set schedule-multiple command. set schedule-multiple Set the mode for allowing threads of multiple processes to be resumed when an execution command is issued. When on, all threads of all processes are allowed to run. When off, only the threads of the current process are resumed. The default is off. The scheduler-locking mode takes precedence when set to on, or while you are stepping and set to step. show schedule-multiple Display the current mode for resuming the execution of threads of multiple processes. © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/1-什麼是 mininet/":{"url":"md/2-Mininet/1-什麼是 mininet/","title":"什麼是 mininet","keywords":"","body":"什麼是 mininet tagsstart mininet tagsstop 什麼是 mininet mininet是一個用python寫的一個Process 這個Process是一個網路模擬器(network emulator) 或者更精確的說：網路拓樸模擬器(network emulation orchestration system) 既然叫拓樸模擬器，代表它模擬了一整個:終端主機(end-hosts),路由器(router),交換器(switches)的集成系統 模擬網路系統可以做什麼？ 通常透過mininet模擬的架構,會與實際透過硬體架設的結果一致，因此可做為實體配線前的臨摹 mininet模擬的host行為跟真的一樣：你可以SSH(Secure Shell)進去並運行任意程式，也可以運行server 你也可以送出封包，就像透過真的乙太網路出去，有link speed & delay，可以觀察封包來往的狀況 可以輕易的製作支援SDN的區域網路 (後面會介紹什麼是SDN)，事實上，mininet是很適合作為一個輕量級的SDN仿真工具 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/2-什麼是 SDN/":{"url":"md/2-Mininet/2-什麼是 SDN/","title":"什麼是 SDN","keywords":"","body":"什麼是 SDN tagsstart mininet SDN tagsstop 什麼是 SDN？ 全名是：軟體定義式網路（Software defined Networking，SDN） 要了解SDN之前，要先了解現今網路架構中，路由器除了硬體上俱備有轉送資料的能力外， 對於資料的移動控制，都是在每一台路由器中， 實作著遵守各種傳輸協定的控制軟體 例如連結層有擴展樹協定（Spanning Tree Protocol，STP）來防止封包卡在迴圈 雖然協定是共通的，但網通廠商各有各的OS與實作技術，導致一旦企業購買某一廠牌的設備， 未來更新設備時就必須遷就於該廠牌的網管功能，造成被網通廠商挾持的情形 現今這樣不是沒什麼問題嘛？ 隨著隨著雲端應用及巨量資料增加，路由表越來越龐大，判斷轉送的過程愈來愈複雜 而這些判斷需要路徑上的每一台交換器或是路由器不斷的拆分及重組封包 可想而知，結果導致傳輸效率不佳，無法有效發揮網路頻寬 網路管理人員需要客製調整各種網路設定時，也必須針對每臺交換器或路由器，逐一登入command-line設定，相當麻煩 而且透過人工逐一設定的方式也有很高的風險，一旦網路管理人員輸入了錯誤的指令，很容易造成網路服務癱瘓 於是關於控制封包這件事情，我們需要重新思考：真的需要每一台路由器拆開封包才能判斷嘛？ 所以SDN做了什麼？ 它的概念是：將網路分為控制層（Control Plane）與資料層（Data Plane） 將網路的管理權限交由控制層的控制器（Controller）軟體負責，採用集中控管的方式，同時也負責決定傳輸路徑 Image 1 - SDN SDN帶來的好處？ 讓網路的管理變得更集中 自動處理與動態因應變化 讓網路的設計、部署、管理、規模延展更為容易 可以減少IT服務日常維運，減少人為出錯 既然傳輸路徑已預先設定完成，交換器不需要透過不斷學習來尋找封包傳送的路徑，可大幅提升傳輸效率，降低延遲（Latency）的時間 可節省支出 所以網通廠怎麼看SDN？ SDN使得交換器的重要性將會不如以往 (功能會越來越單純，未來可能僅負責封包的傳送) 未來客製化的軟體就可以提供各項硬體設備的功能 於硬體設備廠商來說，將會是一大衝擊 臺灣企業還不了解SDN在未來的重要性，而且開發SDN應用程式的門檻較高 Google、Facebook、Yahoo、微軟等多家指標型的大企業投入了SDN架構與OpenFlow技術的發展 我剛好像看到OpenFlow，那是什麼？ 跟SDN是什麼關係 OpenFlow是實現SDN架構最主流的核心技術，也就是網路交換器(switch)和控制器(controller)之間的傳輸協定 就像是人類的神經一樣，負責大腦與四肢的溝通 OpenFlow技術將封包傳送的路徑看成是一條「Flow」，就好像是專屬的傳輸路徑 例如經過哪些交換器，需要多少的網路頻寬，再將傳輸路徑設定成OpenFlow路由表（Flow Table） 控制層和資料層之間，利用SSL加密，建立起安全的傳輸通道 但它只是整體SDN架構的一部分，而且也並非唯一可用的協定 OpenFlow是SDN的一部分，但SDN不是只有OpenFlow Image 2 - OpenFlow © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/3-mininet 實戰/":{"url":"md/2-Mininet/3-mininet 實戰/","title":"mininet 實戰","keywords":"","body":"mininet 實戰 tagsstart mininet tagsstop 安裝 Debian Package sudo apt-get install mininet Build source and install git clone git://github.com/mininet/mininet mininet/util/install.sh -a 啟動 在沒有任何參數下，產生的虛擬環境為兩個host (h1,h2)，一個switch (s1)，並將h1,h2連接s1 Image 1 - Topology 啟動sudo mn Image 2 - mn mininet是基於OVS的應用軟體，當沒有設定OVS Controller時，他會退回OVS Bridge模式(不依賴Controller，預設所有node都是可以連通的) OVS:全名Open vSwitch，類似VM，主要是虛擬switch，支援OpenFlow 測試 顯示所有節點nodes Image 3 - nodes 顯示所有節點的連接關係net Image 4 - net 察看所有節點的資訊:dump Image 5 - dump 用h1 ping h2 一個封包h1 ping -c 1 h2 Image 6 - ping 叫出兩個host的命令視窗xterm h1 h2 Image 7 - xterm Mininet Python API Topo: Mininet拓撲結構的base class build(): The method to override in your topology class. Constructor parameters (n) will be passed through to it automatically by Topo.init(). addSwitch(): 給拓撲結構中增加一個switch，返回switch名字 addHost(): 增加host，返回host名字 addLink(): 增加一個雙向link，返回link的key Mininet: 建立和管理網路的main class start(): 開啟網路 pingAll(): 通過host之間的互ping測試連通性 stop(): 關閉網絡 net.hosts: 網路中的所有主機 dumpNodeConnections(): 所有的連接關係 setLogLevel( 'info' | 'debug' | 'output' ): set Mininet's default output level; 'info' is recommended as it provides useful information. 寫一個Python範例 目標 啟動50個hosts，作為VM server farm 啟動1個controller 啟動1個switch Image 8 - Server Farm Code example #!/usr/bin/python import re from mininet.net import Mininet from mininet.node import Controller from mininet.cli import CLI from mininet.link import Intf from mininet.log import setLogLevel, info, error from mininet.util import quietRun from mininet.node import OVSController def checkIntf( intf ): \"Make sure intf exists and is not configured.\" if ( ' %s:' % intf ) not in quietRun( 'ip link show' ): error( 'Error:', intf, 'does not exist!\\n' ) exit( 1 ) ips = re.findall( r'\\d+\\.\\d+\\.\\d+\\.\\d+', quietRun( 'ifconfig ' + intf ) ) if ips: error( 'Error:', intf, 'has an IP address and is probably in use!\\n' ) exit( 1 ) def myNetwork(): net = Mininet( topo=None, build=False) info( '*** Adding controller\\n' ) net.addController(name='c0',controller = OVSController) info( '*** Add switches\\n') s1 = net.addSwitch('s1') max_hosts = 50 newIntf = 'enp3s0' host_list = {} info( '*** Add hosts\\n') for i in xrange(1,max_hosts+1): host_list[i] = net.addHost('h'+str(i)) info( '*** Add links between ',host_list[i],' and s1 \\r') net.addLink(host_list[i], s1) info( '*** Checking the interface ', newIntf, '\\n' ) checkIntf( newIntf ) switch = net.switches[ 0 ] info( '*** Adding', newIntf, 'to switch', switch.name, '\\n' ) brintf = Intf( newIntf, node=switch ) info( '*** Starting network\\n') net.start() CLI(net) net.stop() if __name__ == '__main__': setLogLevel( 'info' ) myNetwork() 執行 sudo python example.py Image 9 - example Q&A 執行出現Cannot find required executable ovs-controller 你沒有安裝ovs-controller sudo apt-get install openvswitch-testcontroller ovs-controller是舊名稱，所以你需要複製一下 sudo cp /usr/bin/ovs-testcontroller /usr/bin/ovs-controller 執行出現 Exception: Please shut down the controller which is running on port 6653: Active Internet connections (servers and established) tcp 0 0 0.0.0.0:6653 0.0.0.0:* LISTEN 30215/ovs-testcontr 你需要kill正在背景執行的ovs-testcontroller sudo netstat -lptu sudo service ovs-testcontroller stop Mininet建立網路的三種方式 底層API Node & Link h1 = Host( 'h1' ) h2 = Host( 'h2' ) s1 = OVSSwitch( 's1', inNamespace=False ) c0 = Controller( 'c0', inNamespace=False ) Link( h1, s1 ) Link( h2, s1 ) h1.setIP( '10.1/8' ) h2.setIP( '10.2/8' ) c0.start() s1.start( [ c0 ] ) print h1.cmd( 'ping -c1', h2.IP() ) s1.stop() c0.stop() 中層API net Object net = Mininet() h1 = net.addHost( 'h1' ) h2 = net.addHost( 'h2' ) s1 = net.addSwitch( 's1' ) c0 = net.addController( 'c0' ) net.addLink( h1, s1 ) net.addLink( h2, s1 ) net.start() print h1.cmd( 'ping -c1', h2.IP() ) CLI( net ) net.stop() 上層API Topology Object class SingleSwitchTopo( Topo ): \"Single Switch Topology\" def __init__( self, count=1, **params ): Topo.__init__( self, **params ) hosts = [ self.addHost( 'h%d' % i ) for i in range( 1, count + 1 ) ] s1 = self.addSwitch( 's1' ) for h in hosts: self.addLink( h, s1 ) net = Mininet( topo=SingleSwitchTopo( 3 ) ) net.start() CLI( net ) net.stop() © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/1-Network Namespace.html":{"url":"md/2-Mininet/4-運作原理/1-Network Namespace.html","title":"Network Namespace","keywords":"","body":"Network Namespace Mininet虛擬化的核心機制是？ Linux Network Namespace是Mininet軟體架構的基石，用其創建虛擬節點 需要先了解Linux Namespace 之中的 Network Namespaces 預設情況下，Mininet會為每一個host創建一個新的Network Namespaces 由於每個host都有各自獨立的Network Namespaces，我們就可以進行個性化的網路配置和程式佈署 Switch和Controller運行在root Namespace，因此兩個Processes共享同一個Network Namespaces 由於Linux Namespace的虛擬技術沒有提供類似於VM的持久化能力，所以在Mininet關閉時不能保存所有設定 Mininet建立的Network namespace是nameless的，所以透過ip netns list是查看不到的 而透過ip netns add建立的Network Namespace是帶name的，這是兩者最明顯的區別之處Discussions Linux Network Namespace在OpenStack和Docker等開源項目中也廣泛應用主要用於作業系統層級的虛擬化，包含虛擬網路 解釋一下，上一個的範例與namespace的關聯 範例中Host H1和Host H2連接到運行在Kernel的root namespace的Switch S1 H1和H2擁有自己的網路匿名命名空間以及私有網路接口h1-eth0和h2-eth0 S1有兩個埠s1-eth1和s1-eth2，通過veth pair與Host接口相連，這樣H1和H2就可以透過S1進行交流 s1-eth0和s1-eth1間的data轉發透過S1完成，並使用實體接口eth0，等待Controller的指令 Image 1 - Example1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/2-Node.html":{"url":"md/2-Mininet/4-運作原理/2-Node.html","title":"Node","keywords":"","body":"Node Node是什麼？ 每個Host其實就是一個Node的物件，可以在node.py中看到此物件的定義 node.py class Node( object ): portBase = 0 # Nodes always start with eth0/port0, even in OF 1.0 def __init__( self, name, inNamespace=True, **params ): self.checkSetup() self.name = params.get( 'name', name ) self.privateDirs = params.get( 'privateDirs', [] ) self.inNamespace = params.get( 'inNamespace', inNamespace ) ... # Start command interpreter shell self.startShell() self.mountPrivateDirs() inToNode = {} # mapping of input fds to nodes outToNode = {} # mapping of output fds to nodes 初始時，會有一個變數inNamespace用來決定此Host是否要透過network namespaces來達到network isolation的功能 當變數都初始化後，就會呼叫startShell()來啟動此Host node.py def startShell( self, mnopts=None ): \"Start a shell process for running commands\" if self.shell: error( \"%s: shell is already running\\n\" % self.name ) return # mnexec: (c)lose descriptors, (d)etach from tty, # (p)rint pid, and run in (n)amespace opts = '-cd' if mnopts is None else mnopts if self.inNamespace: opts += 'n' # bash -i: force interactive # -s: pass $* to shell, and make process easy to find in ps # prompt is set to sentinel chr( 127 ) cmd = [ 'mnexec', opts, 'env', 'PS1=' + chr( 127 ), 'bash', '--norc', '-is', 'mininet:' + self.name ] master, slave = pty.openpty() self.shell = self._popen( cmd, stdin=slave, stdout=slave,stderr=slave,close_fds=False ) ... 可以觀察到，mininet是透過一隻叫做mnexec的程式來執行，並且透過參數-n來將此process給轉換到network namespaces中 所以建立完Host以後，可以使用ip來看？ 理論上我們要可以透過ip netns show來看到這些network namespaces，實際上卻看不到 原因如同此篇所說，由於建立的為nameless network namespaces Host是Node，那Switch呢？ 建立Switch包含了四種選擇OVSLegacyKernelSwitch、UserSwitch、OVSSwitch，IVSSwitch 一般常用的就是OVSSwitch 這四種Switch都繼承自Switch物件，而Switch物件則繼承自Node © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/3-Link.html":{"url":"md/2-Mininet/4-運作原理/3-Link.html","title":"Link","keywords":"","body":"Link 接下來會根據拓墣的Link情況，去創建對應的Interface 首先，這邊使用到Link這個物件來表示每一條Link 每個Link實際上對應到的是兩個Node上面的Interface link.py class Link( object ): \"\"\"A basic link is just a veth pair. Other types of links could be tunnels, link emulators, etc..\"\"\" # pylint: disable=too-many-branches def __init__( self, node1, node2, port1=None, port2=None, intfName1=None, intfName2=None, addr1=None, addr2=None, intf=Intf, cls1=None, cls2=None, params1=None, params2=None, fast=True ): \"\"\"Create veth link to another node, making two new interfaces. node1: first node node2: second node port1: node1 port number (optional) port2: node2 port number (optional) intf: default interface class/constructor cls1, cls2: optional interface-specific constructors intfName1: node1 interface name (optional) intfName2: node2 interface name (optional) params1: parameters for interface 1 params2: parameters for interface 2\"\"\" # This is a bit awkward; it seems that having everything in # params is more orthogonal, but being able to specify # in-line arguments is more convenient! So we support both. if params1 is None: params1 = {} if params2 is None: params2 = {} # Allow passing in params1=params2 if params2 is params1: params2 = dict( params1 ) if port1 is not None: params1[ 'port' ] = port1 if port2 is not None: params2[ 'port' ] = port2 if 'port' not in params1: params1[ 'port' ] = node1.newPort() if 'port' not in params2: params2[ 'port' ] = node2.newPort() if not intfName1: intfName1 = self.intfName( node1, params1[ 'port' ] ) if not intfName2: intfName2 = self.intfName( node2, params2[ 'port' ] ) self.fast = fast if fast: params1.setdefault( 'moveIntfFn', self._ignore ) params2.setdefault( 'moveIntfFn', self._ignore ) self.makeIntfPair( intfName1, intfName2, addr1, addr2, node1, node2, deleteIntfs=False ) 這邊要觀察到的，Link物件會呼叫makeIntfPair此方法，此方法就可以將兩個Interface給串接起來 util.py def makeIntfPair( intf1, intf2, addr1=None, addr2=None, node1=None, node2=None, deleteIntfs=True, runCmd=None ): \"\"\"Make a veth pair connnecting new interfaces intf1 and intf2 intf1: name for interface 1 intf2: name for interface 2 addr1: MAC address for interface 1 (optional) addr2: MAC address for interface 2 (optional) node1: home node for interface 1 (optional) node2: home node for interface 2 (optional) deleteIntfs: delete intfs before creating them runCmd: function to run shell commands (quietRun) raises Exception on failure\"\"\" if not runCmd: runCmd = quietRun if not node1 else node1.cmd runCmd2 = quietRun if not node2 else node2.cmd if deleteIntfs: # Delete any old interfaces with the same names runCmd( 'ip link del ' + intf1 ) runCmd2( 'ip link del ' + intf2 ) # Create new pair netns = 1 if not node2 else node2.pid if addr1 is None and addr2 is None: cmdOutput = runCmd( 'ip link add name %s ' 'type veth peer name %s ' 'netns %s' % ( intf1, intf2, netns ) ) else: cmdOutput = runCmd( 'ip link add name %s ' 'address %s ' 'type veth peer name %s ' 'address %s ' 'netns %s' % ( intf1, addr1, intf2, addr2, netns ) ) if cmdOutput: raise Exception( \"Error creating interface pair (%s,%s): %s \" % ( intf1, intf2, cmdOutput ) ) 這邊可以看到，mininet實際上是透過系統中的ip link的方法，將兩個interface創造一條veth的Link 此時，我們的系統如下 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/4-Interface.html":{"url":"md/2-Mininet/4-運作原理/4-Interface.html","title":"Interface","keywords":"","body":"Interface 接下來我們要把這些interface給綁到特定的Node身上 在Link物件初始化後段，會去初始化兩個Interface真正的物件本體 link.py class Intf( object ): \"Basic interface object that can configure itself.\" def __init__( self, name, node=None, port=None, link=None, mac=None, **params ): \"\"\"name: interface name (e.g. h1-eth0) node: owning node (where this intf most likely lives) link: parent link if we're part of a link other arguments are passed to config()\"\"\" self.node = node self.name = name self.link = link self.mac = mac self.ip, self.prefixLen = None, None # if interface is lo, we know the ip is 127.0.0.1. # This saves an ifconfig command per node if self.name == 'lo': self.ip = '127.0.0.1' # Add to node (and move ourselves if necessary ) moveIntfFn = params.pop( 'moveIntfFn', None ) if moveIntfFn: node.addIntf( self, port=port, moveIntfFn=moveIntfFn ) else: node.addIntf( self, port=port ) # Save params for future reference self.params = params self.config( **params ) 這邊要觀察的重點是每個Interface都會去呼叫node.addIntf( self, port=port )來處理 node.py def addIntf( self, intf, port=None, moveIntfFn=moveIntf ): \"\"\"Add an interface. intf: interface port: port number (optional, typically OpenFlow port number) moveIntfFn: function to move interface (optional)\"\"\" if port is None: port = self.newPort() self.intfs[ port ] = intf self.ports[ intf ] = port self.nameToIntf[ intf.name ] = intf debug( '\\n' ) debug( 'added intf %s (%d) to node %s\\n' % ( intf, port, self.name ) ) if self.inNamespace: debug( 'moving', intf, 'into namespace for', self.name, '\\n' ) moveIntfFn( intf.name, self ) 此方法最後會呼叫moveIntf來將該interface給處理，moveIntf則會呼叫moveIntfNoRetry將Interface給綁入到每個Node中 util.py def moveIntf( intf, dstNode, printError=True, retries=3, delaySecs=0.001 ): \"\"\"Move interface to node, retrying on failure. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" retry( retries, delaySecs, moveIntfNoRetry, intf, dstNode, printError=printError ) def moveIntfNoRetry( intf, dstNode, printError=False ): \"\"\"Move interface to node, without retrying. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" intf = str( intf ) cmd = 'ip link set %s netns %s' % ( intf, dstNode.pid ) cmdOutput = quietRun( cmd ) # If ip link set does not produce any output, then we can assume # that the link has been moved successfully. if cmdOutput: if printError: error( '*** Error: moveIntf: ' + intf + ' not successfully moved to ' + dstNode.name + ':\\n', cmdOutput ) return False return True 可以看到，透過指令ip link set %s netns %s，將特定的interface塞入特定Node的namespace之中 此時，我們的系統如下 Image 1 - 拓墣 最後OVSSwitch透過ovs-vsctl add-port將Switch上面的Interface都給OVS控管 node.py def attach( self, intf ): \"Connect a data port\" self.vsctl( 'add-port', self, intf ) self.cmd( 'ifconfig', intf, 'up' ) self.TCReapply( intf ) def vsctl( self, *args, **kwargs ): \"Run ovs-vsctl command (or queue for later execution)\" if self.batch: cmd = ' '.join( str( arg ).strip() for arg in args ) self.commands.append( cmd ) else: return self.cmd( 'ovs-vsctl', *args, **kwargs ) © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Namespace/1-簡介/":{"url":"md/1-Namespace/1-簡介/","title":"簡介","keywords":"","body":"簡介 tagsstart Namespace tagsstop 什麼是Namespace？ 命名空間就是在大箱子(Kerne)裏面再裝一堆小箱子(Kernel Namespace) 為什麼要這麼做？ 因為如果我們想在箱子裏面放兩個外觀一模一樣的蘋果(Process)，到時候一定會無法區分 不如就放在A箱子裡面的蘋果，叫作A蘋果；放在B箱子裡面的蘋果，叫作B蘋果 命名空間有幾種？ Linux 2.6.24版的Kernel開始,提供了6種不同類型的Namespace 分別是： 程序間通信(IPC)命名空間 程序命名空間 網絡命名空間 掛載命名空間 UTS命名空間 用戶命名空間 所以有人說Namespaces是一種資源隔離方案，使得PID、Network、IPC等系統資源，不再屬於全域設定，而是某個特定的Namespace的資源 還有其他好處嘛？ 通過Namespace技術使得用戶創建的程序能夠與系統分離得更加徹底，從而不需要使用更多的底層(硬體支援)虛擬化技術 因為Namespaces是用純軟體劃分出來的概念 Namespace之間有關聯嘛？ Namespace之間的資源互相隔離、不可見的 因此在作業系統的層面上看，就會出現多個相同pid的Process User要怎麼看待Namespace 在用戶層面上只能看到屬於用戶自己Namespace下的資源 例如使用ps命令只能列出自己Namespace下的程序 使用者角度來看,每個Namespace看上去就像一個單獨的Linux系統 Image 1 - Linux的命名空間技術架構 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Namespace/2-Network namespaces/1-什麼是Network Namespace.html":{"url":"md/1-Namespace/2-Network namespaces/1-什麼是Network Namespace.html","title":"什麼是Network Namespace","keywords":"","body":"什麼是Network Namespace tagsstart Namespace Network namespace tagsstop 什麼是Network namespace 虛擬化網路相關的功能 Linux近幾年特有的技術(Darwin/Windows無類似功能)(約Kernel 3.0開始才有) 是輕量級虛擬化技術的基礎（Docker,LXC,OpenVZ的原理） 多用在虛擬化和隔離 很少被單獨使用 虛擬化網路相關的功能,是指哪些？ 不同Network namespace內的Process,具有不同的Network資源如下： 虛擬網卡列表 IPv4和IPv6協議 Routing Table 防火牆設定 /proc/net目錄 /sys/class/net目錄 埠（socket） 有什麼特性？ 簡單說就是幾個Process之間搞小團體，小團體有私有網路資源，且小團體之間互不干擾 多用在虛擬化和隔離 如果Network Namespace之間要互相溝通怎麼辦? 在不同的Network namespace間創建通道：veth pair（虛擬網路設備對接口） 不同Network Namespace因為veth pair得以共享同一個實體網路設備 傳統沒有Network natags: Namespace,Network namespacemespace前是怎樣？ 一般乙太網路應用程式 Image 1 - 一般乙太網路應用程式 如果是ADSL/光世代的PPPoE Image 2 - PPPoE 如果是VPN Image 3 - VPN 網卡拿來當Hub用的Bridge Image 4 - Bridge Bridge相關指令: 需要安裝bridge-utils才能使用brctl brctl show - 顯示bridge狀況 brctl addbr/delbr - 新增/刪除bridge brctl addif - 將interface新增至bridge brctl delif - 將interface從bridge移除 有Network namespace後是怎樣？ 只有一個Network namespace的話 Image 5 - 一個Network namespace 複數Network namespace的話 Image 6 - 複數Network namespace 透過veth可以連接兩個Network namespace Image 7 - veth 搭配Bridge使其他Network namespace上網 Image 8 - Bridge+Network namespace 有什麼應用場景？ 多個Network namespace可以共享eth0和lo等實體網路設備 多個Apache伺服器Process可以在不同Network namespace的80埠上進行監聽 一個Process不能嗅探其他Network namespace的流量 一個Process不能關閉其他Network namespace的接口 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Namespace/2-Network namespaces/2-範例.html":{"url":"md/1-Namespace/2-Network namespaces/2-範例.html","title":"範例","keywords":"","body":"範例 tagsstart Namespace Network namespace tagsstop 此範例的目標是？ 使用ip創建H1和H2兩個Network namespace H1擁有自己的Network namespace以及私有網路網路接口h1-eth0 H2擁有自己的Network namespace以及私有網路網路接口h2-eth0 使用ovs-vsctl創建Software Switch S1 S1有兩個埠s1-eth0和s1-eth1 S1運行在root namespace,並使用實體接口eth0，等待Controller的指令 使用veth pair與對應的Host接口相連，這樣H1和H2就可以透過S1溝通 s1-eth0和s1-eth1間的通訊資料透過Software Switch轉發 Image 1 - Example1 什麼是ip command? ip這個command是iproute2軟體包裡面的一個強大的網路配置工具 它能夠替代一些傳統的網路管理工具，例如:ifconfig、route 使用權限要為root 幾乎所有的Linux發行版本都支持該command 介紹ip command吧 ip netns add - 新增NetNS ip netns list - 列出現有的NetNS ip netns identify - 顯示PID所在的NetNS ip netns identify $$ - 顯示目前的NetNS ip netns exec - 在Network namespace執行command ip link add type veth peer name - 建立一個veth裝置 ip link set nets - 將veth搬到NetNS Step 1 - Create host namespaces 建立H1 namespaces sudo ip netns add h1 建立H2 namespaces sudo ip netns add h2 察看建立結果 sudo ip netns Image 2 - Step 1-Result Image 3 - Step 1-Topo Step 2 - Create switch 建立Switch sudo ovs-vsctl add-br s1 Image 4 - Step 2-Topo Step 3 - Create links 建立Link 1(h1-eth0 - s1-eth1) sudo ip link add h1-eth0 type veth peer name s1-eth1 建立Link 2(h2-eth0 - s1-eth2) sudo ip link add h2-eth0 type veth peer name s1-eth2 顯示連結結果 sudo ip link show Image 5 - Step 3-Result Step 4 - Move host ports into namespaces 將H1 port移到H1 namespaces sudo ip link set h1-eth0 netns h1 將H2 port接到H2 namespaces sudo ip link set h2-eth0 netns h2 顯示H1 namespaces的連結 sudo ip netns exec h1 ip link show 顯示H2 namespaces的連結 sudo ip netns exec h2 ip link show Image 6 - Step 4-Result Image 7 - Step 4-Topo Step 5 - Connect switch ports to OVS 將S1 port1連接到Switch sudo ovs-vsctl add-port s1 s1-eth1 將S1 port2連接到Switch sudo ovs-vsctl add-port s1 s1-eth2 顯示Switch的連結 sudo ovs-vsctl show Image 8 - Step 5-Topo Step 6 - Set up OpenFlow controller 設定Controller sudo ovs-vsctl set-controller s1 tcp:127.0.0.1 設定Controller監聽端口OpenFlow TCP（默認值:6633) sudo ovs-controller ptcp: 查詢OpenFlow Controller是否正確連接到S1 sudo ovs-vsctl show Image 9 - Step 6-Result Step 7 - Configure network 修改H1 port網路介面，給予H1 eth0一個 10.0.0.1 的參數 sudo ip netns exec h1 ifconfig h1-eth0 10.1 啟動H1 eth0網路介面 sudo ip netns exec h1 ifconfig lo up 修改H2 port網路介面，給予H2 eth0一個 10.0.0.2 的參數 sudo ip netns exec h2 ifconfig h2-eth0 10.2 啟動H2 eth0網路介面 sudo ip netns exec h2 ifconfig lo up 啟動Switch網路介面 sudo ifconfig s1-eth1 up sudo ifconfig s1-eth2 up Step 8 - Test network 透過H1網路介面Ping H2網路介面 sudo ip netns exec h1 ping -c1 10.2 Image 10 - Step 8-Result Image 11 - Final-Result © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/1-Basic/Readme.html":{"url":"md/4-Alljoyn/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Alljoyn Framework tagsstop Properties GetAllProperties GetAll - a{sv} c++ © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/2-Gateway/1-架構說明.html":{"url":"md/4-Alljoyn/2-Gateway/1-架構說明.html","title":"架構說明","keywords":"","body":"架構說明 tagsstart Alljoyn Framework Gateway tagsstop 名詞定義 縮寫 描述 GM App Gateway Management app WKN Well-Know Name，有別於About的建立session方式 ACL Access Control List Config file 描述Alljoyn router的Policy(Allow or Deny) SLS Sessionless Signal 什麼是Alljoyn Gateway? 基於Alljoyn Framework所開發的一套Framework 主旨是快速開發一套：管理裝置行為、設定操作權限、雲端控制的一系列功能 講白一點，就是有一份XML，記錄著每個Alljoyn service內的成員們是否公開，或者是只允許被某個Alljoyn Client控制 接下來的內容，會將這份XML稱為ACL(Access Control List) Image 1 - ACL - Access Control List ACL實際上是去更新Alljoyn router的防火決策，而Alljoyn router把決策記錄在一份Configure file 將Alljoyn router視為一道防火牆，有一份通行決策(Configure file) Image 2 - Configure file ACL可以有很多份，但只有一份會生效(Activity) 在這Framework下，產生了三個負責不同職責的角色 Gateway Management app Connector app Control app 介紹一下角色的職責吧 在介紹職責之前，我必須要先講解我們想要的目標、架構與流程 我們希望可以透過網路來控制Device，無論區網或外網 區網：Control App透過Alljoyn機制直接控制Device 外網：Control App登入Cloud，並呼叫有註冊且在線的Connector來控制Device Image 3 - 架構 因此，我們需要有Control App,Connector App 再來，我想指定Alljoyn service的一部分成員公開，或只允許被某些Alljoyn Client控制 所以我要建立一份ACL，來更新Configure file 或是建立多份ACL，但只有一個生效 建立並修改ACL的工作，將交由使用者登入Control App後進行操作 基於安全因素，ACL只被允許在區網內透過Control App修改 而維護ACL，並更新Configure file的工作，交給GM app處理 Image 4 - 流程 GM App為了將當前配置上傳至Cloud，需要與Connector建立Non Session連線(透過WKN機制) 一個Connector對應一個Cloud，也對應一份目前正在運行的ACL Image 5 - 對應關係 基於安全因素，Connector與GM App是使用不同Linux User分別執行 GM App的職責是？ 管理ACL：透過About機制，使能被Control App搜尋並建立Session 更新Config File：根據ACL的啟動/關閉，來更新Config File Config File的機制為透過(Allow / Deny) Linux (User / Group) 來建立Alljoyn router Policy 提供列出ACL的Method給Connector呼叫 透過WKN與Connector建立Non Session連線 WKN是規格寫死的名稱： GM app WKN：org.alljoyn.GWAgent.GMApp Connector app WKN：org.alljoyn.GWAgent.Connector. Connector的職責是？ 與Cloud建立連線並傳輸/接收資料 在Config File允許的情況下，與Device互動 位於Cloud與Alljoyn Device的之間，將Alljoyn資料與Cloud資料做Protocol的轉換 透過GM App所發出的Signal來了解ACL是否已經被更新/刪除 透過GM App取得正在啟用的ACL Control App的職責是？ 以下所敘述的功能不一定全部包含，由服務提供商自行定義，有可能只包含一部分的功能 擁有建立/刪除/啟動/關閉/更新ACL的功能與UI介面 與服務提供商的Cloud建立User login的機制 控制Device行為 Alljoyn Router的職責是？ 正確執行Config File所記載的Policy Control App有什麼Secure機制嗎？ 由於GM App提供操作ACL的Interface必須是嚴格控管的，Control App要使用此Interface的Method前，必須輸入Password/PIN GM App應該內建Default的Password/PIN，並於Control App登入後，交由User自行修改 Image 6 - Secure Gateway的各項流程圖 Gateway Discover Image 7 - Gateway Discover 管理ACL Create ACL Image 8 - Create ACL Activate ACL Image 9 - Activate ACL Connector startup Image 10 - Connector startup Update ACL Image 11 - Update ACL Delete ACL Image 12 - Delete ACL Disable ACL Image 13 - Disable ACL Notification 送出 Notification Image 14 - 送出 Notification 接收 Notification Image 15 - 接收 Notification 控制AllJoyn Device 呼叫Method Image 16 - 呼叫Method Get property Image 17 - Get property Set property Image 18 - Set property Remoting session-based signal Image 19 - session-based signal 與ACL相關的成員 GM app管理ACL的部分 Method Create profile Activate profile Get profile GetProfileStatus GetProfileList Update profile Delete profile Deactivate profile Connector提供給外網的部分 Method Get profile Update connection status Signal Profile updated Profile deleted Shutdown App Config File Config File內的Policy應該要使GM App能收到所有設備的About(Default) GM App啟動時，應該基於已經安裝的Connector ID，建立Deny-all的Policy GM App應該根據ACL修改Config File內的Policy 當Active的ACL被Disable或是Delete時，GM App要移除與此ACL相關的Policy Policy可以Allow/Deny Connector發出Notification Policy可以Allow/Deny Connector接收某Device的Notification Policy可以Allow/Deny Connector對發出Signal Policy可以Allow/Deny Connector接收某Device的Signal Policy可以Allow/Deny Connector呼叫某Device的Method Config File的Policy會隨著Runtime而不斷改變 Config File的Reload有兩種方法，一種是取得Bus的ProxyBusObject並引用其Interface的Method；另一種是發送平台訊號(如Kill xxx)來觸發 GM App採用前者的方式 Connetor與Cloud的架構與設計 架構 服務提供商在Cloud端建立App Download Server，管理所有可供下載的Connector Package Control App於User login Cloud後，提供UI介面，便於User從App Download Server下載Connector Package，且提Install/Upgrade等UI介面。 基於上面的需求，GM App必須提供一個Interface給Control App，以便管理Connector Package的Install/Upgrade/Uninstall/Restart 基於安全考量，應由Package Manager(PM)管理需要安裝的Connector Package並驗證數位簽章是否符合 PM與GM App互動的實作與細節不在此討論內。 Image 20 - Cloud & Connector Install或其他Method被呼叫時，實際上Control App將URL傳給GM App，並交由PM下載、驗證、安裝並分配一個唯一Linux User給此Connector Package當作識別 每一個被安裝的Connector Package都有被分配到一個唯一的Linux User Connector Package被分配到的Linux User都屬於同一個Group GM App應該將已經安裝的Connector Package紀錄成一個表格，包含 Connector Id App Name App Package Name App version App package File URL App User Id App Group Id Install Status Install Description Connection Status Operational Status 所有Connector Package內，在預定位置必須含有manifest file，來描述此Connector提供的Service，以及預期能與之互動的Interface 設計細節 App Management interface Method Install App Uninstall App Restart App Get App Status Get Installed Apps Get Manifest Data Get Manifest Interfaces Signal App Status Changed Package Manager app functions Method Install App Uninstall App Manifest file Install App App Package Name App version Min AJ SDK version exposed Services List execution Info 外部連結： Alljoyn Gateway wiki © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/2-Gateway/2-啟動流程 & 程式碼.html":{"url":"md/4-Alljoyn/2-Gateway/2-啟動流程 & 程式碼.html","title":"啟動流程 & 程式碼","keywords":"","body":"啟動流程 & 程式碼 tagsstart Alljoyn Framework Gateway tagsstop 名詞定義 縮寫 描述 GM App Gateway Management app WKN Well-Know Name，有別於About的建立session方式 ACL Access Control List Config file 描述Alljoyn router的Policy(Allow or Deny) SLS Sessionless Signal Connector Code Initialize Bus At tachment：Start & Connect BusAttachment* bus = new BusAttachment(\"ConnectorApp\", true); bus->Start(); bus->Connect(); Initialize authentication：EnablePeerSecurity這個函數是用來啟動身分驗證與加密機制，使用前需要先Start。 keyListener.setPassCode(\"000000\"); String keystore = \"/opt/alljoyn/apps/\" + wellknownName + \"/store/.alljoyn_keystore.ks\"; bus.EnablePeerSecurity(\"ALLJOYN_PIN_KEYX ALLJOYN_SRP_KEYX ALLJOYN_ECDHE_PSK\", &keyListener, keystore.c_str(), false); 這裡所出現的keyListener是一種自定類別，繼承自AuthListener。 class SrpKeyXListener : public ajn::AuthListener SrpKeyXListener keyListener; 而AuthListener為啟動驗證機制時，負責傳達Password或其他與驗證機制相關的Class。 繼承AuthListener時，有幾種virtual method可以實作，其中比較常用的有RequestCredentials/AuthenticationComplete virtual bool RequestCredentials (const char *authMechanism, const char *peerName, uint16_t authCount, const char *userName, uint16_t credMask, >>Credentials &credentials) virtual void AuthenticationComplete (const char *authMechanism, const >>char *peerName, bool success)=0 以下用SrpKeyXListener改寫的內容做為範例： 首先是RequestCredentials bool SrpKeyXListener::RequestCredentials(const char* authMechanism, const char* authPeer,uint16_t authCount, const char* userId, uint16_t credMask, Credentials& creds) { std::cout 其中Credentials為AuthListener的Inner class，作為傳遞認證資訊的關鍵角色。 再來是AuthenticationComplete void SrpKeyXListener::AuthenticationComplete(const char* authMechanism, const char* authPeer, bool success) { std::cout 此處只有一行cout，表明認證結果。 當Interface的secure設為True，第一次調用此Interface下的任何member，都會產生認證要求。 以下是上述Code的認證執行輸出： RequestCredentials for authenticating org.alljoyn.GWAgent.GMApp using mechanism ALLJOYN_ECDHE_PSK RequestCredentials setPasscode to 000000 Authentication with ALLJOYN_ECDHE_PSK was successful Initialize Connector class MyApp : public GatewayConnector MyApp myApp(&bus, wellknownName.c_str()); myApp.init(); 繼承GatewayConnector時，有幾項Method需要實作。 virtual void shutdown() {…} virtual void mergedAclUpdated() {…} void receiveGetMergedAclAsync(QStatus unmarshalStatus,GatewayMergedAcl* response) {…} 基本上到目前為止，就已經完成一個Connector了。接著只需要跟Cloud互動，並在互動過程中適時的呼叫myApp.updateConnectionStatus(...)回報給GM App目前與雲端的連接狀態。GM App收到後，會發Signal給Controler，Controler收到後會呼叫GM AppInterface的Method取得狀態。 GatewayConnector這個Class透過WKN取得GM App的ProxyBusObject，其內部有2個Method與3個Signal，需要RegisterSignalHandler。 ifc->AddMethod(\"GetMergedAcl\", NULL, \"a(obas)a(saya(obas))\", \"exposedServices,remotedApps\"); ifc->AddMethod(\"UpdateConnectionStatus\", \"q\", NULL, \"connectionStatus\", MEMBER_ANNOTATE_NO_REPLY); ifc->AddSignal(\"MergedAclUpdated\", NULL, NULL); ifc->AddSignal(\"ShutdownApp\", NULL, NULL); Manifest.xml Build好Connector後的下一個工作，就是建置Manifest.xml了。Manifest.xml描述Connector的Service、感興趣的Interface、Connector執行時的參數傳入。 是之後Control App用以建立ACL的依據。 以下為Manifest.xml範例結構。 dummyapp1 dummyAppOne dummyAppOne_0.0.1-1_ar71xx.ipk 0.0.1 3.4.0 /emergency false org.alljoyn.Notification /warning false org.alljoyn.Notification / true org.alljoyn.Notification org.alljoyn.About org.alljoyn.Icon org.alljoyn.NotificationSuper org.alljoyn.Config alljoyn-gwconnectorsample /opt/alljoyn/apps/dummyapp1/lib 7 1 postTweet.sh 安裝Connector 有了Build好的Connector與Manifest.xml以後，接著就是安裝/移除Connector了。 安裝的第一步就是將lib、bin、Manifest.xml依照下列格式擺放。 之後將整包壓縮成一個tar檔案。 tar czf dummyApp1.tar.gz -C gatewayConnector/tar Image 1 - Alt text 接著透過官方提供的installPackage.sh/removePackage.sh進行安裝/移除 ./installPackage.sh dummyApp1.tar.gz installPackage.sh所做的事情很單純， 只是將tar檔裡的東西轉移到/opt/alljoyn/apps/$connectorId之中，然後創造一個Linux User，並將store這個Folder的擁有者，轉移到新創的Linux User下 baseDir=/opt/alljoyn manifestFile=$tmpDir/Manifest.xml appBinDir=$tmpDir/bin connectorId=$(grep \"\" $manifestFile | sed -e \"s/ *//\" | sed -e \"s///\") connectorAppDir=$baseDir/apps/$connectorId if [ $? -ne 0 ]; then useradd $connectorId || exit 22 createdUser=1 fi chown -R \"$connectorId\" \"$pkgInstallDir/store\" || exit 23 chmod -R a+rx \"$pkgInstallDir/bin\" || exit 24 chmod -R a+rx \"$pkgInstallDir/lib\" || exit 25 經過上面安裝後，就會看到/opt/alljoyn/apps/$connectorId目錄，結構如下。 此時acls Folder內無東西。可以透過shell自行創造，或是啟動GM App與Controller App後，透過Contorller App建立。 啟動 啟動Router 在啟動GM App與Connectors之前，先確定alljoyn-daemon是否已經安裝並啟動。 先確認是否Build好的alljoyn-daemon放在/usr/bin/中，並寫好alljoyn.init放在/etc/init.d/alljoyn之中。之後執行service alljoyn start 以下為alljoyn.init的start script start() { if [ -f $PIDFILE ] && kill -0 $(cat $PIDFILE); then echo 'Service already running' >&2 return 1 fi echo 'Starting service…' >&2 local CMD=\"$SCRIPT --config-file=/opt/alljoyn/alljoyn-daemon.d/config.xml &> \\\"$LOGFILE\\\" & echo \\$!\" su -c \"$CMD\" $RUNAS > \"$PIDFILE\" echo 'Service started' >&2 } 執行時所帶的參數--config-file指出Router Config Policy的位置，此例為/opt/alljoyn/alljoyn-daemon.d/config.xml 注意Config File內，要include GM App執行時動態改變的Policy File，此例為gwagent-config.xml alljoyn org.alljoyn.BusNode unix:abstract=alljoyn tcp:r4addr=0.0.0.0,r4port=0 5000 16 100 100 false /opt/alljoyn/alljoyn-daemon.d/gwagent-config.xml Config File內所有可用的的Tag，與每個Tag的說明，請參閱以下網址。 XML Schema Routing Node Configuration File 確認完成後，執行Router：service alljoyn start 啟動GM App 確認Config File 與start alljoyn-daemon以後，對於GM App我們也依法照做一次。 將Build好的alljoyn-gwagent放在/usr/bin/中，並寫好alljoyn-gwagent.init放在/etc/init.d/alljoyn-gwagent之中。之後執行service alljoyn-gwagent start 以下為alljoyn-gwagent.init的start script start() { if [ -f $PIDFILE ] && kill -0 $(cat $PIDFILE); then echo 'Service already running' >&2 return 1 fi echo 'Starting service…' >&2 local CMD=\"$SCRIPT &> \\\"$LOGFILE\\\" & echo \\$!\" su -c \"$CMD\" $RUNAS > \"$PIDFILE\" echo 'Service started' >&2 } 注意：雖然此例沒有使用，但事實上可以帶入參數--gwagent-policy-file指出GM App執行時動態產生的Config File，以及--apps-policy-dir指出根據ACL產生的Config File Folder 以下為GM App程式碼片段 String policyFileOption = \"--gwagent-policy-file=\"; String appsPolicyDirOption = \"--apps-policy-dir=\"; for (int i = 1; i setGatewayPolicyFile(policyFile.c_str()); } if (arg.compare(0, appsPolicyDirOption.size(), appsPolicyDirOption) == 0) { String policyDir = arg.substr(appsPolicyDirOption.size()); QCC_DbgPrintf((\"Setting appsPolicyDir to: %s\", policyDir.c_str())); gatewayMgmt->setAppPolicyDir(policyDir.c_str()); } } 例如： start() { service_start /usr/bin/alljoyn-gwagent `--gwagent-policy-file`=/etc/alljoyn/gwagent/gwagent.conf `--apps-policy-dir`=/etc/alljoyn/gwagent-apps } 如果沒有特別指明，則Default gwagent-policy-file：/opt/alljoyn/alljoyn-daemon.d/gwagent-config.xml apps-policy-dir：/opt/alljoyn/alljoyn-daemon.d/apps static const qcc::String GATEWAY_POLICIES_DIRECTORY = \"/opt/alljoyn/alljoyn-daemon.d\"; GatewayRouterPolicyManager::GatewayRouterPolicyManager() : m_AboutListenerRegistered(false), m_AutoCommit(false), m_gatewayPolicyFile(GATEWAY_POLICIES_DIRECTORY + \"/gwagent-config.xml\"), m_appPolicyDirectory(GATEWAY_POLICIES_DIRECTORY + \"/apps\") { } 下圖為此範例的目錄結構： config.xml： gwagent-config.xml： apps-policy-dir內的dummyapp1.xml： 確認完成後，執行GM App：service alljoyn-gwagent start 驗證 透過ps -ef | grep alljoyn指令驗證 目錄結構 /opt/alljoyn下的樹狀結構： Controller App畫面 進入搜尋到的GM App： 進入Connector's acl列表 允許Connector的服務： 含有此Connector感興趣的Interface的Device： 允許Connector存取此Device： ACL產生： 同時產生Config Policy： © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/3-Allplay/Readme.html":{"url":"md/4-Alljoyn/3-Allplay/Readme.html","title":"Allplay","keywords":"","body":"Alljoyn - Allplay tagsstart Alljoyn Framework Allplay tagsstop 核心 BusObject Path: /net/allplay/MediaPlayer Interface: net.allplay.MediaPlayer 附加 BusObject Path: /net/allplay/MediaPlayer Interface: net.allplay.ZoneManager Interface: org.alljoyn.Control.Volume BusObject Path: /net/allplay/MediaPlayer/Playlist Interface: net.allplay.Playlist net.allplay.MediaPlayer XML Method Play Pause Resume Stop Previous Next SetPosition GetPlayerInfo GetPlaylist GetPlaylistInfo ForcedPrevious Properties EnabledControls Interruptible LoopMode PlayState ShuffleMode Version Signal EnabledControlsChanged EndOfPlayback InterruptibleChanged LoopModeChanged ShuffleMode Version Scenario start GetPlayerInfo GetEnabledControls GetInterruptible GetLoopMode GetPlayState GetShuffleMode GetVersion GetPlaylist() 設定撥放位置 Method - SetPosition(INT64 positionMsecs) signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 隨機撥放 Set - ShuffleMode - STRING SHUFFLE LINEAR signal - ShuffleModeChanged - STRING shuffleMode 循環模式 Set - LoopMode - STRING ONE NONE ALL signal - LoopModeChanged - STRING loopMode Resume Method - Resume() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 新增歌曲到Playlist Method - UpdatePlaylist playlistItems public string Album { get; set; } public string Artist { get; set; } public long Duration { get; set; } public string Genre { get; set; } public string MediaType { get; set; } public IDictionary MediumDesc { get; set; } public IDictionary OtherData { get; set; } public string ThumbnailUrl { get; set; } public string Title { get; set; } public string Url { get; set; } public object UserData { get; set; } ` Album=幸福了 然後呢 Duration=286000 Genre=Pop Artist=A-Lin & 小宇 MediaType=audio MediumDesc=System.ComObject OtherData=System.ComObject ThumbnailUrl=http://192.168.1.20:10508/download/thumb.jpg?id=8285275079956195101 Title=920 Url=http://192.168.1.20:10508/download/item.mp3?id=8285275079956195101` signal - PlayListChanged - VOID Method - GetPlaylist Method - Play() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Pause Method - Pause() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Next Method - Next() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Previous Method - Previous() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 移除PlayList Method - UpdatePlaylist Method - GetPlaylist signal - PlayListChanged - VOID 連線失敗 signal - OnPlaybackError - Volume 調整音量 Set - Volume - INT16 Volume : 0~100 signal - VolumeChanged - INT16 newVolume newVolume : 0-100 Pega-Gateway Event Play In { \"itemIndex\":Int \"startPositionMsecs\":Int64 \"pauseStateOnly\":Bool } Out {} Previous In {} Out {} Pause In {} Out {} Resume In {} Out {} Stop In {} Out {} Next In {} Out {} UpdatePlaylist In { \"playlistItems\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] \"index\":Int \"controllerType\":String \"playlistUserData\":String } Out {} SetPosition In { \"positionMsecs\":Int64 } Out {} ForcedPrevious In {} Out {} CreateZone In { \"players\": [ String ] } Out { \"zoneId\":String \"timestamp\":Int \"failedPlayers\": { String:Int } } SetZoneLead In { \"zoneId\":String \"timeServerIp\":String \"timeServerPort\":Uint16 } Out { \"timestamp\":Int } Pega-Gateway Get-Parameter GetPlayerInfo { \"displayName\":String \"capabilities\": [ String ] \"maximumVolume\":Int \"zoneInfo\": { \"zoneId\":String \"zone_timestamp\":Int \"player_known_name\":??? } } GetPlaylist { \"items\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] \"controllerType\":String \"playlistUserData\":String } GetPlaylistInfo { \"controllerType\":String \"playlistUserData\":String } GetPlayState { \"playstate\":String \"position\":Int64 \"current_sample_rate\":uint32 \"audio_channels\":uint32 \"bits_per_sample\":uint32 \"index_current_item\":Int64 \"index_next_item\":Int64 \"items\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] } EnabledControls: [ \"???\":String \"???\":Bool ] GetInterruptible:Bool GetLoopMode : String (ONE,ALL,NONE) GetShuffleMode : String (LINEAR,SHUFFLE) GetAllplayVersion : Uint16 GetVolume : Int16 GetMute : Bool GetVolumeRange : { \"Low\":Int16 \"High\":Int16 \"Increment\":Int16 } GetVolumeEnabled : Bool GetZoneManagerEnabled:Bool Pega-Gateway Set-Parameter SetLoopMode : String (ONE,ALL,NONE) SetShuffleMode : String (LINEAR,SHUFFLE) SetVolume : Int16 SetMute : Bool © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/6-AI/1-Basic/Readme.html":{"url":"md/6-AI/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Machine Learning tagsstop Introduction ML 競賽網站:Kaggle Python 數據處理:numpy,scipy Numpy數組函數 找維度:ndim() 找矩陣:shape() 將資料轉換成矩陣: reshape((3,2)) call by value: copy() import numpy as np a = np.array([0,1,2,3,4,5]) print \"a =\",a.ndim print \"a.shape =\",a.shape print \"--------------------------------\" b = a.reshape((3,2)) print \"b =\",b print \"b.ndim =\",b.ndim print \"b.shape =\",b.shape print \"--------------------------------\" b[1][0] = 77 print \"b[1][0] = 77\" print \"b =\",b print \"a =\",a print \"--------------------------------\" c = a.reshape((3,2)).copy() print \"c =\",c c[0][0] = -99 print \"c[0][0] = -99\" print \"a =\",a print \"c =\",c 數組運算:數組*2,數組**2 找某些index的資料:numpy.array([2,3,4]) 對數組做邏輯判斷:數組>4 用強制數組的值在某個區間:clip(0,4) 判斷是否NaN:numpy.isnan(數組) 數組中不是NaN的結果:數組[~numpy.isnan(數組)] 平均值:numpy.mean(數組) 數組內資料的型態:數組.dtype import numpy as np a = np.array([0,1,2,3,4,5]) b = np.array([1,\"stringy\"]) c = np.array([1,\"stringy\",set([1,2,3])]) print \"a*2 =\",a*2 print \"[1,2,3,4,5]*2 =\",[1,2,3,4,5]*2 print \"a**2 =\",a**2 #print [1,2,3,4,5]**2 will fail print \"---------------------------------\" a=a**2 print \"a=a**2\" print \"a[np.array([2,3,4])] =\",a[np.array([2,3,4])] print \"a>4 =\",a>4 print \"a[a>4] =\",a[a>4] print \"a.clip(0,4) =\",a.clip(0,4) #a[a>4] = 4 print \"---------------------------------\" c = np.array([1,2,np.NaN,3,4]) print \"c =\",c print \"np.isnan(c) =\",np.isnan(c) print \"c[~np.isnan(c)] =\",c[~np.isnan(c)] print \"np.mean(c[~np.isnan(c)]) =\",np.mean(c[~np.isnan(c)]) print \"---------------------------------\" print \"a.dtype =\",a.dtype print \"b.dtype =\",b.dtype print \"c.dtype =\",c.dtype 循環處理數組的時候,多用library以c實做的function,可以提昇速度 import numpy as np import timeit normal_py_sec = timeit.timeit('sum(x*x for x in xrange(1000))',number=10000) navie_np_sec = timeit.timeit('sum(na*na)',setup=\"import numpy as np; na=np.arange(1000)\",number=10000) good_np_sec = timeit.timeit('na.dot(na)',setup=\"import numpy as np;na=np.arange(1000)\",number=10000) print (\"Normal Python: %f sec\" %normal_py_sec) print (\"Naive Numpy: %f sec\" %navie_np_sec) print (\"Good Numpy: %f sec\" %good_np_sec) Scipy數組運換函數 numpy內全部的命名空間,都可以通過scipy來使用 import scipy import numpy print scipy.version.full_version print scipy.dot is numpy.dot 基本資料模型 比較兩個模型的時候,才會判斷絕對誤差的大小 太過貼近真實的資料,會把雜訊資料也貼合進去,稱為過度擬和(overfitting) # !/usr/bin/env python # -*- coding: utf-8 -*- import scipy as sp import numpy as np #標準平方差公式 def error(f,x,y): return sp.sum( (f(x)-y) **2 ) data = sp.genfromtxt(\"web_traffic.tsv\",delimiter=\"\\t\") #前十筆資料 print (data[:10]) #資料矩陣 print (data.shape) #第一維度的資料 x = data[:,0] #第二維度的資料 y = data[:,1] #NaN資料的數目 print sp.sum(sp.isnan(y)) #取出不是NaN的資料 x = x[~sp.isnan(y)] y = y[~sp.isnan(y)] #根據資料繪製基本圖形 import matplotlib.pyplot as plt plt.scatter(x,y) plt.title(\"Web traffic over the last month\") plt.xlabel(\"Time\") plt.ylabel(\"Hits/hour\") plt.xticks([w*7*24 for w in range(10)],['week %i'%w for w in range(10)]) plt.autoscale(tight=True) #取得誤差最小的一階方程式參數 fp1,residuals,rank,sv,rcond = sp.polyfit(x, y, 1,full=True) print (\"Model parameters: %s\" % fp1) #根據方程式參數,來建立方程式 #ex: f1(x) = 2.59619213 * x + 989.02487106 f1 = sp.poly1d(fp1) #誤差總和 print (error(f1,x,y)) #取得誤差最小的二階方程式參數 f2p = sp.polyfit(x, y, 2) #根據方程式參數,來建立方程式 f2 = sp.poly1d(f2p) #誤差總和 print (error(f2,x,y)) #取得誤差最小的100階方程式參數 f100p = sp.polyfit(x, y, 100) #根據方程式參數,來建立方程式 f100 = sp.poly1d(f100p) #誤差總和 print (error(f100,x,y)) fx = sp.linspace(0,x[-1],1000) plt.plot(fx,f1(fx),linewidth=4) #plt.plot(fx,f2(fx),linewidth=4,linestyle='dotted') plt.plot(fx,f2(fx),linewidth=4) plt.plot(fx,f100(fx),linewidth=4) plt.legend([\"d=%i\" % f1.order,\"d=%i\" % f2.order,\"d=%i\" % f100.order],loc=\"upper left\") plt.grid() plt.show() Image 1 - Result © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/6-AI/2-TensorFlow/Readme.html":{"url":"md/6-AI/2-TensorFlow/Readme.html","title":"Tensor Flow","keywords":"","body":"Basic tagsstart Tensorflow Machine Learning Framework tagsstop Introduction © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/6-AI/3-AIML/1-AIMLv1.html":{"url":"md/6-AI/3-AIML/1-AIMLv1.html","title":"AIM Lv 1","keywords":"","body":"AIML v1.0 tagsstart AIML AI tagsstop 型態 用於AIML元素和屬性的名稱的約定是名稱都是小寫 Topic Supported in versions: AIML 1.0 Must be within: Can be within: UNKNOWN Can contain: UNKNOWN Must Contain: optional top-level element that contains category elements A topic element has a required name attribute phrase phrase phrase Category Supported in versions: AIML 1.0 Must be within: Can be within: Can contain: Must Contain: second-level contains exactly one pattern and exactly one template PATTERN THAT Template Pattern Supported in versions: AIML 1.0 Must be within: Can be within: undefined Can contain: * _ Must Contain: Normalized text \"Pattern-side AIML expressions (PSAE).\" it must be the first tag to appear after a in UPPER CASE. * = one or more words. _ = * *只能有一個 tag which is replaced at robot load time with the name of the robot. That 机器人的数据库中对应“是的”的回答必然非常多，比方有下面A和B两个categories 也就是机器人自己上句说过的话，即“你是程序员吗？”这样它就可以确定应该匹配 category A了 = 機器人倒數幾句講的話 表示取机器人倒数第2句的话 也等于 也等于 是的 你是程序员吗？ 你最擅长的编程语言是什么？ 是的 你是学生吗？ 你是哪个学校的 Template Supported in versions: AIML 1.0 Must be within: Can be within: undefined Can contain: TSAE (Template-side AIML Expression) Must Contain: could be empty A template is the \"response\" or \"output\" part of an AIML category. Star CLIENT: \"Hello there, my name is Tom\" HELLO * MY NAME IS * = there = tom = that的第n個* 你好 计算机 的 型 号 是 什 么 * * 的 型 号 是 什 么 这个型号是里面 很好的商品 很流行的商品 很华丽的商品 。 对话场景： 用户：你好 机器人：计算机 的 型 号 是 什 么 用户：p4 机器人：p4这个型号是计算机里面很好的商品 input 输出用户倒数第2次的输入，看如下对话： = 嘿 嘿 你刚才说：“”？ topicstar 元素用来得到先前倒数第n次谈论的主题 get ,即得到name的值 set & think Me bot name date id person2 = 把第一人称转成第2人称 person = 把第一人称转换成第3人称 gender = 元素，替换性别以及代名词，例如： She told him to take a hike. 将被替换成：He told her to take a hike，跟性别有关的单词都将被替换，中文怎么处理不是很清楚 srai 里面的话会被当作是用户输入，从新查找匹配模式，直到找到非定义的回复 例如： 我 是 ，那么机器人会把“我 是 *”当作是用户输入来从新查找匹配模式 = size version uppercase DO UPPERCASE This is an uppercase test. This category will give the following output: This is an UPPERCASE test. lowercase DO LOWERCASE This is a LOWERCASE test. This category will give the following outout: This is a lowercase test. formal 元素，用来格式化输出，例如：jon baer 那么回复将被格式化成首字母大写输出：Jon Baer，对中文无效 sentence 元素用来格式化句子，比如： this is some kind of sentence test. 可以格式化成：This is some kind of sentence test.即把句子首字母大写 condition 你好 我 头 发 的 颜 色 是 蓝 色 * 哇塞，你很 漂亮阿！ 英俊阿！ 我 头 发 的 颜 色 是 蓝 色 * 哇塞，你很 漂亮阿！ 英俊阿！ 我 头 发 的 颜 色 是 蓝 色 * 哇塞，你很 漂亮阿！ 英俊阿！ 我 头 发 的 颜 色 是 蓝 色 * 哇塞，你很 漂亮阿！ 好看！ random 很好的商品 很流行的商品 很华丽的商品 gossip X Save X as gossip. 元素用来把改元素里面的内容保存到gossip.log文件里。 learn basic_chat.aiml system 调用系统函数 date表示取系统当前日期 javascript if 判断元素 你的名字叫 . 你叫什么名字？ NONE kernel = aiml.Kernel() \"\"\" kernel.learn(\"std-startup.xml\") kernel.respond(\"load aiml b\") \"\"\" if os.path.isfile(\"bot_brain.brn\"): kernel.bootstrap(brainFile = \"bot_brain.brn\") else: kernel.bootstrap(learnFiles = \"std-startup.xml\", commands = \"load aiml b\") kernel.saveBrain(\"bot_brain.brn\") while True: message = raw_input(\"Enter your message to the bot: \") respond = kernel.respond(message) print respond sessionId = 12345 kernel.respond(raw_input(\">>>\"), sessionId) sessionData = kernel.getSessionData(sessionId) kernel.setPredicate(\"dog\", \"Brandy\", sessionId) clients_dogs_name = kernel.getPredicate(\"dog\", sessionId) kernel.setBotPredicate(\"hometown\", \"127.0.0.1\") bot_hometown = kernel.getBotPredicate(\"hometown\") abc attractive. handsome. test where is your origin where is your destination test 要換行 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/6-AI/3-AIML/2-AIMLv2.html":{"url":"md/6-AI/3-AIML/2-AIMLv2.html","title":"AIM Lv 2","keywords":"","body":"AIML v2.0 (Program AB) tagsstart AIML AI tagsstop Folder c:/ab/bots the AIML bots go in this directory c:/ab/lib Java libraries needed to run this code c:/ab/out Java class file directory c:/ab/run.bat batch file to run Program AB Bot c:/ab/bots/botname/aiml store your AIML files here c:/ab/bots/botname/aimlif Program AB stores AIMLIF files here c:/ab/bots/botname/config Bot configuration files c:/ab/bots/botname/sets AIML Sets c:/ab/bots/botname/maps AIML Maps Mode action=chat run the bot and have a chat action=ab run the experimental pattern suggestor action=csv2aiml convert AIMLIF files to AIML action=aiml2csv convert AIML files to AIMLIF bot=botname run the bot found in the botname directory trace=true print out useful tracing information chat mode q quit without saving wq write AIML and AIMLIF (.csv) files and quit ab Enter catgeory browser/pattern suggestor mde Pattern suggestor (Category Browser) mode q quit without saving files wq write AIML and AIMLIF files and quit \"Enter\" or skip skip this category d delete this pattern x create a category with of the pattern - saved in sraix.aiml p inappropriate content - creates a category with FILTER INAPPROPRIATE - saved in inappropriate.aiml f profanity - creates a category with FILTER PROFANITY - saved in profanity.aiml i insult - creates a category with FILTER INSULT - saved in insult.aiml template conatins category saved in srai reductions_update.aiml sraix sraix.aiml oob oob.aiml set name client_profile.aiml get name (except get name=”name”) client_profile.aiml anything else personality.aiml Optionally, you can write SOME PATTERN response A 跑aiml or aimlif 取決於誰比較新 Program AB was developed as a project in JetBrains IntelliJ IDEA Some Java libraries are needed to compile Program AB. These libraries are not included in this source code distribution. jgoodies-common.jar jgoodies-forms.jar json-20090211.jar sanmoku-0.0.5.jar sanmoku-feature-ex.0.0.1.jar httpcomponents-client-4.2.1: commons-codec-1.6.jar commons-logging-1.1.1.jar fluent-hc-4.2.1.jar httpclient-4.2.1.jar httpclient-cache-4.2.1.jar httpcore-4.2.1.jar httpmime-4.2.1.jar AIML Intermediate Format 翻譯AIML的每一個category 順序是: activation count, input pattern, that pattern, topic pattern, template, filename. 不包含, or , 對,很敏感,所以不要使用,改用#Comma Hi, nice to see you! -> Hi#Comma nice to see you! #Newline是換行 activation count目前沒有被program ab用到,但你可以優先讀取他來改進bot運行的速度 AIML Processor Extension Program AB 定義了一個Java Interface,名叫AIMLProcessorExtension,用來讓你自訂AIML tags用. 要實做這個Interface必須做三件事情： public Set extensionTagSet(); which returns a set of extension tag names. public String recursEval(Node node, ParseState ps):用來遞迴xml tree,並添增你的標籤會回傳的結果.因為你自定義的標籤可能本身包含原生的AIML 2.0 tags .你會用到AIMLProcessor.evalTagContent(node, parseState ignoreAttributes)取得tag or subtag的內容.最後你要return 一個String來代表這個tag的結果. 最後假設你實做的結果為PCAIMLProcessorExtension,那麼你需要AIMLProcessor.extension = new PCAIMLProcessorExtension(); public Set extensionTagNames = Utilities.stringSet(\"contactid\",\"multipleids\"); public Set extensionTagSet() { return extensionTagNames; } 使用步驟 Link to Ab.jar import org.alicebot.ab.*; Create a bot String botname=\"mybot\"; Bot bot = new Bot(botname); You can also specify a root path for the bot's files with String botname=\"mybot\"; String path=\"c:/example\"; Bot bot = new Bot(botname, path); Create a chat session Chat chatSession = new Chat(bot); Use the method multisentence Response to get the bot's replies to multiple-sentence (one or more sentence) inputs: String request = \"Hello. Are you alive? What is your name?\"; String response = chatSession.multisentenceRespond(request); System.out.println(response); Set 順序： Try underscore _ first. Try to find an exact word match. Try to find a match - this step differs from AIML 1.1 Try star * last. 優先：短>長 “give” > “give up\" 符合的set在template中用代表 Remote set:“ISA“+setName+“ “+setMember server 端寫: ISACOLOR RED true ISACOLOR * false client端寫 IS color A COLOR color.txt: external:www.pandorabots.com:8e3fc4b44e342400:4 The “external” keyword means this is an external set. The “www.pandorabots.com” specifies the host name. bot id The number 4 is the maximum length (in words) of any member of the set. This parameter saves processing and networking resources by omitting checks of phrases that are too long to be in the set anyway. map 用在template be2was been2be 找不到會回傳unknown Remote Map:mapName+“ “+domainElement server寫: ZIP2CITY 94618 Oakland, California ZIP2CITY * unknown client端寫 The city for 94618 is 94618 zip2city.txt: external:www.pandorabots.com:8e3fc4b44e342400 The external keyword means this is an external set. The “www.pandorabots.com” specifies the host name. Note that the maximum element length need not be specified for maps, as it was for sets. This is because the element can be activated on the side much more frequently than the element on the side. configure Normalization:normal.txt Predicate Defaults:predicates.txt Bot Properties:properties.txt Substitutions:person.txt... File AIML Tag normal.txt person.txt person2.txt gender.txt Copyright: Macro Expansion [url] the URL specified by the bot property url in the file properties.txt [date] the current date [YYYY] the current calendar year [version] the bot property version from properties.txt [botname] the botname property from properties.txt [botmaster] the botmaster property from properties.txt [organization] the organization property from properties.txt © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/9-IDE/1-Xcode/Readme.html":{"url":"md/9-IDE/1-Xcode/Readme.html","title":"Xcode","keywords":"","body":"Xcode tagsstart IDE Xcode Mac Software tagsstop 快捷鍵 CTRL+I：格式化程式碼 command + /：註解單行 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/9-IDE/2-Eclipse/Readme.html":{"url":"md/9-IDE/2-Eclipse/Readme.html","title":"Eclipse","keywords":"","body":"Eclipse tagsstart IDE Eclipse Software tagsstop 快捷鍵 ctrl+o：快速outline F3: 打开申明（Open declaration） Ctrl+Shift+F 格式化当前代码 Ctrl + Shift + O: 引入imports语句 ALT+/ 提示 Alt+←】、【Alt+→】 后退历史记录和前进历 Ctrl+M窗口最大化和还原 Ctrl + D : 删除本行 Ctrl + / : 注释本行 cmake -G\"Eclipse CDT4 - Unix Makefiles\" -D CMAKE_BUILD_TYPE=Debug -D CMAKE_ECLIPSE_VERSION=4.6 . Initializer Format(line wrapping) constructor initializer list in Eclipse CDT Click on: Window -> Preferences Go to: C/C++ -> Code Style -> Formatter Here, as first thing you have to create a new profile. Select tab: Line Wrapping Go to: Function declarations -> Constructor initializer list On the bottom, you have to set: Line wrapping policy: Wrap all elements, every element on a new line. check \"Force split, even if line is shorter than maximum\" Indentation policy: indent on column © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/11-Cross_compile/1-Yocto/1-BBfile.html":{"url":"md/11-Cross_compile/1-Yocto/1-BBfile.html","title":"B Bfile","keywords":"","body":"BBfile tagsstart Cross compile Yocto BBfile tagsstop T1 source build/conf/set_bb_env.sh cat pega.sh 裡面有描述 export MACHINE=apq8009 rebake boost rebake azure-iot-sdk merlot/oe-core/build/downloads oe-core/build/tmp-glibc/work/armv7a-vfp-neon-oe-linux-gnueabi repo forall vendor/pega/voiced/ -c git branch -r TOPDIR = 所在的meta目錄 WORKDIR = xxx/1.0-r0/ sbindir = /usr/sbin CFLAGS = makefile 的CFLAGS LDFLAGS = makefile 的LDFLAGS PN = BBfile Name S = 要將src cp 到的位置 ,以下稱為S(source). 與之相對的為D D = WORKDIR/image/ License=build/conf/local.conf © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/10-Android/1-adb/Readme.html":{"url":"md/10-Android/1-adb/Readme.html","title":"Adb","keywords":"","body":"adb tagsstart Android adb tagsstop 簡介 adb shell adb kill-server sudo adb start-server adb devices adb -s f7990ff shell © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/99-Hardware/1-Voice/Readme.html":{"url":"md/99-Hardware/1-Voice/Readme.html","title":"Voice","keywords":"","body":"Basic tagsstart Voice Hardware tagsstop Introduction PulseAudio | ALSA | Gstreamer | Jack ALSA driver | OSS Hardware © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/99-Hardware/2-Open Hardware/1-Arduino Yún/1-基本建置.html":{"url":"md/99-Hardware/2-Open Hardware/1-Arduino Yún/1-基本建置.html","title":"基本建置","keywords":"","body":"基本建置 tagsstart Arduino Hardware Yún tagsstop 名詞定義 縮寫 描述 Yún Arduino系列中唯一有中文名稱的型號–雲 硬體規格 微控制器ATmega32U4 : x1 SOCAtheros AR9331 : x1 運行Linux發行套件Linino Linino是以OpenWRT為基礎修改而成的OS Ethernet WiFi USB A埠 micro SD卡 Image 1 - Buttons 上電 Yún接上電源後，此時WiFi處於AP模式，所以可從電腦連接，其分享出來的SSID會類似Arduino Yun-XXXXXXXXXXXX Image 2 - AP mode 瀏覽器輸入網址 http://arduino.local 或192.168.240.1，便可看到如下畫面，要求輸入密碼，預設密碼是「arduino」 Image 3 - Login 點按「CONFIGURE」進行組態設定 Image 4 - Configure 設定Wifi Image 5 - Set wifi 按下CONFIGURE & RESTART Image 6 - Restart 從Arduino IDE燒入 打開Arduino IDE，從選單「工具-序列埠（Tools-Port）」看到含有IP位址的Yún，勾選後，記得從選單「工具-板子」勾選Yún Image 7 - Restart wifi燒入需要密碼 Image 8 - Restart Update image 將Image(bin檔)放入micro SD卡，插入Arduino並確認Mount完成後，執行以下指令。 run-sysupgrade /mnt/sda1/openwrt-ar71xx-generic-linino-yun-16M-250k-squashfs-sysupgrade.bin 新版介面的密碼「doghunter」 Image 9 - Linino 安裝SFTP opkg update opkg install openssh-sftp-server © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/99-Hardware/2-Open Hardware/1-Arduino Yún/2-在Openwrt上寫C++.html":{"url":"md/99-Hardware/2-Open Hardware/1-Arduino Yún/2-在Openwrt上寫C++.html","title":"在Openwrt上寫C++","keywords":"","body":"在Openwrt上寫C++ tagsstart Arduino Hardware Yún Openwrt c++ Cross Compile eclipse tagsstop 名詞定義 縮寫 描述 Yún Arduino系列中唯一有中文名稱的型號–雲 建置Linux環境 Openwrt Toolchain Image 1 - make menuconfig 下載Eclipse for C++ Cross Compile © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/99-Hardware/3-Interface/Readme.html":{"url":"md/99-Hardware/3-Interface/Readme.html","title":"Interface","keywords":"","body":"Basic tagsstart Interface Hardware tagsstop Introduction USB->UART-> TTL | RS232 TTL | RS232 -> UART Arduino與AVR微控制器相關詞彙 簡單介紹解釋一些名詞，這篇只是把找到的資料整理之後扼要記錄，主要是寫給我自己看的。若有錯誤，還請告知。 microcontroller： 微控制器、MCU（MicroController Unit）、μC，似乎有些人暱稱為「micro」。將CPU、RAM、ROM、Flash、I/O、A/D等等功能通通整合在一起，形成一個微型的電腦，所以也稱為單晶片（single-chip）、單晶片微電腦、單晶片控制器，大陸稱為单片机、单片微型计算机。最廣為人知的是8051。 單板電腦（Single Board Computer）： 並沒有絕對的定義，只要將整部電腦放進一塊板子裡應該都算，譬如使用TI OMAP系統單晶片的Beagleboard、BeagleBone、Pandaboard，譬如Raspberry Pi。一般來說應該比單晶片系統更高檔。 8051： Intel於1980年代推出的MCS-51微控制器，通常稱呼為8051，型號很多，但基本核心與指令皆相同，差別在於記憶體容量、型式、其他擴充功能，Intel於2007年3月終止此產品線，但仍有其他廠商的相容產品。8051發展的早，幾乎可說是單晶片的代名詞，學校課程大都以8051為教材，中英文參考書籍非常多，網路資源豐富，在台灣尤為流行，單晶片幾乎都是8051的天下，也因為如此，其開發環境與周邊非常豐富，諸如整合編輯器、編譯器、模擬器、等等。 此系列廣受歡迎，相容產品非常多，如Atmel的AT89C51/AT89S51，其他廠商還有Winbond、Philips、NXP、STC、Infineon、等等，相繼改進推出相容產品，譬如提高時脈、減少接腳數與晶片體積、PWM、計時器、等等。 在台灣，其他比較常見、資料比較多的單晶片，應該是Microchip的PIC系列與Atmel的AVR系列，機器人領域則有Parallax的BASIC Stamp，當然啦，除此之外還有很多其他廠商的產品。 各種廠牌的8051相容單晶片。 Processing： 2001年由Ben Fry和Casey Reas在MIT媒體實驗室所發展，提供簡單易用的程式語言與開發環境，著重於繪圖、動畫、互動設計，以視覺化的方式，供視覺設計藝術家進行創作。寫出來的程式碼稱為sketch（素描、草稿）。 Wiring： 繼承Processing的概念，將對象改為電子創作者，起初由Hernando Barragán在2003年於義大利Ivrea互動設計學院開始發展，提供一套程式語言、軟體開發環境（Java跨平台IDE）、硬體電路板、等等。可視為Arduino的前輩、姊妹平台。 Arduino： Arduino計畫於2005年正式啟動，在那個年代，發起人Massimo Banzi與David Cuartielles覺得市面上可用的電子素材與零件太過昂貴，學生負擔不起，於是動念打造更便宜好用的電子創作原型平台，這才萌生了Arduino這樣的想法。 Arduino的起源地是義大利西北方的一個小鎮Ivrea，這個小鎮有個知名歷史人物Arduin of Ivrea（955～1015），於是便以他取名為Arduino。Arduino也是個義大利男性名，其意為「strong friend」。 Arduino繼承Wiring並使用Processing的IDE，簡化後的C/C++程式語言，便利且豐富的程式庫，以及Atmel 8-bit AVR微控制器為核心的硬體電路板，提供一套開放原始碼電子創作原型平台。 Arduino官方推出的開發板，諸如Diecimila、Duemilanove、Uno、Leonardo、Esplora，Mega 2560、LilyPad、Micro、等等。主要使用megaAVR（ATmega）系列的晶片，但也有人移植了tinyAVR（ATtiny）系列。 2012年10月Arduino官方的新板子Due，晶片為AT91SAM3X8E，開始採用32-bit ARM核心（ARM Cortex-M3）。 Arduino Uno板，2010年9月推出，uno在義大利文裡是「1」的意思，代表進入1.0里程碑。後來在2011年11月，Arduino軟體部分的編號也從00xx改成1.0。 Arduino相容板： 譬如Seeeduino、Japanino、Roboduino、Raspduino，非常多。 Arduino Software： Arduino官方的軟體開發環境，有Windows、Mac OS X、Linux版，內含整合式編輯器、Arduino核心、內建程式庫、範例sketch、編譯器、燒錄程式、等等。 Arduino軟體開發環境。 sketch： 素描、草稿、草稿碼、程式碼，在Arduino世界裡，就是「程式」的意思啦。而sketchbook指的是存放sketch的地方（目錄）。 Verify： 在Arduino軟體開發環境裡，其真正的意義是「編譯、建置程式碼，產生二進位執行檔」。 Upload： Arduino軟體開發環境裡，其真正的意義是「燒錄，將二進位執行檔傳進微控制器晶片裡」，當然啦，若尚未編譯建置或原始碼檔案更新了，便會先執行Verify。 shield： 擴充板、周邊擴充板、daughterboard、add-on module、擴展板、轉接板、子板。Arduino擁有非常多的shield，一插上便可使用，非常方便。 breakout、breakout board： 分線板。通常是一塊小小的印刷電路板，作用是將某晶片的腳位接出來，因為現在很多元件都是SMD，平常開發時用起來不太方便，以分線板接出接腳、排針、端子，便可輕易地插上麵包板、或接到其他電路；有些晶片使用時可能還需要一些其他元件（譬如電容、石英晶體、電池、電阻），也可整合在板子上變成模組，用起來更方便；板子上可能印有文字說明，用起來較清楚。 Atmel ATmega32U4晶片的分線板。 即時時鐘DS1307晶片的分線板，也是易於使用的模組，該有的電子元件都在上面了。 Harvard architecture、von Newmann architecture： 簡單地說，Harvard架構把指令與資料分開，von Newmann架構則放在一起。一般CPU大都是von Newmann架構，但也加入了Harvard的特色，譬如將cache分成指令快取與資料快取。Harvard也隨著時間演進有所修改。 RISC、CISC： CISC的代表有x86、68000，RISC的代表有ARM、MIPS、Power，因為處理器架構逐漸複雜，但其實常用的指令只佔一小部分，便提出RISC型的架構，精簡指令。但經過多年發展後，RISC處理器的指令集也越來越大。 Atmel： 半導體公司，產品包括微控制器、快閃記憶體、觸控技術、車用電子、等等。台灣地區分公司為台灣愛特梅爾股份有限公司。其AVR產品為Arduino的核心。 AVR： Alf (Egil Bogen) and Vegard (Wollan)'s RISC processor的縮寫，也有人說是Advanced Virtual RISC的縮寫，不過官方說法為「AVR就是AVR，不是縮寫」。修改過的Harvard架構、8-bit、RISC、單晶片微控制器。最先以Flash memory作為程式儲存區，而不是以PROM、EPROM、EEPROM。將Flash、EEPROM、SRAM通通整合在一塊晶片裡，還包含了其他功能，諸如輸出入腳位、計時器、序列傳輸埠、數位類比轉換。 大致上可分為6個群組，tinyAVR（ATtiny）、megaAVR（ATmega）、XMEGA（ATxmega）、特製AVR、FPSLIC（含有FPGA的AVR）、32-bit AVR。Arduino官方主要用的是ATmega系列，也有人移植了ATtiny。 ATmega328： 這是Arduino Uno用的微控制器晶片，後來有ATmega328P，P代表Picopower，意思是製程更好更省電，但功能是一樣的。ATmega168除了有ATmega168P還有ATmega168A與ATmega168PA，多了個A，差異處必須查datasheet才知道，但功能應該是一樣的。若晶片編號後面有-PN或-PU，其中P代表封裝技術PDIP（Plastic Dual Inline Package），而N與U代表溫度容忍範圍，N比U好，另有-AN或-AU，其中A代表封裝技術TQFP（Thin Profile Plastic Quad Flat Pack），另有-MN或-MU，其中M代表封裝技術MLF（Micro Lead Frame Package）。 ATmega328P-PU。 ATtiny45、ATtiny85、ATtiny44、ATtiny84： 有人修改Arduino軟體開發環境的程式後，使其可運作在這些微控制器上，比ATmega系列晶片較小、腳位較少、價格較低，若你的作品不需要那麼多腳位的話，可改用ATtiny系列，降低成本，縮小體積。ATtiny45與ATtiny85有8支腳，功能幾乎一樣，主要差別在於ATtiny85的記憶體（Flash、EEPROM、SRAM）是ATtiny45的兩倍。ATtiny44與ATtiny84有14支腳，輸出入腳位較多。 ATtiny85-20PU。 chip signature、signature bytes： Atmel的微控制器晶片都有個識別碼，譬如ATmega328是0x1E 0x95 0x14，ATmega328P是0x1E 0x95 0x0F。 fuse： Atmel AVR微控制器，裡頭有非揮發性的設定值，其名稱很嚇人，叫做fuse（保險絲），會讓人聯想到保險絲燒壞後必須更換新的，但事實上，fuse就是設定值而已。不過有些設定值很重要，若亂搞，單晶片可能會變得難以燒錄。 16MHz： 雖然ATmega328最高可跑到20MHz，但先前的ATmega8最高只能跑到16MHz，所以Arduino繼續使用頻率16MHz，維持相容性。 STK500 starter kit、STK600 starter kit： Atmel公司的AVR開發套件，包括板子、ISP、軟體開發環境、等等。一直以來是AVR的標準開發平台，但有些人改投Arduino懷抱。 STK500開發板。 AVR Studio、Atmel Studio： Atmel公司官方的AVR整合開發環境，支援8-bit AVR與32-bit AVR，新版本（Atmel Studio 6）開始支援ARM Cortex-M。非開放原始碼、可免費下載，只有Windows版。 AVR Studio 5。 Atmel Studio 6。 PIC： Peripheral Interface Controller。Microchip公司的微控制器產品，其整合開發環境叫做MPLAB，只能在Windows上跑，但新版本叫MPLAB X，跨平台可在Windows、Mac OS X、Linux上跑。PIC在中國大陸似乎很流行。 datasheet： 資料表、規格文件、規格資料。詳細列出電子元件的規格、功能、特性、腳位、溫度容忍範圍、等等。 data book： 將許多電子零件晶片的datasheet收集在一本紙書裡，厚厚一本，以前電子工程師的書架上通常會有一整排data book，但有了網際網路後，datasheet都變成電子檔囉（通常是pdf格式）。 pinout、pin-out： 電子元件或接頭插座之腳位功能對照表（圖）。 ATmega328晶片各腳位功能、以及與Arduino板子針腳的對照圖。 programmer燒錄器： chip programmer、device programmer、晶片燒錄器。意思是一台裝置，有能力將資料燒錄進非揮發性記憶體，諸如EPROM、EEPROM、Flash、PAL、FPGA、可程式化邏輯等等。以前學習單晶片時，並沒有像現在這麼方便 ，開發韌體時額外需要一台燒錄器，將單晶片放進去，然後燒錄，再拔起來插回電路裡，非常麻煩。我在網路找到以前的文章，常抱怨燒錄器很貴，而且有些燒錄器只能燒錄幾個型號的晶片，後來才有萬用型燒錄器。 ISP（In-System Programming）、ICSP（In-Circuit Serial Programming）： 線上燒錄、線上即時燒錄。不須將要被燒錄的單晶片從線路上拔起來。微控制器內建燒錄功能介面，接出來後（型式可能不同，如RJ-11、6腳位、10腳位），連到燒錄連接線（又稱為下載線、ISP下載線、燒錄線、線上燒錄器）、再到電腦主機（的某軟體，例如avrdude、PonyProg、UISP），便可進行燒錄。AVR、PIC、Parallax Propeller皆支援此功能。 ISP應該是個泛稱，指線上燒錄的技術，而ICSP似乎是Microchip公司增強ISP之後所開發並定義的技術，並且擁有商標權，所以Atmel的AVR文件裡，用的是ISP這個字眼。（不知為何，Arduino板子上的ISP接腳旁印的字樣是\"ICSP\"。） 各家ISP的介面不同，例如SPI、UART、JTAG、等等。 AVR的ISP產品有AVR ISP與AVRISP mkII（Atmel官方產品）、USBasp、USBtinyISP（由ladyada開發）、Parallel Port Programmer、等等。 ladyada開發的USBtinyISP。 Arduino as ISP、ArduinoISP： 將某份程式碼燒進Arduino之後，它就搖身一變化身成為一台ISP，可用來燒錄別的單晶片（燒錄bootloader與燒錄sketch）。 self-programming： 自己寫入自己的記憶體。以Arduino的AVR晶片為例，其Flash可分為兩區，一區放bootloader，一區放一般程式碼，Arduino板子與電腦主機連接後，主機端的某軟體（例如avrdude），可與bootloader溝通進行燒錄動作，因bootloader（燒錄者）與程式碼（被燒錄者）皆位於同一塊Flash裡，所以稱為self-progrmming。這麼一來，就不需要額外的燒錄器或下載線了。但若直接購買未含有bootloader的AVR單晶片，那就形成先有雞還是先有蛋的問題，還是必須準備一台燒錄器或下載線。 bootloader： Arduino官方開發板的微控制器晶片皆預先已燒錄bootloader，開機時，bootloader先等個幾秒看看是否要進行燒錄，若不是就將控制權交給一般程式區裡的程式碼。燒錄（上傳）sketch時，就是由Arduino軟體開發環境裡的avrdude與Arduino板子裡的bootloader通力合作，燒錄sketch，非常方便，不需要額外的燒錄器或下載線。缺點是flash有部分會被bootloader佔據。 avrdude（AVR Downloader/UploaDEr）： 位於電腦主機端的AVR燒錄軟體，支援多種燒錄器與ISP下載線、各種燒錄協定（譬如stk500、stk500v2、avr109、等等）。Arduino官方軟體開發環境使用此軟體進行燒錄。 Intel HEX FORMAT： 檔案格式，通常用於燒錄時。程式產生機械碼後，再轉成這種適合燒錄的HEX格式，交由燒錄器進行燒錄。 DFU（Device Firmware Upgrade）： USB Device Firmware Upgrade是USB裝置韌體更新介面的標準，定義如何燒錄韌體到USB裝置。理論上，因為有此標準介面，在個人電腦端便可使用同一套工具，燒錄（更新）韌體到各種USB裝置裡（譬如智慧型手機）。 PWM： Pulse-Width Modulation脈波寬度調變，常用於電子式電壓調整，例如燈光亮度、馬達控制、螢幕亮度、等等。 其原理是藉由調整脈波的工作週期（Duty cycle）並影響平均值來控制電壓。 FTDI： Future Technology Devices International公司，專精於USB技術，譬如USB與RS-232或TTL邏輯訊號的轉換。 早期Arduino板子使用RS-232序列埠與主機電腦連接，但那種連接埠已經快消失了，後來改用USB，需要在USB與TTL序列介面之間作轉換，採用的是FTDI的產品，譬如FT232RL。對Arduino這邊來說並沒變，它仍然是TTL序列介面，但中間經過轉換晶片後，便能經由USB線與主機電腦（虛擬COM埠）溝通。Arduino Uno改用Atmel的產品ATmega8U2/16U2。Arduino Leonardo更進一步，其單晶片ATmega32U4已經內建了USB通訊功能，也就是說，Leonardo還可變成一個USB裝置，例如鍵盤或滑鼠。 TTL：數位電路家族之一，由雙極接面電晶體（BJT，bipolar junction transistor）與電阻器組合而成，因為邏輯閘功能與放大功能皆由電晶體負責，所以稱為TTL（Transistor-Transistor Logic）。最常見的積體電路IC為74系列，編號命名通常以德州儀器的為準。原與CMOS分庭抗禮，以前，TTL速度較快，CMOS則較省電、成本較低，不過CMOS越來越進步，反應速度已超越TTL，且製作較容易；TTL幾乎沒有發展，目前主要應用在簡單的數位電路。 TTL一詞也被拿來指稱「TTL邏輯電壓準位」，但並不一定使用TTL積體電路，而是指哪個電壓範圍代表HIGH，哪個電壓範圍代表LOW，譬如，若驅動電壓（Vcc）為5V，那麼LOW範圍會是0V~0.8V，而HIGH範圍則是2V到Vcc。常見驅動電壓還有3.3V。 Serial（序列傳輸）：顧名思義，一次只傳1個位元的傳輸介面，與之相對的是一次傳送好幾個位元的並列傳輸。最少需要兩條連線，通常標示為負責傳送的TX（或TXD）以及接收的RX（RXD），雙方的接線需交叉連接方為正確。在一般個人電腦中被稱為序列埠或通訊埠（COM port），並以RS-232實體介面的連接埠出現，而在電腦裡負責將資料在序列形式與並列形式之間作轉換的硬體稱為UART（Universal Asynchronous Receiver/Transmitter）。現今的個人電腦幾乎看不見序列埠的身影，已被更高速的傳輸介面所取代，譬如USB與FireWire，但若插上藍牙轉序列埠或USB轉序列埠的轉接介面，就會以虛擬序列埠的姿態出現。 TTL Serial：符合TTL邏輯電壓準位的序列傳輸介面。 UART（Universal Asynchronous Receiver/Transmitter）：實作序列傳輸介面的硬體積體電路，將資料在序列與並列形式之間做轉換。早期知名的晶片有8250、16550。個人電腦以之實作出序列埠，在DOS/Windows下被標示為COM port，至於其外接線路與連接埠，通常採用RS-232與後繼標準。若具備同步功能則稱為USART（Universal Synchronous/Asynchronous Receiver/Transmitter）。 I²C（I2C、Inter-Integrated Circuit）：由Philips設計的一種序列通訊匯流排標準，屬於多主從架構，匯流排上可有多個主方（master）與多個從方（slave），主方多半是微控制器或單板電腦，從方則是各種I2C裝置，透過兩條雙向連線進行傳輸，SDA（Serial Data Line）傳輸資料，SCL（Serial Clock）則為時脈，每個I2C從方裝置各需擁有一個獨一無二的位址，以資區別。自2006年10月後，其他廠商不需權利金也能實作I2C協定，但若要取得I2C從方裝置的位址，還是要付出費用向NXP公司（其前身為Philips半導體部門）註冊。 TWI（Two-Wire Interface）：與I2C完全相容，當初似乎是為了避免商標爭議，所以改用TWI名稱。在極少數狀況下，宣稱符合TWI的電子裝置可能不相容於I2C協定。 SMBus：由Intel於1995年定義的標準，以I2C為基礎但更嚴格的子集合，期許能讓電子電路與裝置能夠更加穩定可靠，並且提昇互通性；新近的I2C裝置多半也符合SMBus的規定，與之相容。 SPI（Serial Peripheral Interface Bus）：一種全雙工同步序列資料傳輸協定，在SPI匯流排上的裝置有一個為主方，其餘為從方，連接線有MOSI（Master Out Slave In）、MISO（Master In Slave Out）、SCLK（Serial Clock）、SS（Slave Select），主方便是透過SS指定欲與哪一個從方溝通，並不像I2C使用位址的方式指定，主方以SCLK發出時脈，以MOSI傳送資料給從方，而從方以MISO傳送資料給主方。SPI也常被稱為SSI（Synchronous Serial Interface）。 1-Wire： Dallas半導體公司（2001年成為Maxim的子公司）的專利技術，只有一條線，卻可傳輸時脈與資料（雙向），甚至也可提供電源，這麼一來總共就只需兩條線（再加一條接地）。傳輸速率比I2C低，通常是用來溝通小型裝置，如數位溫度計。有兩種速率，標準模式16kbps，驅動模式142kbps。 Bit bang：以軟體而非專屬硬體線路來實作底層傳輸的方式，必須在程式碼裡直接設定與取樣腳位的狀態，負責訊號所有需要的參數，包括時脈、電壓準位、同步等等。優點是不需要專屬硬體，可實作出不同的傳輸協定，缺點是耗用處理器的運算時間，產生出來的訊號可能不夠精確。 USB（Universal Serial Bus）：通用型序列傳輸匯流排，具備隨插即用的特性，已成為主流傳輸介面，逐漸取代各種老舊的系統。 USB class： 所謂USB device class，可想像成不同的class定義了不同的電腦硬體。HID（Human Interface Device）便是鍵盤、滑鼠、遊戲搖桿，CDC（Communications Device Class）這就所謂的Virtual COM（虛擬COM埠），MSC（Mass storage Class ）就是隨身碟。 Physical Computing：可翻譯為體感運算或實體互動運算，著重於透過各種硬體與軟體，讓主機電腦（數位）能與周圍環境（類比）溝通與互動，一般指手工設計與製作的藝術裝置或電子機械專案，以微控制器為中心，使用感測器偵測外界（譬如溫度、燈光、壓力、等等），使用致動器（譬如馬達、喇叭、機器手臂）影響外界。 Android Open Accessory： Android 3.1開始支援Android Open Accessory標準（回溯支援到Android 2.3.4），定義了溝通協定與API，讓外部USB周邊硬體能與Android裝置（手機或平板）溝通，讓大家遵循標準開發Android裝置的周邊配件。開發套件叫做ADK（Android Open Accessory Development Kit）。根據這套標準的開發板，有Arduino ADK、Microchip的PIC24F Accessory Development Starter Kit for Android、SparkFun的IOIO for Android、Modern Device的Freeduino USB Host Board、等等。 0.1吋（0.1\"）： 等於2.54mm（公釐、毫米），排針排母與麵包板最常見的孔距。 AWG（American Wire Gauge）： 美國線規，定義導線直徑的標準。數字越小表示線材直徑越粗，所能承載的電流就越大。以太區域網路使用Cat-5非屏蔽雙絞線一般使用AWG 24的線材，而SATA線一般是AWG 26線材。連接電子電路與麵包板時，通常使用20、22、24的線材。 Netduino： 使用32-bit ARM為核心的微控制器，軟體部分為.NET Micro Framework，語言是C#，整合開發環境是Visual Studio，開源硬體平台。其腳位與Arduino相容，所以可插Arduino的shield。 .NET Gadgeteer： 軟體是.NET Micro Framework，整合開發環境是Visual Studio。使用時須有一塊主板加一堆附加模組，其連接介面有一套標準，所以非常「模組化」。 Parallax BASIC Stamp、Basic Stamp 2（BS-2）： 特色是採用PBASIC語言（特製後的BASIC）。 Parallax Propeller、Parallax P8X32A Propeller： 多核心平行運算架構的微控制器，有8顆32位元的RISC CPU。 Basic Micro的BasicATOM： 相容Basic Stamp 2，號稱更快。 Revolution Education(Rev-Ed)的PICAXE： 以各種Microchip PIC晶片為基礎。 mbed： 採用ARM Cortex-M。 LaunchPad： TI的產品，採用MSP430的開發板。 MaKey MaKey： 一塊控制電路板，透過這個控制面板連接電腦，運用電阻感應原理，能夠將任何物體轉換成觸控介面，讓操作這件事情變得更加有趣.。 用香蕉、粘土、水、鉛筆的碳當做觸控媒介。 Uzebox： 復古型電視遊樂器開發平台，以Atmel 8位元AVR微控制器為核心，開放硬體。到這裡看看眾人開發出來的遊戲。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/93-Gstreamer/1-Basic/Readme.html":{"url":"md/93-Gstreamer/1-Basic/Readme.html","title":"Basic","keywords":"","body":"GStreamer tagsstart GStreamer Voice Video tagsstop 前言 pipeline Bins elements source pads sink pads GstBuffer from sources to sinks ((downstream) GstEvent upstream and downstream , 可以從application to element queries messages Image 1 - 1 Image 2 - 2 Image 3 - 3 code $(CC) --silent --tag=CC --mode=link -o $@ -lrt -ldl gst_init (&argc, &argv); gst_version (&major, &minor, &micro, &nano); GST_VERSION_MAJOR GST_VERSION_MINOR GST_VERSION_MICRO GstElement *element; element = gst_element_factory_make (\"fakesrc\", \"source\"); gst_object_unref (GST_OBJECT (element)); gchar *name; g_object_get (G_OBJECT (element), \"name\", &name, NULL); g_free (name); gst_pipeline_new gst_pipeline_get_bus gst_bus_add_watch g_main_loop_new g_main_loop_run gst_pipeline_new bus/message pipeline message handler - mainloop gchar *debug; GError *error; gst_message_parse_error (msg, &error, &debug); g_free (debug); g_printerr (\"Error: %s\\n\", error->message); g_error_free (error); End-of-stream Error Tags State-changes Buffering Element messages Application-specific messages gst_bin_add_many gst_element_link gst_element_link_many g_warning bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline); gst_bus_add_signal_watch (bus); g_signal_connect (bus, \"message::error\", G_CALLBACK (cb_message_error), NULL); g_signal_connect (bus, \"message::eos\", G_CALLBACK (cb_message_eos), NULL); gst_element_get_static_pad (decoder, \"sink\"); gst_pad_link (pad, sinkpad); pad = always sometimes未知來源 ,on request聚合器 ＆Tee elements（複製） gst_element_link (source, demuxer); gst_element_link_many (decoder, conv, sink, NULL); g_signal_connect (demuxer, \"pad-added\", G_CALLBACK (on_pad_added), decoder); pad = gst_element_get_request_pad (tee, \"src%d\"); name = gst_pad_get_name (pad); gst_element_get_pad_list() 調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。 gst_element_get_compatible_pad (mux, tolink_pad); gst_pad_link (tolinkpad, pad); gst_element_set_state GST_STATE_NULL GST_STATE_READY GST_STATE_PAUSED GST_STATE_PLAYING Capabilities 目標 Autoplugging Compatibility detection Metadata Filtering ：audioconvert, audioresample, ffmpegcolorspace or videoscale const GstStructure *str; str = gst_caps_get_structure (caps, 0); if (!gst_structure_get_int (str, \"width\", &width) || !gst_structure_get_int (str, \"height\", &height)) { g_print (\"No width/height available\\n\"); return; } gst_element_link_filtered (demuxer, decoder, caps); struct _GstCaps { gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ }; gst_caps_get_name (cap), gst_caps_get_mime (cap)); 在GStreamer應用程序中使用的箱櫃主要有兩種類型： GstPipeline管道是最常用到的容器，對於一個GStreamer應用程序來講，其頂層箱櫃必須是一條管道。 GstThread線程的作用在於能夠提供同步處理能力，如果GStreamer應用程序需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。 GstElement *thread, *pipeline; //創建線程對象，同時為其指定唯一的名稱。 thread = gst_element_factory_make (\"thread\", NULL); //根據給出的名稱，創建一個特定的管道對象。 pipeline = gst_pipeline_new (\"pipeline_name\"); 箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對象，但由於其自身也是一個GstElement對象 而要從箱櫃中找到特定的元件也很容易，可以藉助gst_bin_get_by_name()函數實現： GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), \"decoder\"); gst_bin_remove() 由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況 具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程序中能夠像使用元件一樣使用這類箱櫃。下面的代碼示範瞭如何為箱櫃添加一個精靈襯墊： GstElement *bin; GstElement *element; element = gst_element_factory_create (\"mad\", \"decoder\"); bin = gst_bin_new (\"bin_name\"); gst_bin_add (GST_BIN (bin), element); gst_element_add_ghost_pad (bin, gst_element_get_pad (element, \"sink\"), \"sink\"); 示範瞭如何將兩個元件通過襯墊連接起來 //連接 gst_pad_link (srcpad, sinkpad); //斷開 gst_pad_unlink (srcpad, sinkpad); 別：初級 肖文鵬,自由軟件愛好者 2004年6月01日 GStreamer是GNOME桌面環境下用來構建流媒體應用的編程框架（framework），其目標是要簡化音/視頻應用程序的開發，目前已經能夠被用來處理像MP3、Ogg、MPEG1、MPEG2、AVI、 Quicktime等多種格式的多媒體數據。 一、基本概念 GStreamer作為GNOME桌面環境推薦的流媒體應用框架，採用了基於插件（plugin）和管道（pipeline）的體系結構，框架中的所有的功能模塊都被實現成可以插拔的組件（component），並且在需要的時候能夠很方便地安裝到任意一個管道上，由於所有插件都通過管道機制進行統一的數據交換，因此很容易利用已有的各種插件“組裝”出一個功能完善的多媒體應用程序。 1.1元件處理 對於需要應用GStreamer框架的程序員來講，GstElement是一個必須理解的概念，因為它是組成管道的基本構件，也是框架中所有可用組件的基礎，這也難怪GStreamer框架中的大部分函數都會涉及到對GstElement對象的操作。從GStreamer自身的觀點來看，GstElement可以描述為一個具有特定屬性的黑盒子，它通過連接點（link point）與外界進行交互，向框架中的其餘部分錶徵自己的特性或者功能。 按照各自功能上的差異，GStreamer又將GstElement細分成如下幾類： Source Element數據源元件只有輸出端，它僅能用來產生供管道消費的數據，而不能對數據做任何處理。一個典型的數據源元件的例子是音頻捕獲單元，它負責從聲卡讀取原始的音頻數據，然後作為數據源提供給其它模塊使用。 Filter Element過濾器元件既有輸入端又有輸出端，它從輸入端獲得相應的數據，並在經過特殊處理之後傳遞給輸出端。一個典型的過濾器元件的例子是音頻編碼單元，它首先從外界獲得音頻數據，然後根據特定的壓縮算法對其進行編碼，最後再將編碼後的結果提供給其它模塊使用。 Sink Element接收器元件只有輸入端，它僅具有消費數據的能力，是整條媒體管道的終端。一個典型的接收器元件的例子是音頻回放單元，它負責將接收到的數據寫到聲卡上，通常這也是音頻處理過程中的最後一個環節。 圖1將有助於你更好地理解數據源元件、過濾器元件和接收器元件三者的區別，同時也不難看出它們是如何相互配合形成管道的： 圖1 需要注意的是，過濾器元件的具體形式是非常靈活的，GStreamer並沒有嚴格規定輸入端和輸出端的數目，事實上它們都可以是一個或者多個。圖2是一個AVI分離器的基本結構，它能夠將輸入數據分離成單獨的音頻信息和視頻信息，用於實現該功能的過濾器元件很明顯只具有一個輸入端，但卻需要有兩個輸出端。 圖2 要想在應用程序中創建GstElement對象，唯一的辦法是藉助於工廠對象GstElementFactory。由於GStreamer框架提供了多種類型的GstElement對象，因此對應地提供了多種類型的GstElementFactory對象，它們是通過特定的工廠名稱來進行區分的。例如，下面的代碼通過gst_element_factory_find()函數獲得了一個名為mad的工廠對象，它之後可以用來創建與之對應的MP3解碼器元件： GstElementFactory *factory; factory = gst_element_factory_find (\"mad\"); 成功獲得工廠對象之後，接下來就可以通過gst_element_factory_create()函數來創建特定的GstElement對象了，該函數在調用時有兩個參數，分別是需要用到的工廠對象，以及即將創建的元件名稱。元件名稱可以用查詢的辦法獲得，也可以通過傳入空指針（NULL）來生成工廠對象的默認元件。下面的代碼示範瞭如何利用已經獲得的工廠對象，來創建名為decoder的MP3解碼器元件： GstElement *element; element = gst_element_factory_create (factory, \"decoder\"); 當創建的GstElement不再使用的時候，還必須調用gst_element_unref()函數釋放其占用的內存資源： gst_element_unref (element); GStreamer使用了與GObject相同的機制來對屬性（property）進行管理，包括查詢（query）、設置（set）和讀取（get）等。所有的GstElement對像都需要從其父對象GstObject那裡繼承名稱（name）這一最基本的屬性，這是因為像gst_element_factory_make()和gst_element_factory_create()這樣的函數在創建工廠對象和元件對象時都會用到名稱屬性，通過調用gst_object_set_name()和gst_object_get_name()函數可以設置和讀取GstElement對象的名稱屬性。 1.2襯墊處理 襯墊（pad）是GStreamer框架引入的另外一個基本概念，它指的是元件（element）與外界的連接通道，對於框架中的某個特定元件來說，其能夠處理的媒體類型正是通過襯墊暴露給其它元件的。成功創建GstElement對象之後，可以通過gst_element_get_pad()獲得該元件的指定襯墊。例如，下面的代碼將返回element元件中名為src的襯墊： GstPad *srcpad; srcpad = gst_element_get_pad (element, \"src\"); 如果需要的話也可以通過gst_element_get_pad_list()函數，來查詢指定元件中的所有襯墊。例如，下面的代碼將輸出element元件中所有襯墊的名稱： GList *pads; pads = gst_element_get_pad_list (element); while (pads) { GstPad *pad = GST_PAD (pads->data); g_print (\"pad name is: %s\\n\", gst_pad_get_name (pad)); pads = g_list_next (pads); } 與元件一樣，襯墊的名稱也能夠動態設置或者讀取，這是通過調用gst_pad_get_name ()和gst_pad_set_name()函數來完成的。所有元件的襯墊都可以細分成輸入襯墊和輸出襯墊兩種，其中輸入襯墊只能接收數據但不能產生數據，而輸出襯墊則正好相反，只能產生數據但不能接收數據，利用函數gst_pad_get_direction()可以獲得指定襯墊的類型。 GStreamer框架中的所有襯墊都必然依附於某個元件之上，調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。襯墊從某種程度上可以看成是元件的代言人，因為它要負責向外界描述該元件所具有的能力。 GStreamer框架提供了統一的機制來讓襯墊描述元件所具有的能力（capability），這是藉助數據結構_GstCaps來實現的： struct _GstCaps { gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ }; 以下是對mad元件的能力描述，不難看出該元件中實際包含sink和src兩個襯墊，並且每個襯墊都帶有特定的功能信息。名為sink的襯墊是mad元件的輸入端，它能夠接受MIME類型為audio/mp3的媒體數據，此外還具有layer、bitrate和framed三種屬性。名為src的襯墊是mad元件的輸出端，它負責產生MIME類型為audio/raw媒體數據，此外還具有format、depth、rate和channels等多種屬性。 Pads: SINK template: ’sink’ Availability: Always Capabilities: ’mad_sink’: MIME type: ’audio/mp3’: SRC template: ’src’ Availability: Always Capabilities: ’mad_src’: MIME type: ’audio/raw’: format: String: int endianness: Integer: 1234 width: Integer: 16 depth: Integer: 16 channels: Integer range: 1 - 2 law: Integer: 0 signed: Boolean: TRUE rate: Integer range: 11025 - 48000 準確地說，GStreamer框架中的每個襯墊都可能對應於多個能力描述，它們能夠通過函數gst_pad_get_caps()來獲得。例如，下面的代碼將輸出pad襯墊中所有能力描述的名稱及其MIME類型： GstCaps *caps; caps = gst_pad_get_caps (pad); g_print (\"pad name is: %s\\n\", gst_pad_get_name (pad)); while (caps) { g_print (\" Capability name is %s, MIME type is %s\\n\", gst_caps_get_name (cap), gst_caps_get_mime (cap)); caps = caps->next; } 1.3箱櫃 箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對象，但由於其自身也是一個GstElement對象，因此實際上也能夠被用來容納其它的箱櫃對象。利用箱櫃可以將需要處理的多個元件組合成一個邏輯元件，由於不再需要對箱櫃中的元件逐個進行操作，因此能夠很容易地利用它來構造更加複雜的管道。在GStreamer框架中使用箱櫃還有另外一個優點，那就是它會試著對數據流進行優化，這對於多媒體應用來講是很具吸引力的。 圖3描述了箱櫃在GStreamer框架中的典型結構： 圖3 在GStreamer應用程序中使用的箱櫃主要有兩種類型： GstPipeline管道是最常用到的容器，對於一個GStreamer應用程序來講，其頂層箱櫃必須是一條管道。 GstThread線程的作用在於能夠提供同步處理能力，如果GStreamer應用程序需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。 GStreamer框架提供了兩種方法來創建箱櫃：一種是藉助工廠方法，另一種則是使用特定的函數。下面的代碼示範瞭如何使用工廠方法創建線程對象，以及如何使用特定函數來創建管道對象： GstElement *thread, *pipeline; //創建線程對象，同時為其指定唯一的名稱。 thread = gst_element_factory_make (\"thread\", NULL); //根據給出的名稱，創建一個特定的管道對象。 pipeline = gst_pipeline_new (\"pipeline_name\"); 箱櫃成功創建之後，就可以調用gst_bin_add()函數將已經存在的元件添加到其中來了： GstElement *element; GstElement *bin; bin = gst_bin_new (\"bin_name\"); element = gst_element_factory_make (\"mpg123\", \"decoder\"); gst_bin_add (GST_BIN (bin), element); 而要從箱櫃中找到特定的元件也很容易，可以藉助gst_bin_get_by_name()函數實現： GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), \"decoder\"); 由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況，gst_bin_get_by_name()函數在查找元件時會對嵌套的箱櫃作遞歸查找。元件有添加到箱櫃之中以後，在需要的時候還可以從中移出，這是通過調用gst_bin_remove()函數來完成的： GstElement *element; gst_bin_remove (GST_BIN (bin), element); 如果仔細研究一下圖3中描述的箱櫃，會發現它沒有屬於自己的輸入襯墊和輸出襯墊，因此顯然是無法作為一個邏輯整體與其它元件交互的。為了解決這一問題，GStreamer引入了精靈襯墊（ghost pad）的概念，它是從箱櫃裡面所有元件的襯墊中推舉出來的，通常來講會同時選出輸入襯墊和輸出襯墊，如圖4所示： 圖4 具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程序中能夠像使用元件一樣使用這類箱櫃。下面的代碼示範瞭如何為箱櫃添加一個精靈襯墊： GstElement *bin; GstElement *element; element = gst_element_factory_create (\"mad\", \"decoder\"); bin = gst_bin_new (\"bin_name\"); gst_bin_add (GST_BIN (bin), element); gst_element_add_ghost_pad (bin, gst_element_get_pad (element, \"sink\"), \"sink\"); 回頁首 二、元件連接 在引入了元件和襯墊的概念之後，GStreamer對多媒體數據的處理過程就變得非常清晰了：通過將不同元件的襯墊依次連接起來構成一條媒體處理管道，使數據在流經管道的過程能夠被各個元件正常處理，最終實現特定的多媒體功能。 圖１就描述了一條很簡單的管道，它由三個基本元件構成：數據源元件只負責產生數據，它的輸出襯墊與過濾器元件的輸入襯墊相連；過濾器元件負責從自己的輸入襯墊中獲取數據，並在經過特定的處理之後，將結果通過輸出襯墊傳給與之相連的接收器元件；接收器元件只負責接收數據，它的輸入襯墊與過濾器元件的輸出襯墊相連，負責對最終結果進行相應的處理。 GStreamer框架中的元件是通過各自的襯墊連接起來的，下面的代碼示範瞭如何將兩個元件通過襯墊連接起來，以及如何在需要的時候斷開它們之間的連接： GstPad *srcpad, *sinkpad; srcpad = gst_element_get_pad (element1, \"src\"); sinpad = gst_element_get_pad (element2, \"sink\"); //連接 gst_pad_link (srcpad, sinkpad); //斷開 gst_pad_unlink (srcpad, sinkpad); 如果需要建立起連接的元件都只有一個輸入襯墊和一個輸出襯墊，那麼更簡單的做法是調用gst_element_link()函數直接在它們之間建立起連接，或者調用gst_element_unlink()函數斷開它們之間的連接： //連接 gst_element_link (element1, element2); //斷開 gst_element_unlink (element1, element2); NULL這是所有元件的默認狀態，表明它剛剛創建，還沒有開始做任何事情。 READY表明元件已經做好準備，隨時可以開始處理流程。 PAUSED表明元件因某種原因暫時停止處理數據。 PLAYING表明元件正在進行數據處理。 所有的元件都從NULL狀態開始，依次經歷NULL、READY、PAUSED、PLAYING等狀態間的轉換。元件當前所處的狀態可以通過調用gst_element_set_state()函數進行切換： GstElement *bin; /*創建元件，並將其連接成箱櫃bin */ gst_element_set_state (bin, GST_STATE_PLAYING); 默認情況下，管道及其包含的所有元件在創建之後將處於NULL狀態，此時它們不會進行任何操作。當管道使用完畢之後，不要忘記重新將管道的狀態切換回NULL狀態，讓其中包含的所有元件能夠有機會釋放它們正在佔用的資源。 管道真正的處理流程是從第一次將其切換到READY狀態時開始的，此時管道及其包含的所有元件將做好相應的初始化工作，來為即將執行的數據處理過程做好準備。對於一個典型的元件來講，處於READY狀態時需要執行的操作包括打開媒體文件和音頻設備等，或者試圖與位於遠端的媒體服務器建立起連接。 處於READY狀態的管道一旦切換到PLAYING狀態，需要處理的多媒體數據就開始在整個管道中流動，並依次被管道中包含的各個元件進行處理，從而最終實現管道預先定義好的某種多媒體功能。 GStreamer框架也允許將管道直接從NULL狀態切換到PLAYING狀態，而不必經過中間的READY狀態。 正處於播放狀態的管道能夠隨時切換到PAUSED狀態，暫時停止管道中所有數據的流動，並能夠在需要的時候再次切換回PLAYING狀態。如果需要插入或者更改管道中的某個元件，必須先將其切換到PAUSED或者NULL狀態，元件在處於PAUSED狀態時並不會釋放其占用的資源。 由於沒有用到線程，因此必須通過不斷調用gst_bin_iterate()函數的辦法，來判斷管道的處理過程會在何時結束： while (gst_bin_iterate (GST_BIN (pipeline))); 只要管道內還會繼續有新的事件產生，gst_bin_iterate()函數就會一直返回TRUE，只有當整個處理過程都結束的時候，該函數才會返回FALSE，此時就該終止管道並釋放佔用的資源了： Manually adding or removing data from/to a pipeline synchronization, thread-safety and other things fakesink fakesrc - old version appsrc appsink - new version cap:is-live min-latency max-latency format = GST_FORMAT_TIME non-live format = GST_FORMAT_TIME or GST_FORMAT_BYTES event : SEGMENT (appsrc will push) 計算接收了多少時間用 gst_app_src_push_buffer \"max-bytes\" property “enough-data” signal “need-data” signal 錄wav gst-launch alsasrc ! audioconvert ! audio/x-raw-int,channel s=1,depth=16,width=16,rate=16000 !audioresample ! wavenc ! filesink location=mic .wav 測試播放 gst-launch audiotestsrc ! audioconvert ! audioresample ! alsasink 播放檔案 gst-launch filesrc location=toto.ogg ! decodebin ! audioconvert ! audioresample ! alsasink 即時播放錄音 gst-launch -v alsasrc ! alsasink sync=FALSE 播放mp3 gst-launch-0.10 -v filesrc location=/response.mp3 ! flump3dec ! alsasink 播放url gst-launch-0.10 playbin2 uri=http://kiis-fm.akacast.akamaistream.net/7/572/19773/v1/auth.akacast.akamaistream.net/kiis-fm null->ready->pause->playing playing->pause>ready->null Sources : filesrc | alsasrc | appsrc Sink: filesink | alsasink | appsink Encoder: Decnoder: decodebin Converter: Bin: playbin Gobject © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/94-Google Cloud/1-Speech/Readme.html":{"url":"md/94-Google Cloud/1-Speech/Readme.html","title":"Speech","keywords":"","body":"Basic tagsstart Google Cloud Speech API tagsstop Request { \"config\": { \"encoding\":\"FLAC\", \"sample_rate\": 16000 }, \"audio\": { \"uri\":\"gs://cloud-samples-tests/speech/brooklyn.flac\" } } 授權 建立資料庫 $ gcloud auth activate-service-account --key-file=service-account-key-file from json file: { \"type\": \"service_account\", \"project_id\": \"zhenkun-957\", \"private_key_id\": \"d19f1f372bdb4493f05fd8d636aa3218f0b9c2a1\", \"private_key\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDDTnzisZPMhds6\\nYUvlyuIUXmB84/zONIkvKLIGhkDXpkmWF6xDGV76RBSMTPu3PGJBwB1hFE2Xetqa\\nnTo0nDFetZe6oVb8g6Yr1aHtSTAYIdtrQIwSXDZaX+6eiY7tA8hy2oXZERWoVbio\\nTVnI4Ga+5hcqeGGRj31IXmm6z1254o3uOBq6+6Q3GmghjTPcVJyxRdpztWbivJuY\\n9CWOqAKZTFTSJ4qPTb7V4smUdYkdWPXdfbKLFs3fy8rES4C7lQNQ57LS36MnxcPm\\niQuuRzDvGdLkOVosTJ3qLDMDGmR8WPau6SGNURNFyNPRjCcTkrntgNbT8y/QqPCE\\ni0P6KenLAgMBAAECggEAZdR0dNXVk9tu1F+KbQN9INWcRUGxu+nUZQw41gIFqOqA\\nj4tEO6/sv1vjwssYqw8Gw/Vg3A7z7bkWZWr4wBl3/EN+GsaoTfxuFYjLZqa0NsDg\\nYGlFHwWJKVG/XlWmeZlxV8Dr7KNlwWEAaG/8Eio+J+Zbyb7+UCCaV7MyOT6JRbMa\\nyiEVTX7JZ/l1c7AhrJ5s8UaZtcxSNNlhV4hC+zJ8DU4eq3bu+66xvit0io6Ymmog\\nDT7chh2SP25b95TUSnZfAxWvvC532viDonyYwYZ9CWt+aBNkWGTuIFZYd6IeC4vH\\nKbLH7f3qbLVFrFQZKQb0urCumWkHFS7ndFYY6TdaQQKBgQDkCwF6L4zMShB96WG7\\nVv8XUJptqd54QVWtlVdeYgdN7TGYescDifQyd33ufDahiTrHv0W0ih4QQQeZd77f\\np/QYuVHdFhMm9UYZq2iVAYBTE9FhomG1rn7BfzTvJI8VEQcAlHMDHn7qtGDtuI5v\\nHjyZPW92ewnp450bEMZ/L/6pGwKBgQDbQBHQ4N7bO07j32SvIazlO1z2O5jeaLxt\\nLPiQyWxfYq6Y2PnPNW+BCM/Zvv45sqJ4NANyBE/1k9qCE+OkRgeLic9Sbz2VWC4x\\nZKzp00awqnJLM4jDnVXw4FijtN6bsJeSPVRRZwAgP0vcb51gO/CRkG0gzMUCJvWI\\ncM4f0nP9EQKBgQDPkMTzdjxt5ixErxzp7DGcAx3NG4UHaFCYAwrXOdr0LyWpaHek\\n3PiMxv61CBKhzcrW7V6BCgZ7PPWx1rDB2pnvtx6wYdtk5nO8Aazbk9Y9yBgZCjht\\nqjpt3V9NHLWvsyPwfy6AdE2JTE29kvLyaU83HBhMe4l2flsNu6MxOXpOaQKBgQCa\\nQiPG0NA7cyj4Ts6qIYlh5zhqzlep9ArOzZs9U1p6ahXp2I86aKBBKxACZcy8j6Cb\\n7gyWhc40PIi6iH/brqHUXWuO1lF/6ADoI6s9ALd1yRaNLn8FEofK6C21UKZm6AJc\\nk+XlOBDwn1giii0x7jo+UF1XfHsIHp0WGDgOT6Xn4QKBgQDetLe431FFDbYmsdAd\\nSov8Dy8loxRhkeGUxf7qWrf3cI4/fKqmT29L0NjayEglQTd3V6aF2OhjX/gOo1Vf\\nQcQvolD1efN+D66rRpwSPSzQ2oDPXwWyCdJr7I24zjjvbfG/pCkrdqAk1zwUxx81\\nAHo1qvXT+fDb1ZM2U90PPieptQ==\\n-----END PRIVATE KEY-----\\n\", \"client_email\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"client_id\": \"103111512865080355330\", \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\", \"token_uri\": \"https://accounts.google.com/o/oauth2/token\", \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\", \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/zhenkun%40zhenkun-957.iam.gserviceaccount.com\" } 由這個取出這六個參數(surface/auth/activate_service_account.py) \"client_id\": \"103111512865080355330\", \"client_email\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"private_key_id\": \"d19f1f372bdb4493f05fd8d636aa3218f0b9c2a1\", \"private_key\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDDTnzisZPMhds6\\nYUvlyuIUXmB84/zONIkvKLIGhkDXpkmWF6xDGV76RBSMTPu3PGJBwB1hFE2Xetqa\\nnTo0nDFetZe6oVb8g6Yr1aHtSTAYIdtrQIwSXDZaX+6eiY7tA8hy2oXZERWoVbio\\nTVnI4Ga+5hcqeGGRj31IXmm6z1254o3uOBq6+6Q3GmghjTPcVJyxRdpztWbivJuY\\n9CWOqAKZTFTSJ4qPTb7V4smUdYkdWPXdfbKLFs3fy8rES4C7lQNQ57LS36MnxcPm\\niQuuRzDvGdLkOVosTJ3qLDMDGmR8WPau6SGNURNFyNPRjCcTkrntgNbT8y/QqPCE\\ni0P6KenLAgMBAAECggEAZdR0dNXVk9tu1F+KbQN9INWcRUGxu+nUZQw41gIFqOqA\\nj4tEO6/sv1vjwssYqw8Gw/Vg3A7z7bkWZWr4wBl3/EN+GsaoTfxuFYjLZqa0NsDg\\nYGlFHwWJKVG/XlWmeZlxV8Dr7KNlwWEAaG/8Eio+J+Zbyb7+UCCaV7MyOT6JRbMa\\nyiEVTX7JZ/l1c7AhrJ5s8UaZtcxSNNlhV4hC+zJ8DU4eq3bu+66xvit0io6Ymmog\\nDT7chh2SP25b95TUSnZfAxWvvC532viDonyYwYZ9CWt+aBNkWGTuIFZYd6IeC4vH\\nKbLH7f3qbLVFrFQZKQb0urCumWkHFS7ndFYY6TdaQQKBgQDkCwF6L4zMShB96WG7\\nVv8XUJptqd54QVWtlVdeYgdN7TGYescDifQyd33ufDahiTrHv0W0ih4QQQeZd77f\\np/QYuVHdFhMm9UYZq2iVAYBTE9FhomG1rn7BfzTvJI8VEQcAlHMDHn7qtGDtuI5v\\nHjyZPW92ewnp450bEMZ/L/6pGwKBgQDbQBHQ4N7bO07j32SvIazlO1z2O5jeaLxt\\nLPiQyWxfYq6Y2PnPNW+BCM/Zvv45sqJ4NANyBE/1k9qCE+OkRgeLic9Sbz2VWC4x\\nZKzp00awqnJLM4jDnVXw4FijtN6bsJeSPVRRZwAgP0vcb51gO/CRkG0gzMUCJvWI\\ncM4f0nP9EQKBgQDPkMTzdjxt5ixErxzp7DGcAx3NG4UHaFCYAwrXOdr0LyWpaHek\\n3PiMxv61CBKhzcrW7V6BCgZ7PPWx1rDB2pnvtx6wYdtk5nO8Aazbk9Y9yBgZCjht\\nqjpt3V9NHLWvsyPwfy6AdE2JTE29kvLyaU83HBhMe4l2flsNu6MxOXpOaQKBgQCa\\nQiPG0NA7cyj4Ts6qIYlh5zhqzlep9ArOzZs9U1p6ahXp2I86aKBBKxACZcy8j6Cb\\n7gyWhc40PIi6iH/brqHUXWuO1lF/6ADoI6s9ALd1yRaNLn8FEofK6C21UKZm6AJc\\nk+XlOBDwn1giii0x7jo+UF1XfHsIHp0WGDgOT6Xn4QKBgQDetLe431FFDbYmsdAd\\nSov8Dy8loxRhkeGUxf7qWrf3cI4/fKqmT29L0NjayEglQTd3V6aF2OhjX/gOo1Vf\\nQcQvolD1efN+D66rRpwSPSzQ2oDPXwWyCdJr7I24zjjvbfG/pCkrdqAk1zwUxx81\\nAHo1qvXT+fDb1ZM2U90PPieptQ==\\n-----END PRIVATE KEY-----\\n\" \"scopes\" : \"\"('https://www.googleapis.com/auth/userinfo.email', 'https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/appengine.admin', 'https://www.googleapis.com/auth/compute')\"\" \"\"user_agent\":\"\"google-cloud-sdk\" 建立出(surface/auth/activate_service_account.py) { \"service_account_name\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"_service_account_id\": \"103111512865080355330\", \"id_token\": null, \"_token_uri\": \"https://accounts.google.com/o/oauth2/token\", \"token_uri\": \"https://accounts.google.com/o/oauth2/token\", \"_private_key_id\": \"d19f1f372bdb4493f05fd8d636aa3218f0b9c2a1\", \"token_response\": null, \"client_id\": null, \"token_expiry\": null, \"_class\": \"ServiceAccountCredentials\", \"refresh_token\": null, \"_module\": \"googlecloudsdk.core.credentials.service_account\", \"_private_key_pkcs8_text\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDDTnzisZPMhds6\\nYUvlyuIUXmB84/zONIkvKLIGhkDXpkmWF6xDGV76RBSMTPu3PGJBwB1hFE2Xetqa\\nnTo0nDFetZe6oVb8g6Yr1aHtSTAYIdtrQIwSXDZaX+6eiY7tA8hy2oXZERWoVbio\\nTVnI4Ga+5hcqeGGRj31IXmm6z1254o3uOBq6+6Q3GmghjTPcVJyxRdpztWbivJuY\\n9CWOqAKZTFTSJ4qPTb7V4smUdYkdWPXdfbKLFs3fy8rES4C7lQNQ57LS36MnxcPm\\niQuuRzDvGdLkOVosTJ3qLDMDGmR8WPau6SGNURNFyNPRjCcTkrntgNbT8y/QqPCE\\ni0P6KenLAgMBAAECggEAZdR0dNXVk9tu1F+KbQN9INWcRUGxu+nUZQw41gIFqOqA\\nj4tEO6/sv1vjwssYqw8Gw/Vg3A7z7bkWZWr4wBl3/EN+GsaoTfxuFYjLZqa0NsDg\\nYGlFHwWJKVG/XlWmeZlxV8Dr7KNlwWEAaG/8Eio+J+Zbyb7+UCCaV7MyOT6JRbMa\\nyiEVTX7JZ/l1c7AhrJ5s8UaZtcxSNNlhV4hC+zJ8DU4eq3bu+66xvit0io6Ymmog\\nDT7chh2SP25b95TUSnZfAxWvvC532viDonyYwYZ9CWt+aBNkWGTuIFZYd6IeC4vH\\nKbLH7f3qbLVFrFQZKQb0urCumWkHFS7ndFYY6TdaQQKBgQDkCwF6L4zMShB96WG7\\nVv8XUJptqd54QVWtlVdeYgdN7TGYescDifQyd33ufDahiTrHv0W0ih4QQQeZd77f\\np/QYuVHdFhMm9UYZq2iVAYBTE9FhomG1rn7BfzTvJI8VEQcAlHMDHn7qtGDtuI5v\\nHjyZPW92ewnp450bEMZ/L/6pGwKBgQDbQBHQ4N7bO07j32SvIazlO1z2O5jeaLxt\\nLPiQyWxfYq6Y2PnPNW+BCM/Zvv45sqJ4NANyBE/1k9qCE+OkRgeLic9Sbz2VWC4x\\nZKzp00awqnJLM4jDnVXw4FijtN6bsJeSPVRRZwAgP0vcb51gO/CRkG0gzMUCJvWI\\ncM4f0nP9EQKBgQDPkMTzdjxt5ixErxzp7DGcAx3NG4UHaFCYAwrXOdr0LyWpaHek\\n3PiMxv61CBKhzcrW7V6BCgZ7PPWx1rDB2pnvtx6wYdtk5nO8Aazbk9Y9yBgZCjht\\nqjpt3V9NHLWvsyPwfy6AdE2JTE29kvLyaU83HBhMe4l2flsNu6MxOXpOaQKBgQCa\\nQiPG0NA7cyj4Ts6qIYlh5zhqzlep9ArOzZs9U1p6ahXp2I86aKBBKxACZcy8j6Cb\\n7gyWhc40PIi6iH/brqHUXWuO1lF/6ADoI6s9ALd1yRaNLn8FEofK6C21UKZm6AJc\\nk+XlOBDwn1giii0x7jo+UF1XfHsIHp0WGDgOT6Xn4QKBgQDetLe431FFDbYmsdAd\\nSov8Dy8loxRhkeGUxf7qWrf3cI4/fKqmT29L0NjayEglQTd3V6aF2OhjX/gOo1Vf\\nQcQvolD1efN+D66rRpwSPSzQ2oDPXwWyCdJr7I24zjjvbfG/pCkrdqAk1zwUxx81\\nAHo1qvXT+fDb1ZM2U90PPieptQ==\\n-----END PRIVATE KEY-----\\n\", \"access_token\": null, \"_kwargs\": { }, \"_user_agent\": \"google-cloud-sdk\", \"invalid\": false, \"_service_account_email\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"_revoke_uri\": \"https://accounts.google.com/o/oauth2/revoke\", \"assertion_type\": null, \"_scopes\": \"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/appengine.admin https://www.googleapis.com/auth/compute\", \"client_secret\": null, \"revoke_uri\": \"https://accounts.google.com/o/oauth2/revoke\", \"user_agent\": \"google-cloud-sdk\" } 取得access token(third_party/oauth2client/service_account.py) $ gcloud auth print-access-token access_token { 'alg': 'RS256', 'typ': 'JWT', 'kid': 'd19f1f372bdb4493f05fd8d636aa3218f0b9c2a1' } { 'iss': 'zhenkun@zhenkun-957.iam.gserviceaccount.com', 'scope': 'https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/appengine.admin https://www.googleapis.com/auth/compute', 'aud': 'https://accounts.google.com/o/oauth2/token', 'exp': 1471940749, 'iat': 1471937149 } © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/94-Google Cloud/2-Map/1-Distance_Matrix.html":{"url":"md/94-Google Cloud/2-Map/1-Distance_Matrix.html","title":"Distance Matrix","keywords":"","body":"Distance Matrix tagsstart Google Cloud Map API Distance Matrix tagsstop 計價 標準使用者 每天可以有 2,500 個免費元素。 每個查詢可以有 100 個元素。 每 10 秒可以有 100 個元素。 每 1000 個額外元素為 $0.50 美元，每天最多可以有 100,000 個元素。 進階使用者 每日配額每 24 小時可有 100,000 個元素以上，視年度合約購買量而定。 每個查詢可以有 625 個元素。 每 10 秒可以有 1,000 個元素。 多點距離 & 時間 URL：https://maps.googleapis.com/maps/api/distancematrix/output?input=value Python：API - Client.distance_matrix Python：Source Code - distance_matrix.py 起點與目的地矩陣的旅行距離與時間。 Key Input Option Input Output Type Output Rows Element keykey modemode xmlxml statusTop status elementelement statusElement status originsorigins languagelanguage jsonjson origin_addressesorigin_addresses durationduration destinationsdestinations avoidavoid destination_addressesdestination_addresses duration_in_trafficduration_in_traffic unitsunits rowsrows distancedistance arrival_timearrival_time farefare departure_timedeparture_time traffic_modeltraffic_model transit_modetransit_mode transit_routing_preferencetransit_routing_preference Python Library def distance_matrix(client, origins, destinations,mode=None, language=None, avoid=None, units=None,departure_time=None, arrival_time=None,transit_mode=None,transit_routing_preference=None, traffic_model=None) Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') origins = ['Vancouver BC','Seattle'] destinations = ['San Francisco','Victoria BC'] directions_result = client.distance_matrix(origins,destinations) for i in directions_result.get('rows'): print i print '------------------------------' Output { \"destination_addresses\" : [ \"美國加利福尼亞州舊金山\", \"加拿大英屬哥倫比亞維多利亞\" ], \"origin_addresses\" : [ \"加拿大英屬哥倫比亞溫哥華\", \"美國華盛頓西雅圖\" ], \"rows\" : [ { \"elements\" : [ { \"distance\" : { \"text\" : \"1,528 公里\", \"value\" : 1528399 }, \"duration\" : { \"text\" : \"15 小時 6 分\", \"value\" : 54365 }, \"status\" : \"OK\" }, { \"distance\" : { \"text\" : \"114 公里\", \"value\" : 114161 }, \"duration\" : { \"text\" : \"3 小時 10 分\", \"value\" : 11403 }, \"status\" : \"OK\" } ] }, { \"elements\" : [ { \"distance\" : { \"text\" : \"1,300 公里\", \"value\" : 1299971 }, \"duration\" : { \"text\" : \"12 小時 36 分\", \"value\" : 45340 }, \"status\" : \"OK\" }, { \"distance\" : { \"text\" : \"172 公里\", \"value\" : 171688 }, \"duration\" : { \"text\" : \"4 小時 35 分\", \"value\" : 16479 }, \"status\" : \"OK\" } ] } ], \"status\" : \"OK\" } key:Key：您應用程式的API 金鑰。 language:Language：語言設定，請參閱支援的語言清單。 arrival_time:arrival_time：針對大眾運輸要求指定抵達時間(秒)，自 1970 年 1 月 1 日午夜 (UTC) 起算，不可與departure_time並存。 departure_time:departure_time：出發時間(秒)，自 1970 年 1 月 1 日午夜 (UTC) 起算，值可以是now。如果mode=driving時，設定此值才會回傳duration_in_traffic。 transit_mode:transit_mode：選擇大眾運輸方式，只有當mode為 transit 時，才能為要求指定此參數。(bus|subway|train|tram|rail(=train+tram+subway)) transit_routing_preference:transit_routing_preference：選擇大眾運輸的偏好，只有當mode為 transit 時，才能為要求指定此參數。(less_walking|fewer_transfers) © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/94-Google Cloud/2-Map/2-Places.html":{"url":"md/94-Google Cloud/2-Map/2-Places.html","title":"Places","keywords":"","body":"Places tagsstart Google Cloud Map API Places tagsstop 計價 每 24 小時期間 1 000 個要求 每 24 小時期間 150 000 個要求 「文字搜尋」服務會乘上 10 倍 places.py 地點資料 附近地點搜尋 URL:https://maps.googleapis.com/maps/api/place/nearbysearch/output?input=value Python:Client.places_nearby 搜尋指定區域內的地點。 Key Input Option Input Output Type Output Result keykey keywordkeyword xmlxml statusstatus name locationlocation languagelanguage jsonjson html_attributions vicinity radiusradius minpriceminprice next_page_token type maxpricemaxprice result geometry namename rating opennowopennow icon rankbyrankby reference typestypes id pagetokenpagetoken opening_hours zagatselectedzagatselected photo place_id scope Python Library def places_nearby(client, location, radius=None, keyword=None, language=None,min_price=None, max_price=None, name=None, open_now=False,rank_by=None, type=None, page_token=None) 到 Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') languages = 'zh-TW' location = (25.1207, 121.5019) types = 'gas_station' radius = 500 directions_result = client.places_nearby(location, radius ,language=languages, type=types) for i in directions_result.get('results'): print 'rating:',i.get('rating') print 'name:',i.get('name') print 'scope:',i.get('scope') print 'types:',i.get('types') print 'vicinity:',i.get('vicinity') print '-------------------------------------' 文字搜尋 URL:https://maps.googleapis.com/maps/api/place/textsearch/output?input=value Python:Client.places 搜尋指定區域內的地點。 Key Input Option Input Output Type Output Result keykey location location xmlxml statusstatus name queryquery languagelanguage jsonjson html_attributions type minpriceminprice next_page_token formatted_address maxpricemaxprice result geometry radius radius rating opennowopennow icon typestypes reference pagetokenpagetoken id zagatselectedzagatselected opening_hours photo price_level place_id Python Library def places(client, query, location=None, radius=None, language=None,min_price=None, max_price=None, open_now=False, type=None,page_token=None) Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') languages = 'zh-TW' location = (25.1203050, 121.5017983) types = 'food' radius = 100 query = 'Subway' directions_result = client.places(query,location,radius=radius,type=types) for i in directions_result.get('results'): print 'rating:',i.get('rating') print 'name:',i.get('name') print 'types:',i.get('types') print 'formatted_address:',i.get('formatted_address') print '-------------------------------------' 雷達搜尋 URL:https://maps.googleapis.com/maps/api/place/radarsearch/output?input=value Python:Client.places_radar 可讓您一次搜尋高達 200 個地點，但是與一般從「文字搜尋」或「附近地點搜尋」要求傳回的資訊相比較不詳細。 Key Input Option Input Output Type Output Result keykey keywordkeyword xmlxml statusstatus id locationlocation namename jsonjson html_attributions place_id radiusradius minpriceminprice next_page_token reference maxpricemaxprice result geometry opennowopennow typestypes zagatselectedzagatselected Python Library def places_radar(client, location, radius, keyword=None, min_price=None, max_price=None, name=None, open_now=False, type=None) Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') location = (25.1203050, 121.5017983) radius = 1000 keyword = 'Subway' types = 'food' directions_result = client.places_radar(location,radius,keyword,type=types) for i in directions_result.get('results'): print 'geometry:',i.get('geometry') print 'id:',i.get('id') print 'place_id:',i.get('place_id') print 'reference:',i.get('reference') print '-------------------------------------' 地點詳細資料 place https://maps.googleapis.com/maps/api/place/details/output?parameters 地點相片 places_photo https://maps.googleapis.com/maps/api/place/photo?parameters 地點自動完成 places_autocomplete https://maps.googleapis.com/maps/api/place/autocomplete/output?parameters 查詢自動完成 places_autocomplete_query https://maps.googleapis.com/maps/api/place/queryautocomplete/output?parameters 新增地點 https://maps.googleapis.com/maps/api/place/add/json?key=YOUR_API_KEY 查詢自刪除地點動完成 https://maps.googleapis.com/maps/api/place/delete/json?key=YOUR_API_KEY key:Key：您應用程式的API 金鑰。 location:Location：用來擷取其周圍地點資訊的緯度/經度。指定 location 參數，就必須一併指定 radius 參數。 radius:Radius：定義要傳回地點結果的距離範圍 (單位為公尺)。允許的最大半徑是50,000 公尺。請注意，如果已指定 rankby=distance就不得包括 radius。 language:Language：語言設定，請參閱支援的語言清單。 name:Name：要與地點的名稱比對的一或多個字詞 (以空格字元分隔)。 minprice:Minprice：有效值的範圍是 0 (最負擔得起) 到 4 (最昂貴)，含 0 和 4。特定值所代表的確切金額將因地區而異。 maxprice:Maxprice：有效值的範圍是 0 (最負擔得起) 到 4 (最昂貴)，含 0 和 4。特定值所代表的確切金額將因地區而異。 rankby:Rankby：指定列出結果的順序。(prominence |distance)。 types:Types：將結果限制在至少與其中一個指定類型相符的地點。類型應該以直立線符號分隔 (type1|type2|etc)。請參閱支援的類型清單。 pagetoken:Pagetoken：傳回上次執行之搜尋的接下來 20 個結果。設定 pagetoken 參數將會使用與先前使用的相同參數來執行搜尋，pagetoken 以外的所有參數都將被忽略。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/95-Git/1-Basic/Readme.html":{"url":"md/95-Git/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Git tagsstop Introduction git config --global user.name \"\" git config --global user.email \"\" git config --global alias.co checkout git config --global core.editor vim git init 使用 git status 來檢視所有檔案的狀態 使用 git add 來告知 git，哪些是我們即將要提交（commit）的檔案 git rm 使用 git commit 來提交一個 patch，並且使用 vim 編輯提交訊息（包含標題及內容） git mv 使用 git log 檢視提交的歷史訊息 --oneline使用 git show 檢視最後一次提交的 patch 所修改內容 git add --all 不論檔案狀態是 Untracked files 或是 Changes not staged for commit（紅色），都會一口氣變成 Changes to be committed（綠色） git add -u # 一次加入所有被更動的檔案，包含 modified 及 deleted Changes not staged for commit（紅色），都會一口氣變成 Changes to be committed（綠色） git add -f 強制 add 被忽略的檔案 第一行為 commit message 的標題（僅限一行） 第二行保留空白 第三行以後是 commit message 的內容（可略過不寫） git diff 只能檢視 Changes not staged for commit 區塊（紅色）的修改內容 git diff hello_world.txt git diff --cached # 檢視Changes to be committed(綠色)部分的內容 git reset git reset HEAD 使用 git reset HEAD 來還原 \"檔案狀態\" 使用 git checkout -- 來還原 \"檔案內容\" 使用 git reset --soft HEAD^ 使 patch 回到上一個階段的 Changes to be committed git reset --soft HEAD@{1} git reset --hard HEAD 可以一次將 Changes not staged for commit 和 Changes to be committed 的區域清空，但不包含Untracked files git reset HEAD^ 回到前一個 patch，且恢復檔案的狀態 git reset --soft HEAD^ 回到前一個 patch，但保持檔案狀態為 Changes to be committed git reset --hard HEAD^ 回到前一個 patch，且強制清除檔案的修改內容 忽略Untracked files .gitignore *.exe # 忽略所有 xxx.exe 的檔案 接著我們可以透過 git checkout -- 來還原檔案的內容 $ git checkout -- num.txt 組合記 $git add -A # 把所有檔案加到 Changes to be committed $git reset --hard HEAD # 一次還原所有檔案的內容 組合記的組合記 $git submodule foreach --recursive git add -A $git submodule foreach --recursive git reset --hard HEAD HEAD^ 或 HEAD~1 可以用來表示上一個 patch HEAD^^ 或 HEAD~2 可以用來表示上兩個 patch HEAD^^^ 或 HEAD~3 可以用來表示上三個 patch git show HEAD~2 在 git 的世界裡，凡事 HEAD 發生改變都會被記錄下來 哪些時候 HEAD 會發生改變呢？ git commit 提交一份新的 patch，HEAD 會轉移到新的 patch git reset --hard 切換 patch 的時候 git cherry-pick/revert ... 挑入/挑出 patch 的時候 git checkout 切換分支的時候 git merge/rebase ... 合併分支的時候 git reflog 用來看Head的移動 git log -g 查看 reflog 的詳細內+ git commit --amend 的注意事項（非常雷 x 2） 使用指令 git commit --amend 後，會馬上進入 vim 的文字編輯模式 git 不論你是否有修改 commit message 或是用 :q! 不存檔直接離開 vim 都會為你重新產生新的 commit id 有時候這並不一定是我們想要的結果，要特別留意！ 例如說，我們從 server 上抓了最新的 code 下來，準備要新增一個功能再上傳至 server 但是你好死不死的手殘按到 git commit --amend 先改到了最新的 patch（P0） 這時候儘管你按 :q! 退出 vim，但是 commit id 早就已經被改掉了（P0'） 然後我們基於 P0' 來開發新功能，並且 commit 了一個新的 patch（P1） 這時候我們要上傳 patch 的時候，會遇到被 git server 拒絕的情形 被拒絕的原因是，server 認為你提交的 patch 跟 server 的 code 並沒有兩樣 但其實主要原因是，server 認為你上傳了兩個的 patch，分別是 P0' 跟 P1 server 先用 P0' 跟 P0 最比對，發現兩個 patch 根本就一模一樣，就直接拒絕了 當你絞盡腦汁的想要找出 P1 哪裡有問題的時候，其實是被 git commit --amend 背後默默捅了一刀 因此上傳 patch 前請確保 parent id 正確無誤 git commit --amend # 使用後會進入 vim 文字編輯模式。把標題改成 \"Add 77\" 然後存檔離開 $ git reset --hard edb3d9c # 回到 P3 $ git cherry-pick b2dbf88 # 挑入 P5 → P5' $ git cherry-pick 8cb205e # 挑入 P6 → P6' 解完衝突請執行 git cherry-pick --continue 若要放棄請執行 git cherry-pick --abort $ git rebase -i # 啟動 rebase 互動模式 如果不想要有 git reflog 的紀錄的話，就要將把 TODO 的內容清空或是註解掉 git rebase --skip git rebase --continue git rebase --abort 全部取消，並且回到 rebase 前的狀態 patch 多沒有關係，但 patch 改的內容要越細越好 git branch git branch git checkout 切換分支 git clone -b RB14.12 https://git.allseenalliance.org/gerrit/core/alljoyn.git git checkout -b $ git checkout git branch -f git branch -D 刪除分支 我們必須切到其它分支上，才能把 feature 分支刪除 git checkout 移動 HEAD 的位置 git push (遠端倉庫名ex:orginal) (分支名ex:master) Git 除了可以用 cherry-pick 和 rebase 的方式來合併分支之外 還可以用 merge 指令來合併分支 git merge bugFix git stash git stash list git config --global core.editor vim git add submoudle git submoudle add subdir git clone submoudle git clone --recurse-submodules https://github.com/schnell18/dotvim.git update submoudle git submodule foreach git pull origin Merge detached HEAD back to origin/master – Git $git checkout c2744f95d $git checkout –b temp #makes a new branch from current detached HEAD $git branch –f master temp #update master to point to the new branch $git branch –d temp #delete the branch $git push origin master #push the re-established history git pull --rebase 加上 rebase 的意思是，會先 1.把本地 repo. 從上次 pull 之後的變更暫存起來 2. 回復到上次 pull 時的情況 3. 套用遠端的變更 4. 最後再套用剛暫存下來的本地變更。詳細說明可以參考 pull with rebase。 git push origin HEAD:master If you want to stash only specific files, do the following: Stage the files you don't want to stash And the following command: git stash save --keep-index For example # On branch develop # Changes to be committed: # (use \"git reset HEAD ...\" to unstage) # # modified: fileA # modified: fileB # # Changes not staged for commit: # (use \"git add ...\" to update what will be committed) # (use \"git checkout -- ...\" to discard changes in working directory) # # modified: fileC # modified: fileD git stash save --keep-index © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/1-TCP_IP與OSI網路模型.html":{"url":"md/96-Network/1-CCNA/1-TCP_IP與OSI網路模型.html","title":"TCP_IP與OSI網路模型","keywords":"","body":"TCP/IP與OSI網路模型 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 中文 英文 全稱 SOHO small office home office 數位用戶線路 DSL digital subscriber line 國際標準組織 ISO International Organization for Standardization 開放系統互連 OSI Open System Interconnection 美國國防部 DoD 開放系統互連 OSI Open System Interconnection 傳輸控制協定 TCP Transmission Control Protocol 使用者資料包協定 UDP User Datagram Protocol 資料段 segment 封包 packet 訊框 frame 協定資料單元 PDU Protocol Data Unit 歷史 對外連線是透過乙太網路連到DSL或Cable數據機 DSL再透過同軸電纜接到有線電視的插座 同軸電纜跟有線電視是同一種纜線 建置網路模型需要藍圖，如同建築工程師 於是各家企業開始提出自己的藍圖 Image 1 - 1-1 TCP/IP未紅以前，購買不同廠商的電腦，就要建置不同的網路模型 後來ISO制定了OSI模型 DoD也制定了TCP/IP模型，而且贏了 概觀 TCP/IP 採用RFC文件製作 左邊是舊版，右邊是新版 Image 2 - 1-2 TCP/IP應用層 定義應用程式所需的服務，如HTTP Image 3 - 1-3 TCP/IP傳輸層 代表作有TCP與UDP 目的是為上層提供服務 如TCP的錯誤修復 Image 4 - 1-4 透過增加SEQ碼來確認是否Lost封包 相鄰層互動指的是同一台電腦的上下層互動 同層互動指的是不同電腦，透過網路相同階層上的互動 TCP/IP網路層 負責IP定址&路由這類的工作 類似郵政服務 Image 5 - 1-5 TCP/IP鏈結層 根據特定媒介的協定，替封包加上LAN或WAN的標頭跟標尾 Image 6 - 1-6 TCP/IP實體層 指接頭 、腳位、電流量、編碼、光調變等 Image 7 - 1-7 TCP/IP模型 封裝是指鏈結層 資料段(segment)、封包(packet )、訊框(frame) Image 8 - 1-8 封包是添加東西最多、最肥的一層 OSI網路模型 應用層: 通訊軟體介面，如HTTP 表現層: 加密與資料格式，如ASCII & JPEG 會談層: 控制與結束對話 網際網路層vs網路層 Image 9 - 1-9-1 口訣All People Seem To Need Data Processing. (字首對應7-1層) 分層優點有不複雜、標準介面、易於學習、易於發展、廠商互通、工程模組化 Image 10 - 1-9-2 OSI的封裝術語為協定資料單元(PDU) Image 11 - 1-9-3 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/2-乙太區域網路基本觀念.html":{"url":"md/96-Network/1-CCNA/2-乙太區域網路基本觀念.html","title":"乙太區域網路基本觀念","keywords":"","body":"乙太區域網路基本觀念 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 中文 英文簡稱 英文全稱 乙太網路 Ethernet 存取點 AP Access Point 無遮蔽雙絞線 UTP Unshielded Twisted-Pair 電磁干擾 EMI Electromagnetic Interface 串音 crosstalk 最大傳輸單元 MTU Maximum transmission unit 廣播位置 Broadcast address 群播位置 Multicast address 錯誤復原 error recovery 錯誤檢測 error detection 載波感應多重存取/碰撞偵測 CSMA/CD 乙太網路概述 LAN區域網路與WAN廣域網路不同 乙太網路使用乙太網路電纜，所以是指有線區域網路 乙太網路使用標準開頭IEEE 802.3 WLAN無線區域網路使用IEEE 802.11，並不屬於乙太網路 HUB、Switch、Router三者有別 AP類似Switch 乙太網路定義 乙太網路是指一系列實體層與鏈結層的標準。 每個乙太網路標準，是定義某特定電纜、某特定速度下的協定。 一般來說，電纜分為光纖電纜或是銅質電纜。 光纖電纜採用玻璃纖維。 銅質電纜採用無遮蔽雙絞線(UTP)。 乙太網路實體層標準種類 IEEE對乙太網路的簡稱: 速率+BASE+T(UTP) or X(光纖) Image 1 - 2-3-1 網路工程師選購設備，需知道此設備支援的乙太網路標準名稱 即便是不同類型，但只要是乙太網路，鏈結層標頭標尾都一樣 區網不同的線段，傳輸速率不一定一樣 Image 2 - 2-3-1 乙太網路實體層原理 節點用乙太網路埠上的電路系統連接一對芯線造成迴圈 Image 3 - 2-4-1 Image 4 - 2-4-2 發送端用相同編碼方式，隨時間推移，改變電氣訊號 接收端用相同編碼方式，隨時間推移，將電氣訊號翻譯回0或是1。 10M代表千萬分之一秒翻譯一個0或是1 實際上UTP電纜的芯線是互相扭絞，並非平行。這是為了抵銷電磁干擾(EMI) 兩條芯線內的EMI稱為串音(crosstalk) 乙太網路UTP電纜的兩端為RJ45接頭 & RJ45埠 10M & 100M是兩對芯線 1000M是四對芯線 每一對芯線有自己的顏色，如藍色與藍白色 RJ11接頭是北美電話線 GB乙太網路有專屬的Gigabit介面轉接器(GBIC)。有些還帶小型可插拔模組 SFP Image 5 - 2-4-3 乙太網路實體層接腳 目前為止，就像在自家開車，無須規則，但上路後需要遵守規則 一對芯線送，一對芯線收 Image 6 - 2-5-1 PC網路卡vs交換器，是採用平行腳腳位(因為收送端相反) 兩種類似的設備相連，採用交叉線腳位 Image 7 - 2-5-2 即便你接錯誤的電纜，仍然正常運作， 是因為Cisco交換器有auto-mdix的功能，改變錯誤的邏輯 1000M有四對芯線與更先進的設備，每一對可同時收送 1.2一對 3.6一對 4.5一對 7.8一對 Image 8 - 2-5-3 乙太網路資料鏈結層協定 乙太網路的優勢就是，這些協定的鏈結層都是標頭-資料-標尾 乙太網路實際上有數個標頭格式，圖中是最普遍的 Image 9 - 2-6-1 1500 bytes是IP MTU(最大傳輸單元) 媒體存取控制 MAC 是6 bytes 正常MAC傳遞，稱為單點傳播(Unicast)，相對於廣播(broadcast)和群播(muticast) Image 10 - 2-6-2 MAC碼的前三Bytes為製造商代碼，是製造商向IEEE申請3 bytes的組織唯一識別碼(OUI)當開頭 後3 bytes是製造商分配的唯一值，且不能是任何存在的OUI碼(為了獨一無二) Image 11 - 2-6-3 乙太網路中的MAC位置與廣播、群播的關係 MAC又被稱為實體位置、燒錄位置(BIA) 指MAC被燒錄在網路卡的ROM晶片中 廣播位置(Broadcast address)為FFFF.FFFF.FFFF，使乙太網路中的所有設備都被傳遞到 群播位置(Multicast address)有特定位置，在此特定位置中的乙太網路設備都被傳遞到 網路層協定有IPv4、IPv6、AppleTalk、DECnet、NetWare、SNA IEEE定義所有每一種網路層協定，在標頭代表一個Type的數值 FCS是用發送端對訊框做複雜數學運算後的值 接收端透過將FCS反運算來進行錯誤檢測(Error detection) 錯誤檢測(error detection)並不等同於錯誤復原(error recovery) 錯誤檢測後，凡是錯誤的訊框必須丟棄 TCP會要求再次發送，來復原遺失的資料 Hub與Switch的半雙工與全雙工 半雙工是一種概念，代表著不能同時發送or同時接收，用來防止碰撞，如Hub 全雙工則可以，如PC網卡、Switch Hub使用實體層標準，將電氣訊號洪泛(flooding)到所有其他的埠，屬於第一層設備 Hub沒有訊框、IP等概念 兩個設備同時輸入訊號，到同一台時，電氣訊號會碰撞，而成亂碼 為了避免這種狀況，所以Hub採用半雙工 Image 12 - 2-8 也就是A要傳送資料給Hub時， B就注意到Hub正在接收某處的訊框，不能傳給Hub 此演算法稱為CSMA/CD(載波感應多重存取/碰撞偵測) 但也可能因為兩個節點正好同一瞬間，檢查一個進來的訊框， 雙方都被判定沒有其他節點正在發送，於是發生碰撞 此時，發送端要監聽到碰撞是否發生，並送出人為的干擾信號， 告訴所有節點碰撞發生，大家各自挑一個隨機的時間再送一次 此演算法屬於碰撞偵測與復原 Switch屬於第二層設備，會檢查資料鏈路的標頭標尾 Switch會檢查MAC位置，如果碰撞，會將訊框放置佇列 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/3-廣域網路的原理.html":{"url":"md/96-Network/1-CCNA/3-廣域網路的原理.html","title":"廣域網路的原理","keywords":"","body":"廣域網路的原理 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 中文 英文簡稱 英文全稱 服務供應商 SP Service Provider 用戶端設備 CPE Customer Premises Equipment 局端 CO Central Offices 用戶端設備 CPE Customer Premises Equipment 通道服務單元 CSU Channel Service Unit 資料服務單元 DSU Data Service Unit 資料終端設備 DTE Data Terminal Equipment 資料通訊設備 DCE Data communications Equipment 高階資料鏈結控制協定 HDLC High-Level Data Link Control 點對點通訊協定 PPP Point-to-Point Protocol 網路連接點 POP Point Of Presence 乙太網路仿真 Ethernet emulation 乙太網路多重協定標籤交換 EoMPLS Ethernet over MPLS 數位用戶電路 DSL Digital Subscriber Line 網際網路服務供應商 ISP Internet Service Providers 公眾交換電話網路 PSTN Public Switched Telephone Network DSL存取多工器 DSLAM DSL Access Multiplexer WAN的簡介 WAN和LAN都符合OSI的第一、第二層標準 WAN的安裝需要穿過他人房產，而我們無權這麼做 故此由電信公司建構後出租 WAN分為專線與光纖乙太網路標準之長距離電纜 專線WAN 專線一詞，指的是使用專線的公司本身並不擁有這條線路 是服務供應商(SP)出租提供 專線完全為客戶著想，是高品質及客戶私有的 美國專線上的標準速度為256Kbps 缺點是成本較高 & 較長的等待佈線時間 圖中彎曲線路，視同省略細節 Image 1 - 3-2-1 專線的實體細節 專線服務是使用全雙工的邏輯，在預定速度傳遞 實際上，使用了兩對纜線，兩個方向個使用一對，概念上是全雙工 Image 2 - 3-2-2 T1是專線的一種特殊類型， 傳送速率每秒1.544Mbps 專線的佈線 專線的佈線，是將它們的設備設置在稱為局端(CO)的建築物內 Image 3 - 3-2-3 期望有一天能租給建築物內的人們 每個地點都會有用戶端設備(CPE) 所謂CPE包含路由器、序列介面卡、CSU/DSU Image 4 - 3-2-4 序列介面卡有點像乙太網卡，裝在路由器內 序列介面卡無法直接連接到電信公司的四芯電纜(通常是RJ-48接頭，與RJ-45接頭大小外型一樣) 序列介面卡需先透過短序列纜線接到稱為CSU/DSU的功能上，再透過CSU/DSU去接到電信公司的四芯電纜 短序列纜線一端是序列介面卡接頭，一端是CSU/DSU接頭 CSU/DSU可以被整合到序列介面卡內，也可以脫離路由器，成為外部設備 用戶只能從電信公司提供的速率清單中擇一，不能任意指定速率 短序列纜線有兩條，在路由器A & CSU/DSU之間一條，另一條在路由器B & CSU/DSU之間，兩條分別有不同的名稱 短序列纜線有公接頭的叫DTE，是平行線 短序列纜線有母接頭的叫DCE，是交叉線 一端是DTE，另一端就是DCE 兩條可以直接相接 最後，為了使線路正常，DCE接的那邊，需要有一個通常是由CSU/DSU提供的功能，稱為時脈 時脈是用來告訴路由器，何時發送一個位元，進而轉成電氣訊號 時脈也可以由路由器的序列介面提供，需要透過設定clock rate命令 Image 5 - 3-2-5 專線的資料鏈路細節 以上算是講實體層，現在來談資料鏈路層 最常見於此的協定有HDLC與PPP 對於點對點的專線來說，HDLC的位置欄位並無作用 HDLC的位置欄位是由於電信公司發展了多點電路，因此可能有超過一個以上的目的地 HDLC類似乙太網路的其他欄位 Image 6 - 3-2-6 HDLC是ISO的標準，同OSI組織，而HDLC卻沒有Type欄位(辨別此封包是IPv4 or IPv6) 於是Cisco路由器使用Cisco專屬的HDLC，自行添加了Type欄位 Image 7 - 3-2-7 下圖為TCP/IP的網路層的視角(相當無感LAN與WAN) Image 8 - 3-2-8 下圖為資料鏈結層的視角(需要正確的封裝/解封裝) Image 9 - 3-2-9 乙太網路做為WAN 1000BASE-LX標準的單模光纖電纜(可支援5KM) 1000BASE-ZX標準(可支援70KM) 乙太網路離開你家以後，連接到SP附近一些網路連接點(POP) 乙太網路WAN的服務有兩個名稱，乙太網路仿真 & 乙太網路多重協定標籤交換(EoMPLS) EoMPLS是一種能夠備用在SP內部雲的技術 提供兩個客戶設備之間的點對點連線 於資料鏈結層來看，圖中第二步驟解封裝後，依然會捨棄標頭標尾 Image 10 - 3-3 新加上的標頭標尾，其位置改為R1 to R2 存取Internet Internet是一個大型的WAN Internet核心由網際網路服務供應商(ISP)營運 ISP彼此互相合作建立網狀 Image 11 - 3-4-1 每一條鏈路稱為Internet存取鏈路 企業傾向用專線連WAN 家庭常用的DSL已經安裝在家庭的類比電話線路，cable則使用CCTV電纜 Image 12 - 3-4-2 數位用戶電路(DSL) DSL只提供務住宅到電信公司網路這段的實體電路 一般電話線透過RJ-11接頭(比RJ-45瘦小)，從電信商CO連到家庭的護牆版 透過電信交換機的一個連接埠，轉送到公眾交換電話網路(PSTN) Image 13 - 3-4-3 家中需要添增DSL數據機連接到一個空電話插座 電信公司CO需要添增DSL存取多工器(DSLAM)，將語音和路由器資料分離 Image 14 - 3-4-4 DSL支援不對稱的速度。(下載快，上傳慢) 有線電視網路 同DSL，支援不對稱的速度 有線電視公司需要將資料和視訊分開 Image 15 - 3-4-5 通常Cable比較快，但DSL比較便宜 兩者都提供Always on的服務，使連線無須採取某些行動 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/4-IPv4定址及路由的基本原理.html":{"url":"md/96-Network/1-CCNA/4-IPv4定址及路由的基本原理.html","title":"IPv4定址及路由的基本原理","keywords":"","body":"IPv4定址及路由的基本原理 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 中文 英文簡稱 英文全稱 路徑選擇 Path Selection 預設閘道 Default gateway or Default router 位置解析協定 ARP Address Resolution Protocol 網域名稱系統 DNS Domain Name System Ping Packet Internet Groper 網際網路控制訊息協定 ICMP Internet Control Message Protocol 網路層功能概述 IP定址：就像是郵遞區號的命名規則。 IP路由：轉送IP封包的過程，就像是郵差透過IP定址送到目的地。 IP遶送通訊協定：一個告訴一個當方式，來動態學習IP位址。 遶送的開始 路由就是路徑選擇的過程。 發送端將發現目的地IP與自己不在同一個LAN上。 於是將IP封包送至預設閘道(Default gateway or Default router)。 鏈結層遶送 每一台router都會有它的IP路由表。 IP路由表就像是高速公路上的路標，LAN或WAN線路相當於道路。 IP路由表中，紀錄如何到達每個IP網路，或IP子網路的路徑。 網路層表明遶送的過程，各router必須適當的封裝與解封裝。 為了封裝新的標頭標尾，需要透過位置解析協定(ARP)來決定標頭內所使用的MAC位置。 ARP會動態學習LAN中Host IP對應的MAC，如圖中R3發給PC2前，透過ARP取得PC2的MAC。 IP定址與IP遶送 IP就像是郵政區號，一層一層定下來。 除了來源IP位置、目的地IP位置以外，還有12 bytes的各項標頭，組成了共20 bytes的IPv4標頭。 Image 1 - 4-1 遶送通訊協定的方式，是Host端開始發送封包到Gateway，Gateway再發給下一位router。 此時下一位router便知道，透過某Gateway，可以到達某個IP子網路。 Gateway發送給下一位router的決定方式，也是透過遶送通訊協定得知的。 IPv4定址 根據IP數字開頭，分為A、B、C、D、E級。 ABC為一般單點傳播用，D為群播(multicast)位置、E為實驗位置。 Image 2 - 4-2-1 A級每個子網路有$2^{24}$個主機。 B級每個子網路有$2^{16}$個主機。 C級每個子網路有$2^{8}$個主機。 Image 3 - 4-2-2 Image 4 - 4-2-3 子網路切割是自行再將某一級網域進行細部切割。 A,B,C網域，除了開頭以外，其餘部分全0與全1(廣播位置)都不能使用。 IPv4路由 目的地如果是同一區網，則直接傳送，否則則交給預設閘道處理。 Image 5 - 4-3-1 預設閘道會先複製封包、檢查FCS，若有錯誤則丟棄封包。 確定沒有錯誤，則丟棄訊框標頭，再查表來分析路徑、封裝、傳送。 下圖使用OSPF遶送通訊協定，一層一層查找。 Image 6 - 4-3-2 IPv4遶送 動態學習，將每個子網路路徑加入路由表。 若到某個子網路有超過一條路徑，則將最佳路徑加入。 路徑失效則刪除。 若有新路徑可以取代失效的路徑，則加入。 取代速度要快，期間稱為收斂時間。 防止迴路。 Image 7 - 4-4 遶送通訊協定有很多種，但有共通點。 直連的子網路，加入路由表。 每一台都互相告訴鄰居自己的路由表(路徑更新)。 其他網路層功能 DNS DNS查詢的名稱也是世界通用協定。 並非某一台DNS知道全部名稱，而是由全世界的DNS互相學習、合作查詢。 Image 8 - 4-5-1 ARP 雖然知道IP的路徑，卻不知道下一位的MAC。 於是ARP用來動態學習LAN中另一台的MAC。 定義ARP Request與ARP Reply：如果這是你的IP，請回應我你的MAC位置。 Image 9 - 4-5-2 將結果記錄到ARP快取或ARP表中，逾期則清除。 透過arp -a來觀察。 Ping Ping使用ICMP協定，發送ICMP echo request到另一個IP。 若有收到，則回應ICMP echo reply。 僅用來測試，代表路徑通行。 Image 10 - 4-5-3 ICMP不依賴任何應用程式，只用了OSI第1、2、3層。 ICMP具有更多功能。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/5-TCP_IP傳輸層和應用層的基本原理.1.html":{"url":"md/96-Network/1-CCNA/5-TCP_IP傳輸層和應用層的基本原理.1.html","title":"TCP_IP傳輸層和應用層的基本原理.1","keywords":"","body":"TCP/IP傳輸層和應用層的基本原理 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 中文 英文簡稱 英文全稱 網路電話 VoIP Voice over IP 網路視訊 Video over IP 全球資訊網 WWW World Wide Web 專門管理網路設備的軟體使用 DNS Domain Name System 小型檔案傳輸協定 TFTP Trivial File Transfer Protocol 檔案傳輸協定 FTP File Transfer Protocol 簡單郵件傳輸通訊協定 SMTP Simple Mail Transfer Protocol 郵件通訊協定版本 POP3 Post Office Protocol version 3 動態埠號 dynamic port numbers 網路檔案系統 NFS Network File System 唯一資源定位器 URL Unifrom Resource Locator 傳輸層目標與功能要求 UDP只支援下表的第一項，TCP則支援全部。 Image 1 - 5-1-1 提供服務給應用程式。 TCP標頭如下。 Image 2 - 5-1-2 UDP的標頭如下。 Image 3 - 5-1-3 為了區別封包要餵給哪個應用程式，所以TCP/UDP都用了埠號。 Image 4 - 5-1-4 多工使用了通訊端(Socket)的概念。 Socket包含三個方面： IP 位置 傳輸通訊協定 埠號 埠號1024以下，是保留給公認應用程式使用。 埠號1024開始，稱為動態埠號(dynamic port numbers)。 一般公認的埠號都使用在伺服器上，其他埠號則使用在用戶端上。 Image 5 - 5-1-5 常見的TCP/IP應用程式有： WWW：網頁伺服器。 DNS：查詢名稱對應的IP。 SNMP：專門管理網路設備的軟體使用。 TFTP：小型檔案傳輸協定。 FTP：檔案傳輸協定。 SMTP：簡單郵件傳輸通訊協定。 POP3：郵件通訊協定版本。 常見的UDP應用程式有： 網路電話(VoIP*)& 網路視訊。 DNS的請求。 網路檔案系統(NFS)：使用應用層的復原。 三向交握使用了SYN flag & ACK flag & FIN flag。 大體來說，傳輸層通訊協定分為連接導向 & 非連接導向兩大類，用以表明是否交換資料前是否要先建立關係。 TCP/IP應用層 應用程式大略分三類型的服務品質(QoS)需求：批次處理、互動式、即時性。 QoS包含四個特徵 頻寬：每秒傳輸的位元量。 延遲：IP傳輸所需時間。 抖動：延遲產生的變動量。 耗損：到達前被丟棄的百分比。 Image 6 - 5-2 批次處理比較在意頻寬。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/6-使用交換器建置乙太區域網路.html":{"url":"md/96-Network/1-CCNA/6-使用交換器建置乙太區域網路.html","title":"使用交換器建置乙太區域網路","keywords":"","body":"CCNA - 6. 使用交換器建置乙太區域網路 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 中文 英文簡稱 英文全稱 碰撞領域 CD 內容定址記憶體or交換表 CAM Content Addressable Memory 泛洪 Flooding 擴展樹協定 STP 雙工不符 Duplex Mismatch Hub、橋接器、Switch Hub Hub會產生碰撞問題。 Image 1 - 6-1-1 Hub造成的半雙工+CSMA/CD的防碰撞原理，造成頻寬共用，且越多設備加入，碰撞機率越高。 橋接器 橋接器將網路切割成碰撞領域(CD)。 Image 2 - 6-1-2 橋接器將訊框留在一個Buffer中，直到確定目標CD空閒才送出。 橋接器將每個CD切割，使每個CD有自己的全部頻寬。 Switch Switch將每條線路視為單一CD。 Image 3 - 6-1-3 Switch支援速度協商，也就是不同乙太網路速度皆可透過Switch溝通(Hub無法)。 Switch收到訊框後，做以下三動作： 根據目的MAC位置，如果是廣播、群播or未知目的的單點傳播，則泛洪(flooding)出去。 若目的MAC位置與來源介面不同，則轉送，否則過濾掉(不轉送) 根據來源MAC位置，紀錄到自己的交換表中，並將閒置計時器設為0。 為了避免泛洪造成的第2層迴圈，所有Switch一同利用擴展樹協定(STP)，決定每個介面是否封鎖or轉送。 Image 4 - 6-1-4 泛洪：除了來源地以外，其他全部送一份訊框。同broadcast的意思。 閒置計時器：表中每一個項目都有一個count，起始值是0。 隨時間增加，計算這位客人多久沒有來消費了。 當表格滿出來的時候，將最久沒來的項目刪除。 封鎖：指介面不能轉送或收到訊框。適當封鎖介面可以使LAN區段僅存一條有效路徑。 Image 5 - 6-1-5 Switch內部有三種轉送的方式。由於現在鏈路速度夠快，因此採用第一種居多。 Image 6 - 6-1-6 乙太區網設計選擇 碰撞領域 網路介面卡(NIC)的集合。 其中一個NIC發送的訊框會與相同碰撞領域內的任一個其他NIC訊框發生碰撞。 Image 7 - 6-2-1 設備共用頻寬。 Hub造成100Mbps的鏈路，同一時間只有一台PC可以傳輸資料，因此LAN最大頻寬共100Mbps。 Switch使每一條線路自成一個碰撞領域，加上全雙工，使整體LAN的頻寬拉至100＊PC數量＊2 Mbps。 廣播領域 網路介面卡(NIC)的集合。 相同廣播領域內的其他NIC會收到一個NIC所發送的廣播訊框。 路由器不負則轉送乙太廣播訊框(忽略)，因此只有路由器會切割LAN的廣播領域。 交換器與橋接器都會泛洪廣播訊框。 Image 8 - 6-2-2 任一台廣播，會造成其他n-1台必須中斷CPU來處理廣播訊框。 因此，廣播領域不宜過大(n)。 何時使用hub & switch建置乙太網路是容易的。 何時使用router切割乙太網路的廣播領域是不容易的。 Image 9 - 6-2-3 VLAN LAN：由相同廣播領域內的設備所組成的。 Image 10 - 6-2-4 設定交換器，將不同介面的LAN，切割成不同的廣播領域(VLAN)。 Image 11 - 6-2-5 園區網路 存取層：直接存取host端，正常任兩台存取層Switch不互相轉送。 分送層：轉送存取層的訊框，每個存取層Switch至少使用1條上行鏈路(uplink)接到分送層。 核心層：大型園區網路用，提供非常高轉送速度，轉送分送層訊框。 Image 12 - 6-2-6 UTP支援100公尺，而雷射(數千公尺)或LED的光纖更遠。 光纖纜線的類型有分，便宜但短的多模&昂貴較遠的單模。 Image 13 - 6-2-7 自動協商 原本，鏈路兩端必須使用相同標準。 因此萬一新設備，不吃舊線路，則必須更新很多(Switch & Switch連接到的host)。 因此，IEEE 802.3u定義了自動協商，要求每個節點告知自己吃的協定清單。 每個節點選出最快速且最佳的雙工設定。 可以關閉自動協商，但最好兩端一起關或一起開。 一邊關，一邊開，則Cisco交換器會感應速度，且根據IEEE的預設值，速度10 or 100則半雙工，否則全雙工。 一般交換器會採用最慢速度(10Mbps)。 下圖F0/1顯示最壞結果：雙工不符(duplex mismatch)。 Image 14 - 6-2-8 PC1使用全雙工，但F0/1使用CSMA/CD+半雙工，收到訊框判定有機會碰撞，但實際上沒有，於是等待一段時間，重新傳送訊框。 鏈路有在運作，但效能不彰。 Hub不懂協商，所以採用IEEE的預設值(10Mbps&半雙工)。 Image 15 - 6-2-9 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/96-Network/1-CCNA/7-Cisco區域網路交換器.html":{"url":"md/96-Network/1-CCNA/7-Cisco區域網路交換器.html","title":"Cisco區域網路交換器","keywords":"","body":"Cisco區域網路交換器 tagsstart CCNA Network Cisco 通訊 Protocol 證照 tagsstop 名詞定義 Hub、橋接器、Switch © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/97-Server/1-Type/Readme.html":{"url":"md/97-Server/1-Type/Readme.html","title":"Type","keywords":"","body":"Type tagsstart Server 軟體 tagsstop Type Project Code: gitlab IM: mattermost Log : Sentry Config: Ansible Image: Docker register & Portus Space: owncloud User: openLDAD LoadBlance: Nginx,HAProxy,LVS mail: postfix,dovecot Project:Readmine Table:PowerBI VM:AWS,Azure © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/98-Swift/1-Basic/Readme.html":{"url":"md/98-Swift/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Swift Language tagsstop 變數 一般變數 var age:Int = 18 var height:Float = 173.5 var weight = 65.1 //不一定需要宣告型態,但最好宣告 let name:String = \"坤\" //final var boolTrue:Bool = true var boolFalse:Bool = false print(\"年紀\\(age)歲,身高\\(height)公分,\"+\"體重\\(weight)公斤\") print(\"boolTrue＝\\(boolTrue),boolFalse=\\(boolFalse)\") 年紀20歲,身高160.0公分,體重50.0公斤 boolTrue＝true,boolFalse=false Byte let minIntU8:UInt8 = UInt8.min //byte let maxIntU8:UInt8 = UInt8.max //byte print(\"最小值＝\\(minIntU8)歲,最大值=\\(maxIntU8)\") 最小值＝0歲,最大值=255 強制轉型 var dValue:Double = 100.999 var fValue:Float = Float(dValue) //必須強制轉型 var iValue:Int = Int(fValue) print(\"Double＝\\(dValue),Float=\\(fValue),Int=\\(iValue)\") Double＝100.999,Float=100.999,Int=100 空變數 var number:Int? //未定義內容的空間,直接印出會變成nil //效果等同宣告指標卻還沒分配空間 number = 100 print(\"number＝\\(number)\") number＝Optional(100) assert assert(boolFalse, \"發生錯誤\") //斷程式專用,防惡意軟體 不常拿來debug 集合 同型態集合-[] var apple:[String] = [\"iPad\",\"iPhone\"] let newProduct:[String] = [\"ipod\",\"Mac\"] print(\"Apple目前產品有\\(apple[0])與\\(apple[1])\") apple += newProduct apple.append(\"iWatch\") apple += [\"Mac Book Pro\"] apple.insert( \"magic mouse\", at: 2 ) //特定格式 let r_1 = apple.remove(at: 2) let r_2 = apple.removeLast() for (index,product) in apple.enumerated() { //陣列 列舉法 print(\"目前第\\(index)項產品是\\(product)\") } apple.removeAll(keepingCapacity: true) if apple.isEmpty { print(\"clean\") } var htc:[String] = [String]() htc.append(\"one\") htc += [String](repeating: \"尚未推出\", count: 3) for (index,product) in htc.enumerated() { print(\"目前第\\(index)項產品是\\(product)\") } Apple目前產品有iPad與iPhone 目前第0項產品是iPad 目前第1項產品是iPhone 目前第2項產品是ipod 目前第3項產品是Mac 目前第4項產品是iWatch clean 目前第0項產品是one 目前第1項產品是尚未推出 目前第2項產品是尚未推出 目前第3項產品是尚未推出 異型態集合-() var product = (\"iPad wifi\",19999) var (device,price) = product //集合與命名 var (device_2,_) = product //集合與命名 print(\"\\(product.0)售價,\\(product.1)元\") print(\"\\(device)售價,\\(price)元\") print(\"\\(device_2)售價\") var product_2 = (device:\"iPad wifi\",price:19999,capacity:500) print(\"\\(product_2.0)售價,\\(product_2.1)元,\\(product_2.2)G\") print(\"\\(product_2.device)售價,\\(product_2.price)元,\\(product_2.capacity)G\") iPad wifi售價,19999元 iPad wifi售價,19999元 iPad wifi售價 iPad wifi售價,19999元,500G iPad wifi售價,19999元,500G Array var sony:Array = Array(repeating: \"即將推出\", count: 4) //Array集合 字串版型 sony[0 ... 2 ] = [\"z1\",\"z2\",\"z3\"] //加入元素 for (index,product) in sony.enumerated() { print(\"目前第\\(index)項產品是\\(product)\") } 目前第0項產品是z1 目前第1項產品是z2 目前第2項產品是z3 目前第3項產品是即將推出 NSArray var acer:NSArray = NSArray(objects: \"a_1\",\"a_2\",88) //槓Object C的Array,此宣告為final值,也就是內容不能替換 for (index,product) in acer.enumerated() { print(\"目前第\\(index)項產品是\\(product)\") } 目前第0項產品是a_1 目前第1項產品是a_2 目前第2項產品是88 NSMutableArray var mi:NSMutableArray = NSMutableArray() mi.add(\"紅米機\") print(\"\\(mi.object(at: 0))\") var ary = [[4,7,6,9],[1,2,3],[4,5,6,7,8]] for i:Int in 0 .. 紅米機 4 7 6 9 1 2 3 4 5 6 7 8 4 7 6 9 1 2 3 4 5 6 7 8 Dictionary var apple:Dictionary = [\"iPhone\":26000,\"iPad\":18000] apple[\"iWatch\"] = 16800 for element in apple.keys{ print(\"商品\\(element) = \\(apple[element])\") } var max:Int = 0 for element in apple.values{ if max = [ \"賀振坤\" : [\"吳國隆\",\"王大維\"] , \"王勇傑\" : [\"賀振坤\",\"王大維\"] ] var temp:[String] = people[\"賀振坤\"]! people[\"賀振坤\"] = people[\"王勇傑\"] people[\"王勇傑\"] = temp for (person,friends) in people{ print(\"我的名字叫做\\(person)\") for friend in friends { print(\"我的朋友有\\(friend)\\t\", terminator: \"\") } print(\"\") } 商品iPad = Optional(18000) 商品iWatch = Optional(16800) 商品iPhone = Optional(26000) 最貴為26000元 我的名字叫做賀振坤 我的朋友有賀振坤 我的朋友有王大維 我的名字叫做王勇傑 我的朋友有吳國隆 我的朋友有王大維 迴圈 & 邏輯判斷 For each var sum:Int = 0 for i in (0 .. 4 4 Switch var ID:Int = 3 switch ID { case 1: print(\"1\") //case 若進入不需要加入break case 2: print(\"2\") case 3 ... 10: print(\"3~10\") fallthrough //穿越到下一個case繼續 case 11 ... 20: print(\"11~20\") default: break //default必須存在且有功能,若無功能則加入break } var say:String = \"食べます\" var chinese:String? switch say { case \"Eat\",\"食べます\": chinese = \"吃飯\" case \"Hello\",\"こんにちは\": chinese = \"問安\" default: break } if chinese == nil { print(\"?\") } else { print(\"\\(chinese)\") } 3~10 11~20 Optional(\"吃飯\") Function Function & Function variable func toAdd( _ num1:Int , num2:Int ) -> Int{ return num1 + num2 } func toSub( _ num1:Int , num2:Int ) -> Int{ return num1 - num2 } func countAddAndSub( _ a:Int , b:Int , fun_add:(Int,Int) -> Int , fun_sub:(Int,Int) -> Int ) -> (Int,Int) { return ( fun_add(a,b) , fun_sub(a,b) ) } var a = 20 , b = 10 //var mathFuncAdd:(Int,Int)->Int = toAdd //var mathFuncSub:(Int,Int)->Int = toSub var result = countAddAndSub( a , b:b , fun_add:toAdd , fun_sub:toSub) //result = countAddAndSub( a , b , mathFuncAdd , mathFuncSub) print(\"add = \\(result.0),sub = \\(result.1)\") add = 30,sub = 10 Function local variable scope func getNewP (_ money:Int) -> () -> Int{ var salary:Int = 0 func workADay() -> Int { salary += money return salary } return workADay } let emp_1 = getNewP(700), emp_2 = getNewP(800) , emp_3 = getNewP(900) //由於emp_1為workADay()的實體,而workADay()實體緊抓著屬於自己的salary,故不得釋放salary的memory for i in 1 ... 2 { print(\"第\\(i)天員工1的薪水 ＝ \\(emp_1()) 元\") print(\"第\\(i)天員工2的薪水 ＝ \\(emp_2()) 元\") print(\"第\\(i)天員工3的薪水 ＝ \\(emp_3()) 元\") } 第1天員工1的薪水 ＝ 700 元 第1天員工2的薪水 ＝ 800 元 第1天員工3的薪水 ＝ 900 元 第2天員工1的薪水 ＝ 1400 元 第2天員工2的薪水 ＝ 1600 元 第2天員工3的薪水 ＝ 1800 元 Named Function & Closure func a() -> Void { print(\"這是Ａ函式\") } func b() -> Void { print(\"這是B函式\") } func countDown ( _ start:Int , timesupClosure:() -> Void ) -> Void{ for i in (0 ... start).reversed() { if( i > 0) { print(\"倒數\\(i)秒\") } else { timesupClosure() } } } countDown(10, timesupClosure:a) countDown(10, timesupClosure:b) countDown(10, timesupClosure:{ print(\"這是Ｃ函式\") //臨時函數如果沒有參數,沒有回傳,不需要多餘的in } ) 倒數3秒 倒數2秒 倒數1秒 這是Ａ函式 倒數3秒 倒數2秒 倒數1秒 這是B函式 倒數3秒 倒數2秒 倒數1秒 這是Ｃ函式 Lambda & Closure func babyName (_ secName:String ,firNameFunc:(String) -> String) -> Void { print(\"寶寶的名字叫\\(firNameFunc(secName))\") } //「臨時函式」的宣告規矩 一切宣告完以後要加「in」 爾後的區塊才是「函式本體」 babyName(\"賀\",firNameFunc: {(secName : String) -> String in return secName + \"振坤\" } ) //「臨時函式」若當「參數」,可寫在「呼叫此臨時函式」的「後方」 babyName(\"賀\") {(secName : String) -> String in return secName + \"振坤\" } //「臨時函式」若當「參數」,此「臨時函式」可「使用呼叫者的參數」 babyName(\"賀\"){return $0 + \"振坤\"} //「臨時函式」若當「參數」,則可直接將return的結果打入{}內,當作呼叫者的參數 // 若此寫法的「臨時函式」回傳不帶參數,會認為此「臨時函式」是不需要輸入參數的函式 babyName(\"賀\"){$0 + \"振坤\"} 寶寶的名字叫賀振坤 寶寶的名字叫賀振坤 寶寶的名字叫賀振坤 寶寶的名字叫賀振坤 Objective-C Bridging Header Project -> Build Settings -> Objective-C Bridging Header Swift_4-Bridging-Header.h void getImput(int *output); file.c #include #include void getImput(int *output){ scanf(\"%i\",output); } main.swift var num:CInt = 0; print(\"請輸入任意整數\") getImput(&num); if Int(num) % 2 == 1 { print(\"奇數\") } else { print(\"偶數\") } 請輸入任意整數 2 偶數 Enum enum Language { case java case swift case objC case actionScript case other } var tool:Language = .java switch tool { case .java: print(\"此為Java\") case .swift: print(\"此為Swift\") case .objC: print(\"此為objC\") case .actionScript: print(\"此為ActionScript\") default: print(\"此語言為其他語言\") } enum Role{ case status(Float,Float,Float) case name (String) } var roleStatus:Role = Role.status(1000, 599, 200) var roleName:Role = Role.name(\"zhenkun\") var role = roleStatus switch role { case .status(var hp,var sp,var mp) : hp -= 200 print(\"Hp:\\(hp) Sp:\\(sp) Mp:\\(mp)\") case let .name(username): print(\"\\(username)\") } enum Classroom : Int { case mary = 3 , ada , fred = 6 , eva , cathy , diana } if let value = Classroom(rawValue: 7){ print(\"\\(value)\") print(\"\\(value.rawValue)\") } 此為Java Hp:800.0 Sp:599.0 Mp:200.0 eva 7 struct struct Ball { var x:Int = 0 var y:Int = 0 var z:Int = 0 var name:String = \"\" } var b1:Ball = Ball() var b2:Ball = Ball(x: 1, y: 2, z: 3, name: \"blueBall\") b1 = b2 b1.x = 100 print(\"\\(b2.x)\") struct Point { var X:Float = 0.0 var Y:Float = 0.0 } struct Size { var w:Float = 0.0 var l:Float = 0.0 } struct Rect { var origin:Point = Point() var size:Size = Size() var center:Point{ //Swift的struct有能力將「屬性」與「屬性」之間建立關係 利用「get」&「set」 get { let centerX = origin.X + (size.w/2) let centerY = origin.Y + (size.l/2) return Point(X:centerX ,Y:centerY) } set (newCenter) { self.origin.X = newCenter.X - (size.w/2) self.origin.Y = newCenter.Y - (size.l/2) } } var area:Float{ //只有get沒有set return size.w * size.l } } var rect:Rect = Rect(origin: Point(X: 20, Y: 30), size: Size(w: 50, l: 50)) //測試get rect.center = Point(X: 60, Y: 60) //測試set rect.center.X = 70 //set進階版 此行等於rect.center = Point(X: 70, Y: 不變) //rect.area = 0.0 //get only的屬性沒有辦法set print(\"原點：(\\(rect.origin.X),\\(rect.origin.Y))\\n範圍：(\\(rect.size.w),\\(rect.size.l))\\n中心：(\\(rect.center.X),\\(rect.center.Y))\\n面積：\\(rect.area)\") struct ScoreRecord{ var scroe:Int = 2{ //若「屬性」與其他「屬性」沒有關聯,則有個多餘的方式,willSet＆didSet 幾乎沒用 且didSet中有特定的關鍵字:oldValue willSet(newScore){ print(\"傳入新分數\\(newScore)\") } didSet { print(scroe >= oldValue ? \"進步了\\(scroe - oldValue)分\" : \"退步了\\(oldValue - scroe)分\") //didSet屬性設定中的特定關鍵字:oldValue } } } var score:ScoreRecord = ScoreRecord() score.scroe = 10 struct RoleStruct { var name:String? init(){ name = \"坤\" print(\"初始\") } } var roleA:RoleStruct = RoleStruct() print(\"\\(roleA.name)\") 1 原點：(45.0,35.0) 範圍：(50.0,50.0) 中心：(70.0,60.0) 面積：2500.0 傳入新分數10 進步了8分 初始 Optional(\"坤\") Class 建構&解構&Lazy struct Position { var X:Float = 0.0 var Y:Float = 0.0 var Z:Float = 0.0 } class Cube { var m_pos:Position = Position() var m_l:Float var m_w:Float var m_h:Float init (p:Position , l:Float , w:Float , h:Float){ m_pos = p m_l = l m_w = w m_h = h } } var cubeA:Cube = Cube(p: Position(), l: 200.0 , w: 300.0 , h: 1000.0) //var cubeB:Cube = Cube() //error 建構子被覆蓋 print(\"體積：\\(cubeA.m_l * cubeA.m_w * cubeA.m_h)\") class DataImporter{ var path:String = \"path.txt\" } class DataManager{ lazy var dataImp:DataImporter = DataImporter() //lazy:物件尚不用到時,不建立實體 var data:[String] = [String]() } let dataManager:DataManager = DataManager() dataManager.data.append(\"Data_1\") dataManager.data.append(\"Data_2\") print(\"將資料存到\\(dataManager.dataImp.path)裡面\") class Role{ var _name:String? var _hp:Int? var _mp:Int? init(){ _name = \"\" _hp = 0 _mp = 0 } init(name:String){ _name = name _hp = 0 _mp = 0 } init(name:String,hp:Int,mp:Int){ _name = name _hp = hp _mp = mp } deinit{ print(\"釋放\") } } var role:Role? = Role(name: \"zhenkun\", hp: 1, mp: 1) role = nil 體積：6e+07 將資料存到path.txt裡面 釋放 Private & Static private var acount:Int = 0 struct Classroom{ static var count:Int = 0 } class Student { var _name:String? //物件的靜態屬性：為了安全起見,限定不行使用static直接呼叫來使用或修改 規定要設定get & set,指向此檔案內的private成員做為共同存取 class var number:Int{ get{ return acount } set (newValue){ acount = newValue } } init(name:String){ _name = name print(\"\\(_name)走進教室\") Student.number += 1 //原始寫法,但也沒有特別屬於此物件所有 Classroom.count += 1 //較好的寫法,將所有靜態屬性放入struct 並在使用的時候呼叫就好 } deinit{ print(\"\\(_name)離開教室\") Student.number -= 1 Classroom.count -= 1 } } var s1:Student? = Student(name: \"Zhenkun\") var s2:Student? = Student(name: \"Alex\") print(\"教室\\(Classroom.count)人\") print(\"教室\\(Student.number)人\") s1 = nil s2 = nil print(\"教室\\(Classroom.count)人\") print(\"教室\\(Student.number)人\") Optional(\"Zhenkun\")走進教室 Optional(\"Alex\")走進教室 教室2人 教室2人 Optional(\"Zhenkun\")離開教室 Optional(\"Alex\")離開教室 教室0人 教室0人 繼承 class BaseObject { var l:Float = 0 , w:Float = 0 func getSize (_: Void) ->Float{ return l * w } } class Rect:BaseObject { } class Circle:BaseObject { var r:Float = 0.0 override func getSize (_: Void) ->Float{ return Float (pow( Double(r) , 2.0 ) * M_PI) } } class Cube:BaseObject { var h:Float = 0.0 override func getSize (_: Void) ->Float{ return super.getSize() * h } } var rect:Rect = Rect() var circle:Circle = Circle() var cube:Cube = Cube() rect.l = 10 rect.w = 20 print(\"\\(rect.getSize())\") circle.r = 10 print(\"\\(circle.getSize())\") cube.l = 10 cube.w = 20 cube.h = 30 print(\"\\(cube.getSize())\") 200.0 314.159 6000.0 Protocol 實作 protocol Rect { func getPerimeter(_ w:Int ,l:Int) -> Int func getArea(_ w:Int , l:Int) -> Int } protocol Circle { func getPerimeter(_ r:Float) -> Float func getArea(_ r:Float) -> Float } class Object: Rect,Circle{ //不能多重繼承,但是可以多重實作.若要繼承,父類別需要寫在冒號後的第一個 func getPerimeter(_ w:Int ,l:Int) -> Int { return (l + w) * 2 } func getArea(_ w:Int ,l:Int) -> Int { return l * w } func getPerimeter(_ r:Float) -> Float { return r * r * Float(M_PI) } func getArea(_ r:Float) -> Float { return 2 * r * Float(M_PI) } } var obj:Object = Object() print(\"圓面積：\\(obj.getArea(3)),圓周長：\\(obj.getPerimeter(3))\") print(\"Rect面積：\\(obj.getArea(3, l: 4)),Rect周長：\\(obj.getPerimeter(3,l: 4))\") //參數第一個不需要形容意義(init 例外) 圓面積：18.8496,圓周長：28.2743 Rect面積：12,Rect周長：14 Delegate BankDelegate.swift protocol BankDelegate { func showBroken() -> Void func showBalance(_ money:Int) -> Void } Bank.swift class Bank { var _money:Int = 0 let _bankD:BankDelegate? init (money:Int , bankD:BankDelegate){ _bankD = bankD _money = money } func withDrawal(_ value:Int) -> Void{ if _money >= value { _money -= value _bankD!.showBalance(_money) } else { _bankD!.showBroken() } } func deposit(_ value:Int) -> Void{ _money += value _bankD!.showBalance(_money) } } main.swift class Main:BankDelegate { init(_: Void){ let bank:Bank = Bank(money: 1000, bankD: self) bank.withDrawal(300) bank.deposit(200) bank.withDrawal(1000) } func showBroken() -> Void{ print(\"你已經破產了\") } func showBalance(_ money:Int) -> Void{ print(\"你還剩下\\(money)元\") } } var main:Main = Main() 你還剩下700元 你還剩下900元 你已經破產了 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/98-Swift/2-iOS/Readme.html":{"url":"md/98-Swift/2-iOS/Readme.html","title":"I OS","keywords":"","body":"iOS tagsstart Swift Language iOS Framework tagsstop cocoapods 它是將所有的依賴庫都放到一個名為Pods資料夾中，然後讓專案依賴Pods資料夾，如此，源碼管理工作都從專案移到了Pods資料夾中 Pods資料夾最終會編譯成一個名為libPods.a的文件，專案只需要依賴這個.a檔即可 對於資源文件，CocoaPods提供了一個名為Pods-resources.sh的bash腳本，該腳本在每次專案編譯的時候都會執行，將第三方庫的各種資源文件複製到目標目錄中 CocoaPods通過一個名為Pods.xcconfig檔來在編譯時設置所有的依賴和參數 Setting up CocoaPods master repo 这并不是卡住，而是一直在安装，速度比较慢是正常的，等待就好，如果你想知道进度，那么进行如下操作 新建一个终端窗口 cd ~/.cocoapods/ 再输入du -sh * 隔几分钟查看下下载量在增加就可以了。不要着急，整个文件大概要400M+貌似，急不来的。 Download # Xcode 7 + 8 $ sudo gem install cocoapods --pre # Xcode 7 sudo gem install activesupport -v 4.2.6 sudo gem install cocoapods Podfile # Uncomment the next line to define a global platform for your project # platform :ios, '9.0' target 'listenPro' do # Comment the next line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! # Pods for listenPro pod 'EliteFramework' pod 'Google/Analytics' pod 'FBSDKCoreKit' pod 'FBSDKLoginKit' pod 'FBSDKShareKit' end Install pod install Xcode 7 sudo gem install activesupport -v 4.2.6 sudo gem install cocoapods AppDelegate App生命週期 import UIKit @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { //最重要的兩個元件 //UIApplicationDelegate 內部設定了appa生命週期觸發的函式 var window: UIWindow? //root視窗物件,不包含container //啟動瞬間觸發 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { return true } //即將終止活動 觸發 func applicationWillResignActive(_ application: UIApplication) { print(\"applicationWillResignActive\"); } //進入後台完成 觸發 func applicationDidEnterBackground(_ application: UIApplication) { print(\"applicationDid Enter Background\"); } //即將進入前端 func applicationWillEnterForeground(_ application: UIApplication) { print(\"application Will Enter Foreground\"); } //app開始活動觸發 func applicationDidBecomeActive(_ application: UIApplication) { print(\"application Did Become Active\"); } //app釋放的瞬間觸發 func applicationWillTerminate(_ application: UIApplication) { print(\"application Will Terminate\"); } } UIWindow var window: UIWindow? //啟動瞬間觸發 func application(_ application: UIApplication,didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { // Initialize window window = UIWindow(frame: UIScreen.main.bounds) // Background color of window window?.backgroundColor = UIColor.white // Set root view controller window?.rootViewController = ViewController() // Show window window?.makeKeyAndVisible() return true } UIView view.removeFromSuperview() view.backgroundColor = UIColor.green self.addSubview(view) view.frame.size = CGSize(width: 100, height: 100) //設置size view.center = CGPoint(x: frame.size.width/2, y: frame.size.height/2) //設置View的「中心點」 self.insertSubview(viewD, aboveSubview: viewC) self.exchangeSubviewAtIndex(2, withSubviewAtIndex: 3) ballView.layer.masksToBounds = true //不去繪製超出遮罩外的範圍 ballView.layer.cornerRadius = w/2 `UIView.beginAnimations(\"MoveGroupAni\", context: nil) UIView.setAnimationDelay(0.1) //從這行到UIView.commitAnimations()之間的繪圖動作,會在0.1秒內逐漸完成,並命名這串動作為MoveGroupAni //若時間還沒到,卻引發了下一個Animations,則動作會立刻完成,以便銜接下一個Animations ballView.center = location UIView.commitAnimations()` self.isUserInteractionEnabled = true //攔截事件,不穿透 Basic Property MainView.swift class MainView: UIView { //CGRect內放著((x,y),(w,h))也就是(原點,寬高) 值為CGFloat,與Float不同的地方只是一個有繪製輸出 override init(frame: CGRect) { super.init(frame: frame) self.backgroundColor = UIColor.brown//透明色UIColor.clearColor let w:CGFloat = 100 let h:CGFloat = 100 //left top var view:UIView = UIView(frame:CGRect(x: 0, y: 0, width: w, height: h) ) view.backgroundColor = UIColor.red self.addSubview(view) //right top view = UIView(frame:CGRect(x: self.frame.size.width - w, y: 0, width: w, height: h) ) view.backgroundColor = UIColor.blue self.addSubview(view) //left button view = UIView(frame:CGRect(x: 0, y: self.frame.size.height - h, width: w, height: h) ) view.backgroundColor = UIColor.green self.addSubview(view) //right button view = UIView(frame:CGRect(x: self.frame.size.width - w, y: self.frame.size.height - h, width: w, height: h) ) view.backgroundColor = UIColor.purple self.addSubview(view) //center view = UIView(frame:CGRect.zero) //空的矩形 view.frame.size = CGSize(width: 100, height: 100) //設置size view.backgroundColor = UIColor.gray view.center = CGPoint(x: frame.size.width/2, y: frame.size.height/2) //設置View的「中心點」 self.addSubview(view) view.removeFromSuperview()//移除需要子物件自己離開 } required init(coder aDecoder: NSCoder) { //初始化失敗時呼叫 fatalError(\"init(coder:) has not been implemented\") } } AppDelegate.swift var mainView: MainView? //啟動瞬間觸發 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { // Initialize window window = UIWindow(frame: UIScreen.main.bounds) // Background color of window window?.backgroundColor = UIColor.white // Set root view controller window?.rootViewController = ViewController() mainView = MainView(frame: window!.frame) window?.addSubview(mainView!) Subview Layer self.backgroundColor = UIColor.brown//透明色UIColor.clearColor let viewH:CGFloat = 300 //red View let viewA = UIView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: viewH)) viewA.backgroundColor = UIColor.red self.addSubview(viewA) //blue View let viewB = UIView(frame: CGRect(x: 0, y: viewH/2, width: self.frame.size.width, height: viewH)) viewB.backgroundColor = UIColor.blue self.addSubview(viewB) //black View let viewC = UIView(frame: CGRect(x: 0, y: viewH, width: self.frame.size.width, height: viewH)) viewC.backgroundColor = UIColor.black self.insertSubview(viewC, aboveSubview: viewA) //Subview //green View let viewD = UIView(frame: CGRect(x: 0, y: viewH, width: self.frame.size.width, height: viewH/2+100)) viewD.backgroundColor = UIColor.green self.insertSubview(viewD, aboveSubview: viewC) //Subview //self.exchangeSubviewAtIndex(2, withSubviewAtIndex: 3) //交換子view層級 ViewController 每個ViewController有一個view作為這次要控制的主view Touch event touchesBegan touchesMoved touchesEnded let t:UITouch = touch as! UITouch if(t.tapCount == 2) ViewController.swift override func touchesBegan(_ touches: Set, with event: UIEvent?) { for subView in self.view.subviews { subView.touchesBegan(touches, with: event) } } MainView.swift override func touchesBegan(_ touches: Set, with event: UIEvent?) { let touche:UITouch = touches.first! as UITouch //取出touch相對於某View的相對位置 let location:CGPoint = touche.location(in: self) let view = UIView(frame: CGRect(x: location.x, y: location.y, width: 30, height: 30)) view.backgroundColor = UIColor(red: CGFloat(arc4random()%256)/255, green: CGFloat(arc4random()%256)/255, blue: CGFloat(arc4random()%256)/255, alpha: CGFloat(arc4random()%100)/100) //RGB Alpha的value從0-255壓縮到0~1之間的浮點數 self.addSubview(view) ary.append(view) } override func touchesEnded(_ touches: Set, with event: UIEvent?) { } Draw override func draw(_ rect: CGRect) { let drawWidth:CGFloat = 10 m_context = UIGraphicsGetCurrentContext() //畫筆文本 setDrawWidth(drawWidth) //CGContextSet... setContentColer(UIColor.red) //CGCGContextSet... var ori:CGPoint = CGPoint(x: 0, y: 0) let tar:CGPoint = CGPoint(x: frame.size.width, y: frame.size.height) drawLine(ori, tar: tar) //CGContext Set..Move...Add...Path setContentColer(UIColor.blue) //CGCGContextSet... let r:CGFloat = 50 let center:CGPoint = CGPoint(x: frame.size.width - r - drawWidth, y: 0 + r + drawWidth) drawCircle(center, r: r ,isFill: false) //CGContext Set..Move...Add...Path setContentColer(UIColor.green) //CGCGContextSet... let size:CGSize = CGSize(width: 100, height: 100) ori = CGPoint(x: 0 , y: frame.size.height - size.height) drawTriangleRect(ori, rect: size, isFill: true) setContentColer(UIColor.yellow) //CGCGContextSet... let p1:CGPoint = CGPoint(x: 0, y: frame.size.height/2 ) let p2:CGPoint = CGPoint(x: frame.size.width, y: frame.size.height/2 ) let p3:CGPoint = CGPoint(x: frame.size.width/2, y: frame.size.height/4 ) drawQuadCurve(p1, to: p2, curve: p3) } func setContentColer(_ col:UIColor){ //UIColor內含著CGColor,CGColor只是ＡＲＧＢ四個浮點數的集和 let components = col.cgColor.components m_context.setFillColor(red: (components?[0])!, green: (components?[1])!, blue: (components?[2])!, alpha: (components?[3])!) m_context.setStrokeColor(red: (components?[0])!, green: (components?[1])!, blue: (components?[2])!, alpha: (components?[3])!) } func setDrawWidth(_ w:CGFloat){ m_context.setLineWidth(w) //設定畫筆寬度 } func drawLine(_ ori:CGPoint,tar:CGPoint){ m_context.setLineCap(CGLineCap.round) //設定線條樣式,kCG系列是樣式 m_context.move(to: CGPoint(x: ori.x, y: ori.y)) //移動畫筆到某一點 m_context.addLine(to: CGPoint(x: tar.x, y: tar.y))//畫一條線 m_context.strokePath() //空心繪製路徑開始 } func drawCircle(_ center:CGPoint,r:CGFloat,isFill:Bool){ m_context.move(to: CGPoint(x: center.x - r, y: center.y - r)) m_context.addEllipse(in: CGRect(x: center.x - r, y: center.y - r, width: r * 2, height: r * 2)) isFill ? (m_context).fillPath() : m_context.strokePath() } func drawTriangleRect(_ ori:CGPoint, rect:CGSize,isFill:Bool){ m_context.move(to: CGPoint(x: ori.x + (rect.width / 2), y: ori.y)) //移動畫筆到某一點 m_context.addLine(to: CGPoint(x: ori.x, y: ori.y + rect.height)) //畫一條線 m_context.addLine(to: CGPoint(x: ori.x + rect.width, y: ori.y + rect.height)) //畫一條線 m_context.addLine(to: CGPoint(x: ori.x + (rect.width / 2), y: ori.y)) //畫一條線 isFill ? (m_context).fillPath() : m_context.strokePath() } func drawQuadCurve(_ ori:CGPoint, to:CGPoint , curve:CGPoint){ m_context.move(to: CGPoint(x: ori.x, y: ori.y)) //移動畫筆到某一點 m_context.addQuadCurve(to: CGPoint(x: to.x, y: to.y), control: CGPoint(x: curve.x, y: curve.y)) m_context.strokePath() } UINavigationController AppDelegate.swift var window: UIWindow! var navaController:UINavigationController! var mainVC:ViewController! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { window = UIWindow(frame: UIScreen.main.bounds) mainVC = ViewController() mainVC.refreshWithFrame(window.frame) navaController = UINavigationController() navaController.pushViewController(mainVC, animated: false) //當被掛載時,mainVC裡面的navigationController會指向他 window?.rootViewController = navaController window.makeKeyAndVisible() return true } ViewController.swift //window掛載navigationController後呈現時,才執行以下 //此時的self.navigationController與self.navigationItem才可抓到 override func viewDidLoad() { super.viewDidLoad() m_leftBtnItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.compose , target: self, action: #selector(ViewController.onSelectLeftAction(_:))) self.navigationItem.leftBarButtonItem = m_leftBtnItem m_rightBtnItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.done, target: self, action: #selector(ViewController.onSelectRightAction(_:))) self.navigationItem.rightBarButtonItem = m_rightBtnItem let titleView:UIImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 30, height: 30)) titleView.image = UIImage(named: \"icon\") self.navigationItem.titleView = titleView } //MARK: - CallBack & Lisetner //------------------------------- func onSelectRightAction(_ sender:UIBarButtonItem){ if popRightVC == nil { popRightVC = Pop2ViewController() } else if m_isAlready { self.navigationController?.pushViewController(popRightVC!, animated: true) } } UITabBarController ＆ 切頁動畫 TabBarViewController.swift import UIKit class TabBarViewController: UITabBarController,UITabBarControllerDelegate { override func viewDidLoad() { super.viewDidLoad() let controllers:[UIViewController] = [PageOneViewController(),PageTwoViewController(),PageThreeViewController()] self.viewControllers = controllers self.delegate = self //初始全部跑一遍回到原點,起始才會出現全部選項 for i in (0 .. Bool { let fromView: UIView = tabBarController.selectedViewController!.view let toView : UIView = viewController.view if fromView == toView { return false } UIView.transition(from: fromView, to: toView, duration: 0.3, options: UIViewAnimationOptions.transitionCrossDissolve) { (finished:Bool) in } return true } } PageOneViewController.swift override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.red let tabBarItem:UITabBarItem = UITabBarItem(title: \"第一頁\", image: UIImage(named: \"aa\"), selectedImage: UIImage(named: \"bb\")) self.tabBarItem = tabBarItem } override func viewWillAppear(_ animated: Bool) { let tabBarItem:UITabBarItem = UITabBarItem(title: \"第一頁\", image: UIImage(named: \"aa\"), selectedImage: UIImage(named: \"bb\")) self.tabBarItem = tabBarItem } 動畫 寫在tableView willDisplayCell或是tabBarController shouldSelect viewController之中 var rotation:CATransform3D; rotation = CATransform3DMakeRotation( CGFloat(90*M_PI/180) , 0.0, 0.7, 0.4); rotation.m34 = 1.0 / (-600); //2. Define the initial state (Before the animation) toView.layer.shadowColor = UIColor.black.cgColor toView.layer.shadowOffset = CGSize(width: 10, height: 10) toView.alpha = 0; toView.layer.transform = rotation; toView.layer.anchorPoint = CGPoint(x: 0, y: 0.5) //3. Define the final state (After the animation) and commit the animation UIView.beginAnimations(\"rotation\", context: nil) UIView.setAnimationDuration(0.8) toView.layer.transform = CATransform3DIdentity; toView.alpha = 1; toView.layer.shadowOffset = CGSize(width: 0, height: 0) UIView.commitAnimations() Image 1 - Animation © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-08-12 03:45:00 Docker Basic RTP RTP體系 RTCP RTP體系 RTSP RTP體系 Protocol RTP體系 TCP_IP與OSI網路模型 乙太區域網路基本觀念 廣域網路的原理 IPv4定址及路由的基本原理 TCP_IP傳輸層和應用層的基本原理.1 使用交換器建置乙太區域網路 Cisco區域網路交換器 valgrind Valgrind memory Valgrind Linux Basic Shell Makefile GDB Shell Shell Makefile Makefile Markdown Markdown GDB GDB mininet 什麼是 mininet 什麼是 SDN mininet 實戰 SDN 什麼是 SDN Namespace 簡介 什麼是Network Namespace 範例 Network namespace 什麼是Network Namespace 範例 Alljoyn Basic 架構說明 啟動流程 & 程式碼 Allplay Framework Basic 架構說明 啟動流程 & 程式碼 Allplay Tensor Flow I OS Gateway 架構說明 啟動流程 & 程式碼 Allplay Allplay Machine Learning Basic Tensor Flow Tensorflow Tensor Flow AIML AIM Lv 1 AIM Lv 2 AI AIM Lv 1 AIM Lv 2 IDE Xcode Eclipse Xcode Xcode Mac Xcode Software Xcode Eclipse Eclipse Eclipse Cross compile B Bfile Yocto B Bfile BBfile B Bfile Android Adb adb Adb Voice Voice Basic Hardware Voice 基本建置 在Openwrt上寫C++ Interface Arduino 基本建置 在Openwrt上寫C++ Yún 基本建置 在Openwrt上寫C++ Openwrt 在Openwrt上寫C++ c++ 在Openwrt上寫C++ Cross Compile 在Openwrt上寫C++ eclipse 在Openwrt上寫C++ Interface Interface GStreamer Basic Video Basic Google Cloud Speech Distance Matrix Places Speech Speech API Speech Distance Matrix Places Map Distance Matrix Places Distance Matrix Distance Matrix Places Places Git Basic CCNA TCP_IP與OSI網路模型 乙太區域網路基本觀念 廣域網路的原理 IPv4定址及路由的基本原理 TCP_IP傳輸層和應用層的基本原理.1 使用交換器建置乙太區域網路 Cisco區域網路交換器 Network TCP_IP與OSI網路模型 乙太區域網路基本觀念 廣域網路的原理 IPv4定址及路由的基本原理 TCP_IP傳輸層和應用層的基本原理.1 使用交換器建置乙太區域網路 Cisco區域網路交換器 Cisco TCP_IP與OSI網路模型 乙太區域網路基本觀念 廣域網路的原理 IPv4定址及路由的基本原理 TCP_IP傳輸層和應用層的基本原理.1 使用交換器建置乙太區域網路 Cisco區域網路交換器 通訊 TCP_IP與OSI網路模型 乙太區域網路基本觀念 廣域網路的原理 IPv4定址及路由的基本原理 TCP_IP傳輸層和應用層的基本原理.1 使用交換器建置乙太區域網路 Cisco區域網路交換器 證照 TCP_IP與OSI網路模型 乙太區域網路基本觀念 廣域網路的原理 IPv4定址及路由的基本原理 TCP_IP傳輸層和應用層的基本原理.1 使用交換器建置乙太區域網路 Cisco區域網路交換器 Server Type 軟體 Type Swift Basic I OS Language Basic I OS iOS I OS "}}