{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-08-12 03:45:00 "},"md/0-Basic/1-Basic/1-Basic.html":{"url":"md/0-Basic/1-Basic/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Linux tagsstop Introduction Linux是kernel,加上GNU社群裡面的一堆應用程式,就成了現在的OS發行版本 Windows大多直接使用administrator,是病毒氾濫的推手 root權限大到可以自殺 Tool 永中Office VLC GIMP(Photoshop) 主要分支 RedHat Red Hat Enterprise Linux(RHEL) Slackware SUSE Linux Enterprise(SUSE) Debian Ubuntu 建議用CentOS,因為KVM開發與測試環境都是在RHEL進行,而CentOS是RHEL open source的衍生(RHEL要收費,免費版無法升級或技術支援) 圖形介面 X是一種協定 xorg則是實現X協定,提供圖形化使用者介面服務的server軟體 系統開機之後自動執行xorg 1992~2004只有XFree86(GPL),後來公司改授權條款,造成GNU社群不滿,於是衍生出了xorg. X client軟體有兩個,一個叫Window Manager(WM),一個叫Display Manager(DM) 透過startx啟動xorg與default WM GNOME: Metacity KDE: K Win DM是負責圖形介面的使用者登入,開機第一個執行,且無人能關掉它 XDM KDM GDM Mac OS Ｘ協議與Linux X不同,前者是binary,後者是純文字 There is more than one way to define \"memory leak\". In particular, there are two primary definitions of \"memory leak\" that are in common usage among programmers. The first commonly used definition of \"memory leak\" is, \"Memory was allocated and was not subsequently freed before the program terminated.\" However, many programmers (rightly) argue that certain types of memory leaks that fit this definition don't actually pose any sort of problem, and therefore should not be considered true \"memory leaks\". An arguably stricter (and more useful) definition of \"memory leak\" is, \"Memory was allocated and cannot be subsequently freed because the program no longer has any pointers to the allocated memory block.\" In other words, you cannot free memory that you no longer have any pointers to. Such memory is therefore a \"memory leak\". Valgrind uses this stricter definition of the term \"memory leak\". This is the type of leak which can potentially cause significant heap depletion, especially for long lived processes. The \"still reachable\" category within Valgrind's leak report refers to allocations that fit only the first definition of \"memory leak\". These blocks were not freed, but they could have been freed (if the programmer had wanted to) because the program still was keeping track of pointers to those memory blocks. In general, there is no need to worry about \"still reachable\" blocks. They don't pose the sort of problem that true memory leaks can cause. For instance, there is normally no potential for heap exhaustion from \"still reachable\" blocks. This is because these blocks are usually one-time allocations, references to which are kept throughout the duration of the process's lifetime. While you could go through and ensure that your program frees all allocated memory, there is usually no practical benefit from doing so since the operating system will reclaim all of the process's memory after the process terminates, anyway. Contrast this with true memory leaks which, if left unfixed, could cause a process to run out of memory if left running long enough, or will simply cause a process to consume far more memory than is necessary. Probably the only time it is useful to ensure that all allocations have matching \"frees\" is if your leak detection tools cannot tell which blocks are \"still reachable\" (but Valgrind can do this) or if your operating system doesn't reclaim all of a terminating process's memory (all platforms which Valgrind has been ported to do this). © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/2-Shell.html":{"url":"md/0-Basic/1-Basic/2-Shell.html","title":"Shell","keywords":"","body":"Shell tagsstart Linux Shell tagsstop Command readelf -d -t iothub_client_sample_http find ~~~ | xargs rm diff $(readlink $(which sh)) xxd readlink -f /proc/20361/fd/1 tee lsof md5sum stty -a ctrl+w = alt+back ctrl+ cp --parent echo \"${PWD##*/}\" = basename ${PWD} tr -d '\\n' ldd nm This happens to me a lot, too, and this thread is one of the top results when googling for \"restart cinnamon\". Unfortunately, the instructions don't work for me (only because the display number is wrong!). For future visitors, here's what I do that always helps me. How do I restart Cinnamon from the tty? Cinnamon freezes Switch tty. I usually go to tty6, Ctrl+Alt+F6 If you need to login first, do so. Type w (yes, just the letter) and press enter. This commands does a lot of different things, but you need it to figure out the number of the display you are using. The display number is in the column FROM. Mine is :0 (yes, including the colon). Assuming that cinnamon is already dead (which you would notice by the windows lacking titles and that you can't move different windows around, and perhaps even not being able to use the keyboard), you type export DISPLAY=:0; cinnamon &, and don't forget the colon. I add the ampersand (&) only not to keep that tty busy. This always works for me, and I don't lose open windows. Also, I keep these instructions in a file called restartcinnamon, which is just a text file. I keep the file in my Dropbox folder, so no matter what machine I am on I can just type cat ~/Dropbox/restartcinnamon if I need to be reminded of how to do it. sed -i '/speech_language/s/value=\\\".*\\\"/value=\"zh-TW\"/' alextext.launch 查看进程pid (1) ps ux | grep prog_name (2) pgrep prog_name 查看线程tid (1) ps -efL | grep prog_name (2) ls /proc/pid/task 系統如何判斷 32bits / 64bits 在嘿嘿星期四的討論學到, Mat: 用 file /bin/bash, 結果非常淺顯易懂. sudo service network-manager restart © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/3-Makefile.html":{"url":"md/0-Basic/1-Basic/3-Makefile.html","title":"Makefile","keywords":"","body":"Makefile tagsstart Linux Makefile tagsstop 前言 $? $@ $ -Wall : 顯示所有的警告訊息 ZMQOPTS='-lzmq -lczmq' LDADD is used by NetBSD in the bsd.prog.mk Makefile, which is used to build programs of the base distribution and some of the programs in pkgsrc. LDLIBS is used by NetBSD in the sys.mk Makefile, which is used for implicit rules. LDLIBS is also used by GNU Make. LIBS is used by the GNU ./configure scripts. © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/4-Markdown.html":{"url":"md/0-Basic/1-Basic/4-Markdown.html","title":"Markdown","keywords":"","body":"Markdown tagsstart Markdown tagsstop 特殊 刪除線 至中 我是微软雅黑 color=gray 背景色是：orange 值班人员 星期一 星期二 星期三 李强 张明 王平 註腳1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/0-Basic/1-Basic/5-GDB.html":{"url":"md/0-Basic/1-Basic/5-GDB.html","title":"GDB","keywords":"","body":"GDB tagsstart Linux GDB tagsstop All-Stop Mode In all-stop mode, whenever your program stops under gdb for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot. Conversely, whenever you restart the program, all threads start executing. This is true even when single-stepping with commands like step or next. In particular, gdb cannot single-step all threads in lockstep. Since thread scheduling is up to your debugging target's operating system (not controlled by gdb), other threads may execute more than one statement while the current thread completes a single step. Moreover, in general other threads stop in the middle of a statement, rather than at a clean statement boundary, when the program stops. You might even find your program stopped in another thread after continuing or even single-stepping. This happens whenever some other thread runs into a breakpoint, a signal, or an exception before the first thread completes whatever you requested. Whenever gdb stops your program, due to a breakpoint or a signal, it automatically selects the thread where that breakpoint or signal happened. gdb alerts you to the context switch with a message such as ‘[Switching to Thread n]’ to identify the thread. On some OSes, you can modify gdb's default behavior by locking the OS scheduler to allow only a single thread to run. set scheduler-locking mode Set the scheduler locking mode. It applies to normal execution, record mode, and replay mode. If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may run when the inferior is resumed. The step mode optimizes for single-stepping; it prevents other threads from preempting the current thread while you are stepping, so that the focus of debugging does not change unexpectedly. Other threads never get a chance to run when you step, and they are completely free to run when you use commands like ‘continue’, ‘until’, or ‘finish’. However, unless another thread hits a breakpoint during its timeslice, gdb does not change the current thread away from the thread that you are debugging. The replay mode behaves like off in record mode and like on in replay mode. show scheduler-locking Display the current scheduler locking mode. By default, when you issue one of the execution commands such as continue, next or step, gdb allows only threads of the current inferior to run. For example, if gdb is attached to two inferiors, each with two threads, the continue command resumes only the two threads of the current inferior. This is useful, for example, when you debug a program that forks and you want to hold the parent stopped (so that, for instance, it doesn't run to exit), while you debug the child. In other situations, you may not be interested in inspecting the current state of any of the processes gdb is attached to, and you may want to resume them all until some breakpoint is hit. In the latter case, you can instruct gdb to allow all threads of all the inferiors to run with the set schedule-multiple command. set schedule-multiple Set the mode for allowing threads of multiple processes to be resumed when an execution command is issued. When on, all threads of all processes are allowed to run. When off, only the threads of the current process are resumed. The default is off. The scheduler-locking mode takes precedence when set to on, or while you are stepping and set to step. show schedule-multiple Display the current mode for resuming the execution of threads of multiple processes. © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Namespace/1-簡介/":{"url":"md/1-Namespace/1-簡介/","title":"簡介","keywords":"","body":"簡介 tagsstart Namespace tagsstop 什麼是Namespace？ 命名空間就是在大箱子(Kerne)裏面再裝一堆小箱子(Kernel Namespace) 為什麼要這麼做？ 因為如果我們想在箱子裏面放兩個外觀一模一樣的蘋果(Process)，到時候一定會無法區分 不如就放在A箱子裡面的蘋果，叫作A蘋果；放在B箱子裡面的蘋果，叫作B蘋果 命名空間有幾種？ Linux 2.6.24版的Kernel開始,提供了6種不同類型的Namespace 分別是： 程序間通信(IPC)命名空間 程序命名空間 網絡命名空間 掛載命名空間 UTS命名空間 用戶命名空間 所以有人說Namespaces是一種資源隔離方案，使得PID、Network、IPC等系統資源，不再屬於全域設定，而是某個特定的Namespace的資源 還有其他好處嘛？ 通過Namespace技術使得用戶創建的程序能夠與系統分離得更加徹底，從而不需要使用更多的底層(硬體支援)虛擬化技術 因為Namespaces是用純軟體劃分出來的概念 Namespace之間有關聯嘛？ Namespace之間的資源互相隔離、不可見的 因此在作業系統的層面上看，就會出現多個相同pid的Process User要怎麼看待Namespace 在用戶層面上只能看到屬於用戶自己Namespace下的資源 例如使用ps命令只能列出自己Namespace下的程序 使用者角度來看,每個Namespace看上去就像一個單獨的Linux系統 Image 1 - Linux的命名空間技術架構 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Namespace/2-Network namespaces/1-什麼是Network Namespace.html":{"url":"md/1-Namespace/2-Network namespaces/1-什麼是Network Namespace.html","title":"什麼是Network Namespace","keywords":"","body":"什麼是Network Namespace tagsstart Namespace Network namespace tagsstop 什麼是Network namespace 虛擬化網路相關的功能 Linux近幾年特有的技術(Darwin/Windows無類似功能)(約Kernel 3.0開始才有) 是輕量級虛擬化技術的基礎（Docker,LXC,OpenVZ的原理） 多用在虛擬化和隔離 很少被單獨使用 虛擬化網路相關的功能,是指哪些？ 不同Network namespace內的Process,具有不同的Network資源如下： 虛擬網卡列表 IPv4和IPv6協議 Routing Table 防火牆設定 /proc/net目錄 /sys/class/net目錄 埠（socket） 有什麼特性？ 簡單說就是幾個Process之間搞小團體，小團體有私有網路資源，且小團體之間互不干擾 多用在虛擬化和隔離 如果Network Namespace之間要互相溝通怎麼辦? 在不同的Network namespace間創建通道：veth pair（虛擬網路設備對接口） 不同Network Namespace因為veth pair得以共享同一個實體網路設備 傳統沒有Network natags: Namespace,Network namespacemespace前是怎樣？ 一般乙太網路應用程式 Image 1 - 一般乙太網路應用程式 如果是ADSL/光世代的PPPoE Image 2 - PPPoE 如果是VPN Image 3 - VPN 網卡拿來當Hub用的Bridge Image 4 - Bridge Bridge相關指令: 需要安裝bridge-utils才能使用brctl brctl show - 顯示bridge狀況 brctl addbr/delbr - 新增/刪除bridge brctl addif - 將interface新增至bridge brctl delif - 將interface從bridge移除 有Network namespace後是怎樣？ 只有一個Network namespace的話 Image 5 - 一個Network namespace 複數Network namespace的話 Image 6 - 複數Network namespace 透過veth可以連接兩個Network namespace Image 7 - veth 搭配Bridge使其他Network namespace上網 Image 8 - Bridge+Network namespace 有什麼應用場景？ 多個Network namespace可以共享eth0和lo等實體網路設備 多個Apache伺服器Process可以在不同Network namespace的80埠上進行監聽 一個Process不能嗅探其他Network namespace的流量 一個Process不能關閉其他Network namespace的接口 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Namespace/2-Network namespaces/2-範例.html":{"url":"md/1-Namespace/2-Network namespaces/2-範例.html","title":"範例","keywords":"","body":"範例 tagsstart Namespace Network namespace tagsstop 此範例的目標是？ 使用ip創建H1和H2兩個Network namespace H1擁有自己的Network namespace以及私有網路網路接口h1-eth0 H2擁有自己的Network namespace以及私有網路網路接口h2-eth0 使用ovs-vsctl創建Software Switch S1 S1有兩個埠s1-eth0和s1-eth1 S1運行在root namespace,並使用實體接口eth0，等待Controller的指令 使用veth pair與對應的Host接口相連，這樣H1和H2就可以透過S1溝通 s1-eth0和s1-eth1間的通訊資料透過Software Switch轉發 Image 1 - Example1 什麼是ip command? ip這個command是iproute2軟體包裡面的一個強大的網路配置工具 它能夠替代一些傳統的網路管理工具，例如:ifconfig、route 使用權限要為root 幾乎所有的Linux發行版本都支持該command 介紹ip command吧 ip netns add - 新增NetNS ip netns list - 列出現有的NetNS ip netns identify - 顯示PID所在的NetNS ip netns identify $$ - 顯示目前的NetNS ip netns exec - 在Network namespace執行command ip link add type veth peer name - 建立一個veth裝置 ip link set nets - 將veth搬到NetNS Step 1 - Create host namespaces 建立H1 namespaces sudo ip netns add h1 建立H2 namespaces sudo ip netns add h2 察看建立結果 sudo ip netns Image 2 - Step 1-Result Image 3 - Step 1-Topo Step 2 - Create switch 建立Switch sudo ovs-vsctl add-br s1 Image 4 - Step 2-Topo Step 3 - Create links 建立Link 1(h1-eth0 - s1-eth1) sudo ip link add h1-eth0 type veth peer name s1-eth1 建立Link 2(h2-eth0 - s1-eth2) sudo ip link add h2-eth0 type veth peer name s1-eth2 顯示連結結果 sudo ip link show Image 5 - Step 3-Result Step 4 - Move host ports into namespaces 將H1 port移到H1 namespaces sudo ip link set h1-eth0 netns h1 將H2 port接到H2 namespaces sudo ip link set h2-eth0 netns h2 顯示H1 namespaces的連結 sudo ip netns exec h1 ip link show 顯示H2 namespaces的連結 sudo ip netns exec h2 ip link show Image 6 - Step 4-Result Image 7 - Step 4-Topo Step 5 - Connect switch ports to OVS 將S1 port1連接到Switch sudo ovs-vsctl add-port s1 s1-eth1 將S1 port2連接到Switch sudo ovs-vsctl add-port s1 s1-eth2 顯示Switch的連結 sudo ovs-vsctl show Image 8 - Step 5-Topo Step 6 - Set up OpenFlow controller 設定Controller sudo ovs-vsctl set-controller s1 tcp:127.0.0.1 設定Controller監聽端口OpenFlow TCP（默認值:6633) sudo ovs-controller ptcp: 查詢OpenFlow Controller是否正確連接到S1 sudo ovs-vsctl show Image 9 - Step 6-Result Step 7 - Configure network 修改H1 port網路介面，給予H1 eth0一個 10.0.0.1 的參數 sudo ip netns exec h1 ifconfig h1-eth0 10.1 啟動H1 eth0網路介面 sudo ip netns exec h1 ifconfig lo up 修改H2 port網路介面，給予H2 eth0一個 10.0.0.2 的參數 sudo ip netns exec h2 ifconfig h2-eth0 10.2 啟動H2 eth0網路介面 sudo ip netns exec h2 ifconfig lo up 啟動Switch網路介面 sudo ifconfig s1-eth1 up sudo ifconfig s1-eth2 up Step 8 - Test network 透過H1網路介面Ping H2網路介面 sudo ip netns exec h1 ping -c1 10.2 Image 10 - Step 8-Result Image 11 - Final-Result © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/8-Memory/1-Memory_Leak/1-valgrind.html":{"url":"md/8-Memory/1-Memory_Leak/1-valgrind.html","title":"Valgrind","keywords":"","body":"valgrind tagsstart valgrind memory tagsstop Introduction Memory Leak: leak on the heap, memory allocation during runtime Frequent Memory Leak: a code include memory leak is used frequently (most dangerous but relatively easy to find) Occasional Memory Leak: memory leak happens in specific occasion (hard to find) One-Time Memory Leak: only leak once, like in a singleton class (not that dangerous) Implicit Memory Leak: always allocate memory during the runtime and only free memory until exit (hard to find and dangerous, may hold too much memory and lead to crush ) Examples Forget to free/delete void func() { char *oldString = \"Old String\"; char* newStrig = strdup(oldString); //be careful with c lib-functions which alloc memory inside char *textString = malloc(128*sizeof(char)); ClassTypeA *ptr = new ClassTypeA; return; } Be careful with logic branches BassClass * obj = new BaseClass； if（test something） return; else if (test something) do something; else do something; delete obj; return; 2.Careful with Inheritance, polymorphism BaseClass* obj_ptr = new DerivedClass; delete obj_ptr; /*If you are counting on the destructor to delete memory allocated in the constructor beware of this mistake as it will cause a memory leak. */ /*Use a virtual destructor to avoid this problem.*/ 3.Pointer re-assignment error char *a = malloc(128*sizeof(char)); char *b = malloc(128*sizeof(char)); b = a; free(a); free(b); // will not free the pointer to the original allocated memory. 4.Default copy constructor may not give correct results ClassA& operator=(const ClassA& right_hand_side); /*sallow copy, deep copy?*/ /*Memory allocated by copy constructors for pointer duplication. Check in destructor and delete if necessary. Memory allocated in passing class by value which invokes copy constructor. Also beware, the default copy constructor may not give you the results you want especially when dealing with pointers as the default copy constructor has no knowledge of how to copy the contents of what the pointer points to. To prohibit the use of the default copy constructor define a null assignment operator. And when there is allocation in class, define your own destructor*/ class GCharacter //Game Character { private: std::string name; int capacity; //the capacity of our tool array int used; //the nr of elements that we've actually used in that tool array std::string* toolHolder; //string pointer that will be able to reference our ToolArray; public: static const int DEFAULT_CAPACITY = 5; //Constructor GCharacter(std::string n = \"John\", int cap = DEFAULT_CAPACITY) :name(n), capacity(cap), used(0), toolHolder(new string[cap]) { } } int main() { GCharacter gc1(\"BoB\", 5); GCharacter gc2(\"Terry\", 5); gc2 = gc1; GCharacter gc3 = gc1; return 0; } Do not rely on STL containers vector objects; for (int i=0;i Yes, stl containers will call destruct functions. But in this case, the container dose not free any memory. vector objects; //when clear object in vector, the vector will call the destructor of T in this way *T->~T(); Implicit Memory Leak: free memory as soon as you don't need it(or need so large) another stl example: stl containers always know how and when to expand itself, but they never know when to shrink itself. { vector vec; for(int64_t i=0; i then the 1000000000000000000*sizeof(int) memory will hold forever. //if you don't need it vector().swap(vec) //instead of clear //if you want to shrink the container size vector(vec).swap(vec) Implicit Memory Leak: heap fragmentation（impossible to be found by tools） You think the code is memory leak free, but the memory usage always going up and then crush.... Applications that are free from memory leaks but perform dynamic memory allocation and deallocation frequently tend to show gradual performance degradation if they are kept running for long periods. Finally, they crash. Why is this? Recurrent allocation and deallocation of dynamic memory causes the heap to become fragmented, especially if the application allocates small memory chunks (int, an 8 byte object etc.). A fragmented heap can have many free blocks, but these blocks are small and non-contiguous. imagine that you have a \"large\" (32 bytes) expanse of free memory: | | Now, allocate some of it (5 allocations): |aaaabbccccccddeeee | Now, free the first four allocations but not the fifth: | eeee | Now, try to allocate 16 bytes. Oops, I can't, even though there's nearly double that much free. On systems with virtual memory, fragmentation is less of a problem than you might think, because large allocations only need to be contiguous in virtual address space, not in physical address space. So in my example, if I had virtual memory with a page size of 2 bytes then I could make my 16 byte allocation with no problem. Physical memory would look like this: | ffffffffffffffeeeeff | whereas virtual memory (being much bigger) could look like this: ------------------------------------------------------... | eeeeffffffffffffffff ------------------------------------------------------... The classic symptom of memory fragmentation is that you try to allocate a large block and you can't, even though you appear to have enough memory free. Another possible consequence is the inability of the process to release memory back to the OS (because there's some object still in use in all the blocks it has allocated from the OS, even though those blocks are now mostly unused). Method to avoid: 1.First of all, use dynamic memory as little as possible. In most cases, you can use static or automatic storage instead of allocating objects dynamically. 2.Secondly, try to allocate large chunks rather than small ones. For example, instead of allocating a single object, allocate an array of objects at once, and use these objects when they are needed. (Like use reserve() for stl containers) If all these tips don't solve the fragmentation problem, you should consider building a custom memory pool. Implicit Memory Leak: memory not release to OS When you call free() or delete(), it will NOT really release any memory back to OS. Instead, that memory is kept with the same process until it is terminated. However, this memory can be reused for any future allocations by the same process. documentation for libc's free: Occasionally, free can actually return memory to the operating system and make the process smaller. Usually, all it can do is allow a later call to malloc to reuse the space. In the meantime, the space remains in your program as part of a free-list used internally by malloc. a little deeper by looking at other malloc/free family of functions and saw 'mallopt', and that you can actually change the way malloc/free behave (especially if you're using GNU libc -- pointers about other platform implementations would be helpful). One option that is interesting to look at is M_TRIM_THRESHOLD which: This is the minimum size (in bytes) of the top-most, releasable chunk that will cause sbrk to be called with a negative argument in order to return memory to the system. 昨天晚上，我徒弟跑过来讲，他的程序的内存占用居高不下，愿意是std::map的clear()没有效果。于是我让他用erase(begin,end); 试试也不行。 代码如下： View Code 用命令 top -p ps -ef | grep abc | grep -v grep | awk {'print $2'}, 一查看，占了104M物理内存。 开始我猜测是stl用了自己的缓冲池，clear()并没有归还给系统。于是我用了boost::unordered_map试试，一查看，占了78M物理内存（看来hashmap比红黑树既快又省空间）。 于是上网查询资料，stl有很多种allocator，默认采用是的new_allocator，并没有使用内存缓冲池，针对不同的应用场合，STL中实现了不同的Allocator。 gnu_cxx::new_allocator Simply wraps ::operator new and ::operator delete. gnu_cxx::malloc_allocator Simply wraps malloc and free. There is also a hook for an out-of-memory handler gnu_cxx::debug_allocator A wrapper around an arbitrary allocator A. It passes on slightly increased size requests to A, and uses the extra memory to store size information. gnu_cxx::pool_alloc A high-performance, single pool allocator. The reusable memory is shared among identical instantiations of this type. gnu_cxx::mt_alloc A high-performance fixed-size allocatorthat was initially developed specifically to suit the needs of multi threaded applications gnu_cxx::bitmap_allocato A high-performance allocator that uses a bit-map to keep track of the used and unused memory locations 发现stl提供的malloc.h有监控功能，于是修改为下面代码： #include #include #include #include #include using namespace std; using namespace boost; void release_map(void) { malloc_stats(); map testmap; sleep(2); for(int i=0; i 发现clear() 其实已经归还内存了，内存的持有是 system bytes 。显然，malloc并没有把这些内存归还给系统，而是缓存起来了。所以说，这个例子的罪魁祸首并不是STL，而是glibc的malloc。好吧，既然找到问题，那就要解决它，虽然glibc的缓存也是一番好意，但是由于实际运行环境不能等到什么用户heap空间内连续空闲内存数据超出一个阈值时才将这片内存归还给内核。 glibc管理内存目前采用的是ptmalloc2，我测试了google的tcmalloc和Jason Evans的jemalloc。 测试很简单，把包downlaod下来并解压，./configure && make && make install即可。 export $LD_PRELOAD=\"/usr/local/lib/libtcmalloc.so” 或者 export $LD_PRELOAD=\"/usr/local/lib/libjemalloc.so” (这个要根据自己的实际情况选择路径) 然后编译后可以用ldd查看程序的依赖库。 测试结果：tcmalloc也不归还给系统，而jemalloc的clear后不再占用物理内存。 徒弟问了一句jemalloc靠谱么，我想想淘宝的Tengine，facebook的folly，redis，firefox，freebsd都是用这个，应该是很靠谱的。你上线去测试看看。 附上一张内存分配性能比较图片： Image 1 - Performance valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./pega_iot_gateway_bin hello_world_lin.json 可以看到 memory lost 分成幾種類型： definitely lost: 真的 memory leak 了 indirectly lost: 間接的 memory leak，structure 本身發生 memory leak，而內部的 member 如果是 allocate 的出來的，一樣會 memory leak，但是只要修好前面的問題，後面的問題也會跟著修復 possibly lost: allocate 一塊記憶體，並且放到指標 ptr，但事後又改變 ptr 指到這會計一體的中間 (這一點我目前也不是很清楚，建議看原文說明) still reachable: 程式結束時有未釋放的記憶體，不過卻還有指標指著，通常會發生在 global 變數 如果不想 show possibly lost，可以加下面的參數 3.9版 --show-leak-kinds=definite 3.7版 --show-possibly-lost=no © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/11-Cross_compile/1-Yocto/1-BBfile.html":{"url":"md/11-Cross_compile/1-Yocto/1-BBfile.html","title":"B Bfile","keywords":"","body":"BBfile tagsstart Cross compile Yocto BBfile tagsstop T1 source build/conf/set_bb_env.sh cat pega.sh 裡面有描述 export MACHINE=apq8009 rebake boost rebake azure-iot-sdk merlot/oe-core/build/downloads oe-core/build/tmp-glibc/work/armv7a-vfp-neon-oe-linux-gnueabi repo forall vendor/pega/voiced/ -c git branch -r TOPDIR = 所在的meta目錄 WORKDIR = xxx/1.0-r0/ sbindir = /usr/sbin CFLAGS = makefile 的CFLAGS LDFLAGS = makefile 的LDFLAGS PN = BBfile Name S = 要將src cp 到的位置 ,以下稱為S(source). 與之相對的為D D = WORKDIR/image/ License=build/conf/local.conf © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-08-12 03:45:00 Linux Basic Shell Makefile GDB Shell Shell Makefile Makefile Markdown Markdown GDB GDB Namespace 簡介 什麼是Network Namespace 範例 Network namespace 什麼是Network Namespace 範例 valgrind Valgrind memory Valgrind Cross compile B Bfile Yocto B Bfile BBfile B Bfile "}}