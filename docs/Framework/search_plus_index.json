{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 03:50:27 "},"md/1-Mininet/1-什麼是 mininet/":{"url":"md/1-Mininet/1-什麼是 mininet/","title":"什麼是 mininet","keywords":"","body":"什麼是 mininet tagsstart mininet tagsstop 什麼是 mininet mininet是一個用python寫的一個Process 這個Process是一個網路模擬器(network emulator) 或者更精確的說：網路拓樸模擬器(network emulation orchestration system) 既然叫拓樸模擬器，代表它模擬了一整個:終端主機(end-hosts),路由器(router),交換器(switches)的集成系統 模擬網路系統可以做什麼？ 通常透過mininet模擬的架構,會與實際透過硬體架設的結果一致，因此可做為實體配線前的臨摹 mininet模擬的host行為跟真的一樣：你可以SSH(Secure Shell)進去並運行任意程式，也可以運行server 你也可以送出封包，就像透過真的乙太網路出去，有link speed & delay，可以觀察封包來往的狀況 可以輕易的製作支援SDN的區域網路 (後面會介紹什麼是SDN)，事實上，mininet是很適合作為一個輕量級的SDN仿真工具 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-18 05:47:06 "},"md/1-Mininet/2-什麼是 SDN/":{"url":"md/1-Mininet/2-什麼是 SDN/","title":"什麼是 SDN","keywords":"","body":"什麼是 SDN tagsstart mininet SDN tagsstop 什麼是 SDN？ 全名是：軟體定義式網路（Software defined Networking，SDN） 要了解SDN之前，要先了解現今網路架構中，路由器除了硬體上俱備有轉送資料的能力外， 對於資料的移動控制，都是在每一台路由器中， 實作著遵守各種傳輸協定的控制軟體 例如連結層有擴展樹協定（Spanning Tree Protocol，STP）來防止封包卡在迴圈 雖然協定是共通的，但網通廠商各有各的OS與實作技術，導致一旦企業購買某一廠牌的設備， 未來更新設備時就必須遷就於該廠牌的網管功能，造成被網通廠商挾持的情形 現今這樣不是沒什麼問題嘛？ 隨著隨著雲端應用及巨量資料增加，路由表越來越龐大，判斷轉送的過程愈來愈複雜 而這些判斷需要路徑上的每一台交換器或是路由器不斷的拆分及重組封包 可想而知，結果導致傳輸效率不佳，無法有效發揮網路頻寬 網路管理人員需要客製調整各種網路設定時，也必須針對每臺交換器或路由器，逐一登入command-line設定，相當麻煩 而且透過人工逐一設定的方式也有很高的風險，一旦網路管理人員輸入了錯誤的指令，很容易造成網路服務癱瘓 於是關於控制封包這件事情，我們需要重新思考：真的需要每一台路由器拆開封包才能判斷嘛？ 所以SDN做了什麼？ 它的概念是：將網路分為控制層（Control Plane）與資料層（Data Plane） 將網路的管理權限交由控制層的控制器（Controller）軟體負責，採用集中控管的方式，同時也負責決定傳輸路徑 Image 1 - SDN SDN帶來的好處？ 讓網路的管理變得更集中 自動處理與動態因應變化 讓網路的設計、部署、管理、規模延展更為容易 可以減少IT服務日常維運，減少人為出錯 既然傳輸路徑已預先設定完成，交換器不需要透過不斷學習來尋找封包傳送的路徑，可大幅提升傳輸效率，降低延遲（Latency）的時間 可節省支出 所以網通廠怎麼看SDN？ SDN使得交換器的重要性將會不如以往 (功能會越來越單純，未來可能僅負責封包的傳送) 未來客製化的軟體就可以提供各項硬體設備的功能 於硬體設備廠商來說，將會是一大衝擊 臺灣企業還不了解SDN在未來的重要性，而且開發SDN應用程式的門檻較高 Google、Facebook、Yahoo、微軟等多家指標型的大企業投入了SDN架構與OpenFlow技術的發展 我剛好像看到OpenFlow，那是什麼？ 跟SDN是什麼關係 OpenFlow是實現SDN架構最主流的核心技術，也就是網路交換器(switch)和控制器(controller)之間的傳輸協定 就像是人類的神經一樣，負責大腦與四肢的溝通 OpenFlow技術將封包傳送的路徑看成是一條「Flow」，就好像是專屬的傳輸路徑 例如經過哪些交換器，需要多少的網路頻寬，再將傳輸路徑設定成OpenFlow路由表（Flow Table） 控制層和資料層之間，利用SSL加密，建立起安全的傳輸通道 但它只是整體SDN架構的一部分，而且也並非唯一可用的協定 OpenFlow是SDN的一部分，但SDN不是只有OpenFlow Image 2 - OpenFlow © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Mininet/3-mininet 實戰/":{"url":"md/1-Mininet/3-mininet 實戰/","title":"mininet 實戰","keywords":"","body":"mininet 實戰 tagsstart mininet tagsstop 安裝 Debian Package sudo apt-get install mininet Build source and install git clone git://github.com/mininet/mininet mininet/util/install.sh -a 啟動 在沒有任何參數下，產生的虛擬環境為兩個host (h1,h2)，一個switch (s1)，並將h1,h2連接s1 Image 1 - Topology 啟動sudo mn Image 2 - mn mininet是基於OVS的應用軟體，當沒有設定OVS Controller時，他會退回OVS Bridge模式(不依賴Controller，預設所有node都是可以連通的) OVS:全名Open vSwitch，類似VM，主要是虛擬switch，支援OpenFlow 測試 顯示所有節點nodes Image 3 - nodes 顯示所有節點的連接關係net Image 4 - net 察看所有節點的資訊:dump Image 5 - dump 用h1 ping h2 一個封包h1 ping -c 1 h2 Image 6 - ping 叫出兩個host的命令視窗xterm h1 h2 Image 7 - xterm Mininet Python API Topo: Mininet拓撲結構的base class build(): The method to override in your topology class. Constructor parameters (n) will be passed through to it automatically by Topo.init(). addSwitch(): 給拓撲結構中增加一個switch，返回switch名字 addHost(): 增加host，返回host名字 addLink(): 增加一個雙向link，返回link的key Mininet: 建立和管理網路的main class start(): 開啟網路 pingAll(): 通過host之間的互ping測試連通性 stop(): 關閉網絡 net.hosts: 網路中的所有主機 dumpNodeConnections(): 所有的連接關係 setLogLevel( 'info' | 'debug' | 'output' ): set Mininet's default output level; 'info' is recommended as it provides useful information. 寫一個Python範例 目標 啟動50個hosts，作為VM server farm 啟動1個controller 啟動1個switch Image 8 - Server Farm Code example #!/usr/bin/python import re from mininet.net import Mininet from mininet.node import Controller from mininet.cli import CLI from mininet.link import Intf from mininet.log import setLogLevel, info, error from mininet.util import quietRun from mininet.node import OVSController def checkIntf( intf ): \"Make sure intf exists and is not configured.\" if ( ' %s:' % intf ) not in quietRun( 'ip link show' ): error( 'Error:', intf, 'does not exist!\\n' ) exit( 1 ) ips = re.findall( r'\\d+\\.\\d+\\.\\d+\\.\\d+', quietRun( 'ifconfig ' + intf ) ) if ips: error( 'Error:', intf, 'has an IP address and is probably in use!\\n' ) exit( 1 ) def myNetwork(): net = Mininet( topo=None, build=False) info( '*** Adding controller\\n' ) net.addController(name='c0',controller = OVSController) info( '*** Add switches\\n') s1 = net.addSwitch('s1') max_hosts = 50 newIntf = 'enp3s0' host_list = {} info( '*** Add hosts\\n') for i in xrange(1,max_hosts+1): host_list[i] = net.addHost('h'+str(i)) info( '*** Add links between ',host_list[i],' and s1 \\r') net.addLink(host_list[i], s1) info( '*** Checking the interface ', newIntf, '\\n' ) checkIntf( newIntf ) switch = net.switches[ 0 ] info( '*** Adding', newIntf, 'to switch', switch.name, '\\n' ) brintf = Intf( newIntf, node=switch ) info( '*** Starting network\\n') net.start() CLI(net) net.stop() if __name__ == '__main__': setLogLevel( 'info' ) myNetwork() 執行 sudo python example.py Image 9 - example Q&A 執行出現Cannot find required executable ovs-controller 你沒有安裝ovs-controller sudo apt-get install openvswitch-testcontroller ovs-controller是舊名稱，所以你需要複製一下 sudo cp /usr/bin/ovs-testcontroller /usr/bin/ovs-controller 執行出現 Exception: Please shut down the controller which is running on port 6653: Active Internet connections (servers and established) tcp 0 0 0.0.0.0:6653 0.0.0.0:* LISTEN 30215/ovs-testcontr 你需要kill正在背景執行的ovs-testcontroller sudo netstat -lptu sudo service ovs-testcontroller stop Mininet建立網路的三種方式 底層API Node & Link h1 = Host( 'h1' ) h2 = Host( 'h2' ) s1 = OVSSwitch( 's1', inNamespace=False ) c0 = Controller( 'c0', inNamespace=False ) Link( h1, s1 ) Link( h2, s1 ) h1.setIP( '10.1/8' ) h2.setIP( '10.2/8' ) c0.start() s1.start( [ c0 ] ) print h1.cmd( 'ping -c1', h2.IP() ) s1.stop() c0.stop() 中層API net Object net = Mininet() h1 = net.addHost( 'h1' ) h2 = net.addHost( 'h2' ) s1 = net.addSwitch( 's1' ) c0 = net.addController( 'c0' ) net.addLink( h1, s1 ) net.addLink( h2, s1 ) net.start() print h1.cmd( 'ping -c1', h2.IP() ) CLI( net ) net.stop() 上層API Topology Object class SingleSwitchTopo( Topo ): \"Single Switch Topology\" def __init__( self, count=1, **params ): Topo.__init__( self, **params ) hosts = [ self.addHost( 'h%d' % i ) for i in range( 1, count + 1 ) ] s1 = self.addSwitch( 's1' ) for h in hosts: self.addLink( h, s1 ) net = Mininet( topo=SingleSwitchTopo( 3 ) ) net.start() CLI( net ) net.stop() © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Mininet/4-運作原理/1-Network Namespace.html":{"url":"md/1-Mininet/4-運作原理/1-Network Namespace.html","title":"Network Namespace","keywords":"","body":"Network Namespace Mininet虛擬化的核心機制是？ Linux Network Namespace是Mininet軟體架構的基石，用其創建虛擬節點 需要先了解Linux Namespace 之中的 Network Namespaces 預設情況下，Mininet會為每一個host創建一個新的Network Namespaces 由於每個host都有各自獨立的Network Namespaces，我們就可以進行個性化的網路配置和程式佈署 Switch和Controller運行在root Namespace，因此兩個Processes共享同一個Network Namespaces 由於Linux Namespace的虛擬技術沒有提供類似於VM的持久化能力，所以在Mininet關閉時不能保存所有設定 Mininet建立的Network namespace是nameless的，所以透過ip netns list是查看不到的 而透過ip netns add建立的Network Namespace是帶name的，這是兩者最明顯的區別之處Discussions Linux Network Namespace在OpenStack和Docker等開源項目中也廣泛應用主要用於作業系統層級的虛擬化，包含虛擬網路 解釋一下，上一個的範例與namespace的關聯 範例中Host H1和Host H2連接到運行在Kernel的root namespace的Switch S1 H1和H2擁有自己的網路匿名命名空間以及私有網路接口h1-eth0和h2-eth0 S1有兩個埠s1-eth1和s1-eth2，通過veth pair與Host接口相連，這樣H1和H2就可以透過S1進行交流 s1-eth0和s1-eth1間的data轉發透過S1完成，並使用實體接口eth0，等待Controller的指令 Image 1 - Example1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Mininet/4-運作原理/2-Node.html":{"url":"md/1-Mininet/4-運作原理/2-Node.html","title":"Node","keywords":"","body":"Node Node是什麼？ 每個Host其實就是一個Node的物件，可以在node.py中看到此物件的定義 node.py class Node( object ): portBase = 0 # Nodes always start with eth0/port0, even in OF 1.0 def __init__( self, name, inNamespace=True, **params ): self.checkSetup() self.name = params.get( 'name', name ) self.privateDirs = params.get( 'privateDirs', [] ) self.inNamespace = params.get( 'inNamespace', inNamespace ) ... # Start command interpreter shell self.startShell() self.mountPrivateDirs() inToNode = {} # mapping of input fds to nodes outToNode = {} # mapping of output fds to nodes 初始時，會有一個變數inNamespace用來決定此Host是否要透過network namespaces來達到network isolation的功能 當變數都初始化後，就會呼叫startShell()來啟動此Host node.py def startShell( self, mnopts=None ): \"Start a shell process for running commands\" if self.shell: error( \"%s: shell is already running\\n\" % self.name ) return # mnexec: (c)lose descriptors, (d)etach from tty, # (p)rint pid, and run in (n)amespace opts = '-cd' if mnopts is None else mnopts if self.inNamespace: opts += 'n' # bash -i: force interactive # -s: pass $* to shell, and make process easy to find in ps # prompt is set to sentinel chr( 127 ) cmd = [ 'mnexec', opts, 'env', 'PS1=' + chr( 127 ), 'bash', '--norc', '-is', 'mininet:' + self.name ] master, slave = pty.openpty() self.shell = self._popen( cmd, stdin=slave, stdout=slave,stderr=slave,close_fds=False ) ... 可以觀察到，mininet是透過一隻叫做mnexec的程式來執行，並且透過參數-n來將此process給轉換到network namespaces中 所以建立完Host以後，可以使用ip來看？ 理論上我們要可以透過ip netns show來看到這些network namespaces，實際上卻看不到 原因如同此篇所說，由於建立的為nameless network namespaces Host是Node，那Switch呢？ 建立Switch包含了四種選擇OVSLegacyKernelSwitch、UserSwitch、OVSSwitch，IVSSwitch 一般常用的就是OVSSwitch 這四種Switch都繼承自Switch物件，而Switch物件則繼承自Node © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Mininet/4-運作原理/3-Link.html":{"url":"md/1-Mininet/4-運作原理/3-Link.html","title":"Link","keywords":"","body":"Link 接下來會根據拓墣的Link情況，去創建對應的Interface 首先，這邊使用到Link這個物件來表示每一條Link 每個Link實際上對應到的是兩個Node上面的Interface link.py class Link( object ): \"\"\"A basic link is just a veth pair. Other types of links could be tunnels, link emulators, etc..\"\"\" # pylint: disable=too-many-branches def __init__( self, node1, node2, port1=None, port2=None, intfName1=None, intfName2=None, addr1=None, addr2=None, intf=Intf, cls1=None, cls2=None, params1=None, params2=None, fast=True ): \"\"\"Create veth link to another node, making two new interfaces. node1: first node node2: second node port1: node1 port number (optional) port2: node2 port number (optional) intf: default interface class/constructor cls1, cls2: optional interface-specific constructors intfName1: node1 interface name (optional) intfName2: node2 interface name (optional) params1: parameters for interface 1 params2: parameters for interface 2\"\"\" # This is a bit awkward; it seems that having everything in # params is more orthogonal, but being able to specify # in-line arguments is more convenient! So we support both. if params1 is None: params1 = {} if params2 is None: params2 = {} # Allow passing in params1=params2 if params2 is params1: params2 = dict( params1 ) if port1 is not None: params1[ 'port' ] = port1 if port2 is not None: params2[ 'port' ] = port2 if 'port' not in params1: params1[ 'port' ] = node1.newPort() if 'port' not in params2: params2[ 'port' ] = node2.newPort() if not intfName1: intfName1 = self.intfName( node1, params1[ 'port' ] ) if not intfName2: intfName2 = self.intfName( node2, params2[ 'port' ] ) self.fast = fast if fast: params1.setdefault( 'moveIntfFn', self._ignore ) params2.setdefault( 'moveIntfFn', self._ignore ) self.makeIntfPair( intfName1, intfName2, addr1, addr2, node1, node2, deleteIntfs=False ) 這邊要觀察到的，Link物件會呼叫makeIntfPair此方法，此方法就可以將兩個Interface給串接起來 util.py def makeIntfPair( intf1, intf2, addr1=None, addr2=None, node1=None, node2=None, deleteIntfs=True, runCmd=None ): \"\"\"Make a veth pair connnecting new interfaces intf1 and intf2 intf1: name for interface 1 intf2: name for interface 2 addr1: MAC address for interface 1 (optional) addr2: MAC address for interface 2 (optional) node1: home node for interface 1 (optional) node2: home node for interface 2 (optional) deleteIntfs: delete intfs before creating them runCmd: function to run shell commands (quietRun) raises Exception on failure\"\"\" if not runCmd: runCmd = quietRun if not node1 else node1.cmd runCmd2 = quietRun if not node2 else node2.cmd if deleteIntfs: # Delete any old interfaces with the same names runCmd( 'ip link del ' + intf1 ) runCmd2( 'ip link del ' + intf2 ) # Create new pair netns = 1 if not node2 else node2.pid if addr1 is None and addr2 is None: cmdOutput = runCmd( 'ip link add name %s ' 'type veth peer name %s ' 'netns %s' % ( intf1, intf2, netns ) ) else: cmdOutput = runCmd( 'ip link add name %s ' 'address %s ' 'type veth peer name %s ' 'address %s ' 'netns %s' % ( intf1, addr1, intf2, addr2, netns ) ) if cmdOutput: raise Exception( \"Error creating interface pair (%s,%s): %s \" % ( intf1, intf2, cmdOutput ) ) 這邊可以看到，mininet實際上是透過系統中的ip link的方法，將兩個interface創造一條veth的Link 此時，我們的系統如下 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/1-Mininet/4-運作原理/4-Interface.html":{"url":"md/1-Mininet/4-運作原理/4-Interface.html","title":"Interface","keywords":"","body":"Interface 接下來我們要把這些interface給綁到特定的Node身上 在Link物件初始化後段，會去初始化兩個Interface真正的物件本體 link.py class Intf( object ): \"Basic interface object that can configure itself.\" def __init__( self, name, node=None, port=None, link=None, mac=None, **params ): \"\"\"name: interface name (e.g. h1-eth0) node: owning node (where this intf most likely lives) link: parent link if we're part of a link other arguments are passed to config()\"\"\" self.node = node self.name = name self.link = link self.mac = mac self.ip, self.prefixLen = None, None # if interface is lo, we know the ip is 127.0.0.1. # This saves an ifconfig command per node if self.name == 'lo': self.ip = '127.0.0.1' # Add to node (and move ourselves if necessary ) moveIntfFn = params.pop( 'moveIntfFn', None ) if moveIntfFn: node.addIntf( self, port=port, moveIntfFn=moveIntfFn ) else: node.addIntf( self, port=port ) # Save params for future reference self.params = params self.config( **params ) 這邊要觀察的重點是每個Interface都會去呼叫node.addIntf( self, port=port )來處理 node.py def addIntf( self, intf, port=None, moveIntfFn=moveIntf ): \"\"\"Add an interface. intf: interface port: port number (optional, typically OpenFlow port number) moveIntfFn: function to move interface (optional)\"\"\" if port is None: port = self.newPort() self.intfs[ port ] = intf self.ports[ intf ] = port self.nameToIntf[ intf.name ] = intf debug( '\\n' ) debug( 'added intf %s (%d) to node %s\\n' % ( intf, port, self.name ) ) if self.inNamespace: debug( 'moving', intf, 'into namespace for', self.name, '\\n' ) moveIntfFn( intf.name, self ) 此方法最後會呼叫moveIntf來將該interface給處理，moveIntf則會呼叫moveIntfNoRetry將Interface給綁入到每個Node中 util.py def moveIntf( intf, dstNode, printError=True, retries=3, delaySecs=0.001 ): \"\"\"Move interface to node, retrying on failure. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" retry( retries, delaySecs, moveIntfNoRetry, intf, dstNode, printError=printError ) def moveIntfNoRetry( intf, dstNode, printError=False ): \"\"\"Move interface to node, without retrying. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" intf = str( intf ) cmd = 'ip link set %s netns %s' % ( intf, dstNode.pid ) cmdOutput = quietRun( cmd ) # If ip link set does not produce any output, then we can assume # that the link has been moved successfully. if cmdOutput: if printError: error( '*** Error: moveIntf: ' + intf + ' not successfully moved to ' + dstNode.name + ':\\n', cmdOutput ) return False return True 可以看到，透過指令ip link set %s netns %s，將特定的interface塞入特定Node的namespace之中 此時，我們的系統如下 Image 1 - 拓墣 最後OVSSwitch透過ovs-vsctl add-port將Switch上面的Interface都給OVS控管 node.py def attach( self, intf ): \"Connect a data port\" self.vsctl( 'add-port', self, intf ) self.cmd( 'ifconfig', intf, 'up' ) self.TCReapply( intf ) def vsctl( self, *args, **kwargs ): \"Run ovs-vsctl command (or queue for later execution)\" if self.batch: cmd = ' '.join( str( arg ).strip() for arg in args ) self.commands.append( cmd ) else: return self.cmd( 'ovs-vsctl', *args, **kwargs ) © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 03:50:27 mininet 什麼是 mininet 什麼是 SDN mininet 實戰 SDN 什麼是 SDN "}}