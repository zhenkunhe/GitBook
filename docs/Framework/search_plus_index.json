{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 03:50:27 "},"md/4-Alljoyn/1-Basic/Readme.html":{"url":"md/4-Alljoyn/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Alljoyn Framework tagsstop Properties GetAllProperties GetAll - a{sv} c++ © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/2-Gateway/1-架構說明.html":{"url":"md/4-Alljoyn/2-Gateway/1-架構說明.html","title":"架構說明","keywords":"","body":"架構說明 tagsstart Alljoyn Framework Gateway tagsstop 名詞定義 縮寫 描述 GM App Gateway Management app WKN Well-Know Name，有別於About的建立session方式 ACL Access Control List Config file 描述Alljoyn router的Policy(Allow or Deny) SLS Sessionless Signal 什麼是Alljoyn Gateway? 基於Alljoyn Framework所開發的一套Framework 主旨是快速開發一套：管理裝置行為、設定操作權限、雲端控制的一系列功能 講白一點，就是有一份XML，記錄著每個Alljoyn service內的成員們是否公開，或者是只允許被某個Alljoyn Client控制 接下來的內容，會將這份XML稱為ACL(Access Control List) Image 1 - ACL - Access Control List ACL實際上是去更新Alljoyn router的防火決策，而Alljoyn router把決策記錄在一份Configure file 將Alljoyn router視為一道防火牆，有一份通行決策(Configure file) Image 2 - Configure file ACL可以有很多份，但只有一份會生效(Activity) 在這Framework下，產生了三個負責不同職責的角色 Gateway Management app Connector app Control app 介紹一下角色的職責吧 在介紹職責之前，我必須要先講解我們想要的目標、架構與流程 我們希望可以透過網路來控制Device，無論區網或外網 區網：Control App透過Alljoyn機制直接控制Device 外網：Control App登入Cloud，並呼叫有註冊且在線的Connector來控制Device Image 3 - 架構 因此，我們需要有Control App,Connector App 再來，我想指定Alljoyn service的一部分成員公開，或只允許被某些Alljoyn Client控制 所以我要建立一份ACL，來更新Configure file 或是建立多份ACL，但只有一個生效 建立並修改ACL的工作，將交由使用者登入Control App後進行操作 基於安全因素，ACL只被允許在區網內透過Control App修改 而維護ACL，並更新Configure file的工作，交給GM app處理 Image 4 - 流程 GM App為了將當前配置上傳至Cloud，需要與Connector建立Non Session連線(透過WKN機制) 一個Connector對應一個Cloud，也對應一份目前正在運行的ACL Image 5 - 對應關係 基於安全因素，Connector與GM App是使用不同Linux User分別執行 GM App的職責是？ 管理ACL：透過About機制，使能被Control App搜尋並建立Session 更新Config File：根據ACL的啟動/關閉，來更新Config File Config File的機制為透過(Allow / Deny) Linux (User / Group) 來建立Alljoyn router Policy 提供列出ACL的Method給Connector呼叫 透過WKN與Connector建立Non Session連線 WKN是規格寫死的名稱： GM app WKN：org.alljoyn.GWAgent.GMApp Connector app WKN：org.alljoyn.GWAgent.Connector. Connector的職責是？ 與Cloud建立連線並傳輸/接收資料 在Config File允許的情況下，與Device互動 位於Cloud與Alljoyn Device的之間，將Alljoyn資料與Cloud資料做Protocol的轉換 透過GM App所發出的Signal來了解ACL是否已經被更新/刪除 透過GM App取得正在啟用的ACL Control App的職責是？ 以下所敘述的功能不一定全部包含，由服務提供商自行定義，有可能只包含一部分的功能 擁有建立/刪除/啟動/關閉/更新ACL的功能與UI介面 與服務提供商的Cloud建立User login的機制 控制Device行為 Alljoyn Router的職責是？ 正確執行Config File所記載的Policy Control App有什麼Secure機制嗎？ 由於GM App提供操作ACL的Interface必須是嚴格控管的，Control App要使用此Interface的Method前，必須輸入Password/PIN GM App應該內建Default的Password/PIN，並於Control App登入後，交由User自行修改 Image 6 - Secure Gateway的各項流程圖 Gateway Discover Image 7 - Gateway Discover 管理ACL Create ACL Image 8 - Create ACL Activate ACL Image 9 - Activate ACL Connector startup Image 10 - Connector startup Update ACL Image 11 - Update ACL Delete ACL Image 12 - Delete ACL Disable ACL Image 13 - Disable ACL Notification 送出 Notification Image 14 - 送出 Notification 接收 Notification Image 15 - 接收 Notification 控制AllJoyn Device 呼叫Method Image 16 - 呼叫Method Get property Image 17 - Get property Set property Image 18 - Set property Remoting session-based signal Image 19 - session-based signal 與ACL相關的成員 GM app管理ACL的部分 Method Create profile Activate profile Get profile GetProfileStatus GetProfileList Update profile Delete profile Deactivate profile Connector提供給外網的部分 Method Get profile Update connection status Signal Profile updated Profile deleted Shutdown App Config File Config File內的Policy應該要使GM App能收到所有設備的About(Default) GM App啟動時，應該基於已經安裝的Connector ID，建立Deny-all的Policy GM App應該根據ACL修改Config File內的Policy 當Active的ACL被Disable或是Delete時，GM App要移除與此ACL相關的Policy Policy可以Allow/Deny Connector發出Notification Policy可以Allow/Deny Connector接收某Device的Notification Policy可以Allow/Deny Connector對發出Signal Policy可以Allow/Deny Connector接收某Device的Signal Policy可以Allow/Deny Connector呼叫某Device的Method Config File的Policy會隨著Runtime而不斷改變 Config File的Reload有兩種方法，一種是取得Bus的ProxyBusObject並引用其Interface的Method；另一種是發送平台訊號(如Kill xxx)來觸發 GM App採用前者的方式 Connetor與Cloud的架構與設計 架構 服務提供商在Cloud端建立App Download Server，管理所有可供下載的Connector Package Control App於User login Cloud後，提供UI介面，便於User從App Download Server下載Connector Package，且提Install/Upgrade等UI介面。 基於上面的需求，GM App必須提供一個Interface給Control App，以便管理Connector Package的Install/Upgrade/Uninstall/Restart 基於安全考量，應由Package Manager(PM)管理需要安裝的Connector Package並驗證數位簽章是否符合 PM與GM App互動的實作與細節不在此討論內。 Image 20 - Cloud & Connector Install或其他Method被呼叫時，實際上Control App將URL傳給GM App，並交由PM下載、驗證、安裝並分配一個唯一Linux User給此Connector Package當作識別 每一個被安裝的Connector Package都有被分配到一個唯一的Linux User Connector Package被分配到的Linux User都屬於同一個Group GM App應該將已經安裝的Connector Package紀錄成一個表格，包含 Connector Id App Name App Package Name App version App package File URL App User Id App Group Id Install Status Install Description Connection Status Operational Status 所有Connector Package內，在預定位置必須含有manifest file，來描述此Connector提供的Service，以及預期能與之互動的Interface 設計細節 App Management interface Method Install App Uninstall App Restart App Get App Status Get Installed Apps Get Manifest Data Get Manifest Interfaces Signal App Status Changed Package Manager app functions Method Install App Uninstall App Manifest file Install App App Package Name App version Min AJ SDK version exposed Services List execution Info 外部連結： Alljoyn Gateway wiki © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/2-Gateway/2-啟動流程 & 程式碼.html":{"url":"md/4-Alljoyn/2-Gateway/2-啟動流程 & 程式碼.html","title":"啟動流程 & 程式碼","keywords":"","body":"啟動流程 & 程式碼 tagsstart Alljoyn Framework Gateway tagsstop 名詞定義 縮寫 描述 GM App Gateway Management app WKN Well-Know Name，有別於About的建立session方式 ACL Access Control List Config file 描述Alljoyn router的Policy(Allow or Deny) SLS Sessionless Signal Connector Code Initialize Bus At tachment：Start & Connect BusAttachment* bus = new BusAttachment(\"ConnectorApp\", true); bus->Start(); bus->Connect(); Initialize authentication：EnablePeerSecurity這個函數是用來啟動身分驗證與加密機制，使用前需要先Start。 keyListener.setPassCode(\"000000\"); String keystore = \"/opt/alljoyn/apps/\" + wellknownName + \"/store/.alljoyn_keystore.ks\"; bus.EnablePeerSecurity(\"ALLJOYN_PIN_KEYX ALLJOYN_SRP_KEYX ALLJOYN_ECDHE_PSK\", &keyListener, keystore.c_str(), false); 這裡所出現的keyListener是一種自定類別，繼承自AuthListener。 class SrpKeyXListener : public ajn::AuthListener SrpKeyXListener keyListener; 而AuthListener為啟動驗證機制時，負責傳達Password或其他與驗證機制相關的Class。 繼承AuthListener時，有幾種virtual method可以實作，其中比較常用的有RequestCredentials/AuthenticationComplete virtual bool RequestCredentials (const char *authMechanism, const char *peerName, uint16_t authCount, const char *userName, uint16_t credMask, >>Credentials &credentials) virtual void AuthenticationComplete (const char *authMechanism, const >>char *peerName, bool success)=0 以下用SrpKeyXListener改寫的內容做為範例： 首先是RequestCredentials bool SrpKeyXListener::RequestCredentials(const char* authMechanism, const char* authPeer,uint16_t authCount, const char* userId, uint16_t credMask, Credentials& creds) { std::cout 其中Credentials為AuthListener的Inner class，作為傳遞認證資訊的關鍵角色。 再來是AuthenticationComplete void SrpKeyXListener::AuthenticationComplete(const char* authMechanism, const char* authPeer, bool success) { std::cout 此處只有一行cout，表明認證結果。 當Interface的secure設為True，第一次調用此Interface下的任何member，都會產生認證要求。 以下是上述Code的認證執行輸出： RequestCredentials for authenticating org.alljoyn.GWAgent.GMApp using mechanism ALLJOYN_ECDHE_PSK RequestCredentials setPasscode to 000000 Authentication with ALLJOYN_ECDHE_PSK was successful Initialize Connector class MyApp : public GatewayConnector MyApp myApp(&bus, wellknownName.c_str()); myApp.init(); 繼承GatewayConnector時，有幾項Method需要實作。 virtual void shutdown() {…} virtual void mergedAclUpdated() {…} void receiveGetMergedAclAsync(QStatus unmarshalStatus,GatewayMergedAcl* response) {…} 基本上到目前為止，就已經完成一個Connector了。接著只需要跟Cloud互動，並在互動過程中適時的呼叫myApp.updateConnectionStatus(...)回報給GM App目前與雲端的連接狀態。GM App收到後，會發Signal給Controler，Controler收到後會呼叫GM AppInterface的Method取得狀態。 GatewayConnector這個Class透過WKN取得GM App的ProxyBusObject，其內部有2個Method與3個Signal，需要RegisterSignalHandler。 ifc->AddMethod(\"GetMergedAcl\", NULL, \"a(obas)a(saya(obas))\", \"exposedServices,remotedApps\"); ifc->AddMethod(\"UpdateConnectionStatus\", \"q\", NULL, \"connectionStatus\", MEMBER_ANNOTATE_NO_REPLY); ifc->AddSignal(\"MergedAclUpdated\", NULL, NULL); ifc->AddSignal(\"ShutdownApp\", NULL, NULL); Manifest.xml Build好Connector後的下一個工作，就是建置Manifest.xml了。Manifest.xml描述Connector的Service、感興趣的Interface、Connector執行時的參數傳入。 是之後Control App用以建立ACL的依據。 以下為Manifest.xml範例結構。 dummyapp1 dummyAppOne dummyAppOne_0.0.1-1_ar71xx.ipk 0.0.1 3.4.0 /emergency false org.alljoyn.Notification /warning false org.alljoyn.Notification / true org.alljoyn.Notification org.alljoyn.About org.alljoyn.Icon org.alljoyn.NotificationSuper org.alljoyn.Config alljoyn-gwconnectorsample /opt/alljoyn/apps/dummyapp1/lib 7 1 postTweet.sh 安裝Connector 有了Build好的Connector與Manifest.xml以後，接著就是安裝/移除Connector了。 安裝的第一步就是將lib、bin、Manifest.xml依照下列格式擺放。 之後將整包壓縮成一個tar檔案。 tar czf dummyApp1.tar.gz -C gatewayConnector/tar Image 1 - Alt text 接著透過官方提供的installPackage.sh/removePackage.sh進行安裝/移除 ./installPackage.sh dummyApp1.tar.gz installPackage.sh所做的事情很單純， 只是將tar檔裡的東西轉移到/opt/alljoyn/apps/$connectorId之中，然後創造一個Linux User，並將store這個Folder的擁有者，轉移到新創的Linux User下 baseDir=/opt/alljoyn manifestFile=$tmpDir/Manifest.xml appBinDir=$tmpDir/bin connectorId=$(grep \"\" $manifestFile | sed -e \"s/ *//\" | sed -e \"s///\") connectorAppDir=$baseDir/apps/$connectorId if [ $? -ne 0 ]; then useradd $connectorId || exit 22 createdUser=1 fi chown -R \"$connectorId\" \"$pkgInstallDir/store\" || exit 23 chmod -R a+rx \"$pkgInstallDir/bin\" || exit 24 chmod -R a+rx \"$pkgInstallDir/lib\" || exit 25 經過上面安裝後，就會看到/opt/alljoyn/apps/$connectorId目錄，結構如下。 此時acls Folder內無東西。可以透過shell自行創造，或是啟動GM App與Controller App後，透過Contorller App建立。 啟動 啟動Router 在啟動GM App與Connectors之前，先確定alljoyn-daemon是否已經安裝並啟動。 先確認是否Build好的alljoyn-daemon放在/usr/bin/中，並寫好alljoyn.init放在/etc/init.d/alljoyn之中。之後執行service alljoyn start 以下為alljoyn.init的start script start() { if [ -f $PIDFILE ] && kill -0 $(cat $PIDFILE); then echo 'Service already running' >&2 return 1 fi echo 'Starting service…' >&2 local CMD=\"$SCRIPT --config-file=/opt/alljoyn/alljoyn-daemon.d/config.xml &> \\\"$LOGFILE\\\" & echo \\$!\" su -c \"$CMD\" $RUNAS > \"$PIDFILE\" echo 'Service started' >&2 } 執行時所帶的參數--config-file指出Router Config Policy的位置，此例為/opt/alljoyn/alljoyn-daemon.d/config.xml 注意Config File內，要include GM App執行時動態改變的Policy File，此例為gwagent-config.xml alljoyn org.alljoyn.BusNode unix:abstract=alljoyn tcp:r4addr=0.0.0.0,r4port=0 5000 16 100 100 false /opt/alljoyn/alljoyn-daemon.d/gwagent-config.xml Config File內所有可用的的Tag，與每個Tag的說明，請參閱以下網址。 XML Schema Routing Node Configuration File 確認完成後，執行Router：service alljoyn start 啟動GM App 確認Config File 與start alljoyn-daemon以後，對於GM App我們也依法照做一次。 將Build好的alljoyn-gwagent放在/usr/bin/中，並寫好alljoyn-gwagent.init放在/etc/init.d/alljoyn-gwagent之中。之後執行service alljoyn-gwagent start 以下為alljoyn-gwagent.init的start script start() { if [ -f $PIDFILE ] && kill -0 $(cat $PIDFILE); then echo 'Service already running' >&2 return 1 fi echo 'Starting service…' >&2 local CMD=\"$SCRIPT &> \\\"$LOGFILE\\\" & echo \\$!\" su -c \"$CMD\" $RUNAS > \"$PIDFILE\" echo 'Service started' >&2 } 注意：雖然此例沒有使用，但事實上可以帶入參數--gwagent-policy-file指出GM App執行時動態產生的Config File，以及--apps-policy-dir指出根據ACL產生的Config File Folder 以下為GM App程式碼片段 String policyFileOption = \"--gwagent-policy-file=\"; String appsPolicyDirOption = \"--apps-policy-dir=\"; for (int i = 1; i setGatewayPolicyFile(policyFile.c_str()); } if (arg.compare(0, appsPolicyDirOption.size(), appsPolicyDirOption) == 0) { String policyDir = arg.substr(appsPolicyDirOption.size()); QCC_DbgPrintf((\"Setting appsPolicyDir to: %s\", policyDir.c_str())); gatewayMgmt->setAppPolicyDir(policyDir.c_str()); } } 例如： start() { service_start /usr/bin/alljoyn-gwagent `--gwagent-policy-file`=/etc/alljoyn/gwagent/gwagent.conf `--apps-policy-dir`=/etc/alljoyn/gwagent-apps } 如果沒有特別指明，則Default gwagent-policy-file：/opt/alljoyn/alljoyn-daemon.d/gwagent-config.xml apps-policy-dir：/opt/alljoyn/alljoyn-daemon.d/apps static const qcc::String GATEWAY_POLICIES_DIRECTORY = \"/opt/alljoyn/alljoyn-daemon.d\"; GatewayRouterPolicyManager::GatewayRouterPolicyManager() : m_AboutListenerRegistered(false), m_AutoCommit(false), m_gatewayPolicyFile(GATEWAY_POLICIES_DIRECTORY + \"/gwagent-config.xml\"), m_appPolicyDirectory(GATEWAY_POLICIES_DIRECTORY + \"/apps\") { } 下圖為此範例的目錄結構： config.xml： gwagent-config.xml： apps-policy-dir內的dummyapp1.xml： 確認完成後，執行GM App：service alljoyn-gwagent start 驗證 透過ps -ef | grep alljoyn指令驗證 目錄結構 /opt/alljoyn下的樹狀結構： Controller App畫面 進入搜尋到的GM App： 進入Connector's acl列表 允許Connector的服務： 含有此Connector感興趣的Interface的Device： 允許Connector存取此Device： ACL產生： 同時產生Config Policy： © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/4-Alljoyn/3-Allplay/Readme.html":{"url":"md/4-Alljoyn/3-Allplay/Readme.html","title":"Allplay","keywords":"","body":"Alljoyn - Allplay tagsstart Alljoyn Framework Allplay tagsstop 核心 BusObject Path: /net/allplay/MediaPlayer Interface: net.allplay.MediaPlayer 附加 BusObject Path: /net/allplay/MediaPlayer Interface: net.allplay.ZoneManager Interface: org.alljoyn.Control.Volume BusObject Path: /net/allplay/MediaPlayer/Playlist Interface: net.allplay.Playlist net.allplay.MediaPlayer XML Method Play Pause Resume Stop Previous Next SetPosition GetPlayerInfo GetPlaylist GetPlaylistInfo ForcedPrevious Properties EnabledControls Interruptible LoopMode PlayState ShuffleMode Version Signal EnabledControlsChanged EndOfPlayback InterruptibleChanged LoopModeChanged ShuffleMode Version Scenario start GetPlayerInfo GetEnabledControls GetInterruptible GetLoopMode GetPlayState GetShuffleMode GetVersion GetPlaylist() 設定撥放位置 Method - SetPosition(INT64 positionMsecs) signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 隨機撥放 Set - ShuffleMode - STRING SHUFFLE LINEAR signal - ShuffleModeChanged - STRING shuffleMode 循環模式 Set - LoopMode - STRING ONE NONE ALL signal - LoopModeChanged - STRING loopMode Resume Method - Resume() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 新增歌曲到Playlist Method - UpdatePlaylist playlistItems public string Album { get; set; } public string Artist { get; set; } public long Duration { get; set; } public string Genre { get; set; } public string MediaType { get; set; } public IDictionary MediumDesc { get; set; } public IDictionary OtherData { get; set; } public string ThumbnailUrl { get; set; } public string Title { get; set; } public string Url { get; set; } public object UserData { get; set; } ` Album=幸福了 然後呢 Duration=286000 Genre=Pop Artist=A-Lin & 小宇 MediaType=audio MediumDesc=System.ComObject OtherData=System.ComObject ThumbnailUrl=http://192.168.1.20:10508/download/thumb.jpg?id=8285275079956195101 Title=920 Url=http://192.168.1.20:10508/download/item.mp3?id=8285275079956195101` signal - PlayListChanged - VOID Method - GetPlaylist Method - Play() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Pause Method - Pause() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Next Method - Next() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Previous Method - Previous() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 移除PlayList Method - UpdatePlaylist Method - GetPlaylist signal - PlayListChanged - VOID 連線失敗 signal - OnPlaybackError - Volume 調整音量 Set - Volume - INT16 Volume : 0~100 signal - VolumeChanged - INT16 newVolume newVolume : 0-100 Pega-Gateway Event Play In { \"itemIndex\":Int \"startPositionMsecs\":Int64 \"pauseStateOnly\":Bool } Out {} Previous In {} Out {} Pause In {} Out {} Resume In {} Out {} Stop In {} Out {} Next In {} Out {} UpdatePlaylist In { \"playlistItems\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] \"index\":Int \"controllerType\":String \"playlistUserData\":String } Out {} SetPosition In { \"positionMsecs\":Int64 } Out {} ForcedPrevious In {} Out {} CreateZone In { \"players\": [ String ] } Out { \"zoneId\":String \"timestamp\":Int \"failedPlayers\": { String:Int } } SetZoneLead In { \"zoneId\":String \"timeServerIp\":String \"timeServerPort\":Uint16 } Out { \"timestamp\":Int } Pega-Gateway Get-Parameter GetPlayerInfo { \"displayName\":String \"capabilities\": [ String ] \"maximumVolume\":Int \"zoneInfo\": { \"zoneId\":String \"zone_timestamp\":Int \"player_known_name\":??? } } GetPlaylist { \"items\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] \"controllerType\":String \"playlistUserData\":String } GetPlaylistInfo { \"controllerType\":String \"playlistUserData\":String } GetPlayState { \"playstate\":String \"position\":Int64 \"current_sample_rate\":uint32 \"audio_channels\":uint32 \"bits_per_sample\":uint32 \"index_current_item\":Int64 \"index_next_item\":Int64 \"items\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] } EnabledControls: [ \"???\":String \"???\":Bool ] GetInterruptible:Bool GetLoopMode : String (ONE,ALL,NONE) GetShuffleMode : String (LINEAR,SHUFFLE) GetAllplayVersion : Uint16 GetVolume : Int16 GetMute : Bool GetVolumeRange : { \"Low\":Int16 \"High\":Int16 \"Increment\":Int16 } GetVolumeEnabled : Bool GetZoneManagerEnabled:Bool Pega-Gateway Set-Parameter SetLoopMode : String (ONE,ALL,NONE) SetShuffleMode : String (LINEAR,SHUFFLE) SetVolume : Int16 SetMute : Bool © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 03:50:27 Alljoyn Basic 架構說明 啟動流程 & 程式碼 Allplay Framework Basic 架構說明 啟動流程 & 程式碼 Allplay Gateway 架構說明 啟動流程 & 程式碼 Allplay Allplay "}}