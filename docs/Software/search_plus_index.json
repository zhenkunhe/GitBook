{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 03:47:18 "},"md/2-Mininet/1-什麼是 mininet/":{"url":"md/2-Mininet/1-什麼是 mininet/","title":"什麼是 mininet","keywords":"","body":"什麼是 mininet tagsstart mininet tagsstop 什麼是 mininet mininet是一個用python寫的一個Process 這個Process是一個網路模擬器(network emulator) 或者更精確的說：網路拓樸模擬器(network emulation orchestration system) 既然叫拓樸模擬器，代表它模擬了一整個:終端主機(end-hosts),路由器(router),交換器(switches)的集成系統 模擬網路系統可以做什麼？ 通常透過mininet模擬的架構,會與實際透過硬體架設的結果一致，因此可做為實體配線前的臨摹 mininet模擬的host行為跟真的一樣：你可以SSH(Secure Shell)進去並運行任意程式，也可以運行server 你也可以送出封包，就像透過真的乙太網路出去，有link speed & delay，可以觀察封包來往的狀況 可以輕易的製作支援SDN的區域網路 (後面會介紹什麼是SDN)，事實上，mininet是很適合作為一個輕量級的SDN仿真工具 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/2-什麼是 SDN/":{"url":"md/2-Mininet/2-什麼是 SDN/","title":"什麼是 SDN","keywords":"","body":"什麼是 SDN tagsstart mininet SDN tagsstop 什麼是 SDN？ 全名是：軟體定義式網路（Software defined Networking，SDN） 要了解SDN之前，要先了解現今網路架構中，路由器除了硬體上俱備有轉送資料的能力外， 對於資料的移動控制，都是在每一台路由器中， 實作著遵守各種傳輸協定的控制軟體 例如連結層有擴展樹協定（Spanning Tree Protocol，STP）來防止封包卡在迴圈 雖然協定是共通的，但網通廠商各有各的OS與實作技術，導致一旦企業購買某一廠牌的設備， 未來更新設備時就必須遷就於該廠牌的網管功能，造成被網通廠商挾持的情形 現今這樣不是沒什麼問題嘛？ 隨著隨著雲端應用及巨量資料增加，路由表越來越龐大，判斷轉送的過程愈來愈複雜 而這些判斷需要路徑上的每一台交換器或是路由器不斷的拆分及重組封包 可想而知，結果導致傳輸效率不佳，無法有效發揮網路頻寬 網路管理人員需要客製調整各種網路設定時，也必須針對每臺交換器或路由器，逐一登入command-line設定，相當麻煩 而且透過人工逐一設定的方式也有很高的風險，一旦網路管理人員輸入了錯誤的指令，很容易造成網路服務癱瘓 於是關於控制封包這件事情，我們需要重新思考：真的需要每一台路由器拆開封包才能判斷嘛？ 所以SDN做了什麼？ 它的概念是：將網路分為控制層（Control Plane）與資料層（Data Plane） 將網路的管理權限交由控制層的控制器（Controller）軟體負責，採用集中控管的方式，同時也負責決定傳輸路徑 Image 1 - SDN SDN帶來的好處？ 讓網路的管理變得更集中 自動處理與動態因應變化 讓網路的設計、部署、管理、規模延展更為容易 可以減少IT服務日常維運，減少人為出錯 既然傳輸路徑已預先設定完成，交換器不需要透過不斷學習來尋找封包傳送的路徑，可大幅提升傳輸效率，降低延遲（Latency）的時間 可節省支出 所以網通廠怎麼看SDN？ SDN使得交換器的重要性將會不如以往 (功能會越來越單純，未來可能僅負責封包的傳送) 未來客製化的軟體就可以提供各項硬體設備的功能 於硬體設備廠商來說，將會是一大衝擊 臺灣企業還不了解SDN在未來的重要性，而且開發SDN應用程式的門檻較高 Google、Facebook、Yahoo、微軟等多家指標型的大企業投入了SDN架構與OpenFlow技術的發展 我剛好像看到OpenFlow，那是什麼？ 跟SDN是什麼關係 OpenFlow是實現SDN架構最主流的核心技術，也就是網路交換器(switch)和控制器(controller)之間的傳輸協定 就像是人類的神經一樣，負責大腦與四肢的溝通 OpenFlow技術將封包傳送的路徑看成是一條「Flow」，就好像是專屬的傳輸路徑 例如經過哪些交換器，需要多少的網路頻寬，再將傳輸路徑設定成OpenFlow路由表（Flow Table） 控制層和資料層之間，利用SSL加密，建立起安全的傳輸通道 但它只是整體SDN架構的一部分，而且也並非唯一可用的協定 OpenFlow是SDN的一部分，但SDN不是只有OpenFlow Image 2 - OpenFlow © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/3-mininet 實戰/":{"url":"md/2-Mininet/3-mininet 實戰/","title":"mininet 實戰","keywords":"","body":"mininet 實戰 tagsstart mininet tagsstop 安裝 Debian Package sudo apt-get install mininet Build source and install git clone git://github.com/mininet/mininet mininet/util/install.sh -a 啟動 在沒有任何參數下，產生的虛擬環境為兩個host (h1,h2)，一個switch (s1)，並將h1,h2連接s1 Image 1 - Topology 啟動sudo mn Image 2 - mn mininet是基於OVS的應用軟體，當沒有設定OVS Controller時，他會退回OVS Bridge模式(不依賴Controller，預設所有node都是可以連通的) OVS:全名Open vSwitch，類似VM，主要是虛擬switch，支援OpenFlow 測試 顯示所有節點nodes Image 3 - nodes 顯示所有節點的連接關係net Image 4 - net 察看所有節點的資訊:dump Image 5 - dump 用h1 ping h2 一個封包h1 ping -c 1 h2 Image 6 - ping 叫出兩個host的命令視窗xterm h1 h2 Image 7 - xterm Mininet Python API Topo: Mininet拓撲結構的base class build(): The method to override in your topology class. Constructor parameters (n) will be passed through to it automatically by Topo.init(). addSwitch(): 給拓撲結構中增加一個switch，返回switch名字 addHost(): 增加host，返回host名字 addLink(): 增加一個雙向link，返回link的key Mininet: 建立和管理網路的main class start(): 開啟網路 pingAll(): 通過host之間的互ping測試連通性 stop(): 關閉網絡 net.hosts: 網路中的所有主機 dumpNodeConnections(): 所有的連接關係 setLogLevel( 'info' | 'debug' | 'output' ): set Mininet's default output level; 'info' is recommended as it provides useful information. 寫一個Python範例 目標 啟動50個hosts，作為VM server farm 啟動1個controller 啟動1個switch Image 8 - Server Farm Code example #!/usr/bin/python import re from mininet.net import Mininet from mininet.node import Controller from mininet.cli import CLI from mininet.link import Intf from mininet.log import setLogLevel, info, error from mininet.util import quietRun from mininet.node import OVSController def checkIntf( intf ): \"Make sure intf exists and is not configured.\" if ( ' %s:' % intf ) not in quietRun( 'ip link show' ): error( 'Error:', intf, 'does not exist!\\n' ) exit( 1 ) ips = re.findall( r'\\d+\\.\\d+\\.\\d+\\.\\d+', quietRun( 'ifconfig ' + intf ) ) if ips: error( 'Error:', intf, 'has an IP address and is probably in use!\\n' ) exit( 1 ) def myNetwork(): net = Mininet( topo=None, build=False) info( '*** Adding controller\\n' ) net.addController(name='c0',controller = OVSController) info( '*** Add switches\\n') s1 = net.addSwitch('s1') max_hosts = 50 newIntf = 'enp3s0' host_list = {} info( '*** Add hosts\\n') for i in xrange(1,max_hosts+1): host_list[i] = net.addHost('h'+str(i)) info( '*** Add links between ',host_list[i],' and s1 \\r') net.addLink(host_list[i], s1) info( '*** Checking the interface ', newIntf, '\\n' ) checkIntf( newIntf ) switch = net.switches[ 0 ] info( '*** Adding', newIntf, 'to switch', switch.name, '\\n' ) brintf = Intf( newIntf, node=switch ) info( '*** Starting network\\n') net.start() CLI(net) net.stop() if __name__ == '__main__': setLogLevel( 'info' ) myNetwork() 執行 sudo python example.py Image 9 - example Q&A 執行出現Cannot find required executable ovs-controller 你沒有安裝ovs-controller sudo apt-get install openvswitch-testcontroller ovs-controller是舊名稱，所以你需要複製一下 sudo cp /usr/bin/ovs-testcontroller /usr/bin/ovs-controller 執行出現 Exception: Please shut down the controller which is running on port 6653: Active Internet connections (servers and established) tcp 0 0 0.0.0.0:6653 0.0.0.0:* LISTEN 30215/ovs-testcontr 你需要kill正在背景執行的ovs-testcontroller sudo netstat -lptu sudo service ovs-testcontroller stop Mininet建立網路的三種方式 底層API Node & Link h1 = Host( 'h1' ) h2 = Host( 'h2' ) s1 = OVSSwitch( 's1', inNamespace=False ) c0 = Controller( 'c0', inNamespace=False ) Link( h1, s1 ) Link( h2, s1 ) h1.setIP( '10.1/8' ) h2.setIP( '10.2/8' ) c0.start() s1.start( [ c0 ] ) print h1.cmd( 'ping -c1', h2.IP() ) s1.stop() c0.stop() 中層API net Object net = Mininet() h1 = net.addHost( 'h1' ) h2 = net.addHost( 'h2' ) s1 = net.addSwitch( 's1' ) c0 = net.addController( 'c0' ) net.addLink( h1, s1 ) net.addLink( h2, s1 ) net.start() print h1.cmd( 'ping -c1', h2.IP() ) CLI( net ) net.stop() 上層API Topology Object class SingleSwitchTopo( Topo ): \"Single Switch Topology\" def __init__( self, count=1, **params ): Topo.__init__( self, **params ) hosts = [ self.addHost( 'h%d' % i ) for i in range( 1, count + 1 ) ] s1 = self.addSwitch( 's1' ) for h in hosts: self.addLink( h, s1 ) net = Mininet( topo=SingleSwitchTopo( 3 ) ) net.start() CLI( net ) net.stop() © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/1-Network Namespace.html":{"url":"md/2-Mininet/4-運作原理/1-Network Namespace.html","title":"Network Namespace","keywords":"","body":"Network Namespace Mininet虛擬化的核心機制是？ Linux Network Namespace是Mininet軟體架構的基石，用其創建虛擬節點 需要先了解Linux Namespace 之中的 Network Namespaces 預設情況下，Mininet會為每一個host創建一個新的Network Namespaces 由於每個host都有各自獨立的Network Namespaces，我們就可以進行個性化的網路配置和程式佈署 Switch和Controller運行在root Namespace，因此兩個Processes共享同一個Network Namespaces 由於Linux Namespace的虛擬技術沒有提供類似於VM的持久化能力，所以在Mininet關閉時不能保存所有設定 Mininet建立的Network namespace是nameless的，所以透過ip netns list是查看不到的 而透過ip netns add建立的Network Namespace是帶name的，這是兩者最明顯的區別之處Discussions Linux Network Namespace在OpenStack和Docker等開源項目中也廣泛應用主要用於作業系統層級的虛擬化，包含虛擬網路 解釋一下，上一個的範例與namespace的關聯 範例中Host H1和Host H2連接到運行在Kernel的root namespace的Switch S1 H1和H2擁有自己的網路匿名命名空間以及私有網路接口h1-eth0和h2-eth0 S1有兩個埠s1-eth1和s1-eth2，通過veth pair與Host接口相連，這樣H1和H2就可以透過S1進行交流 s1-eth0和s1-eth1間的data轉發透過S1完成，並使用實體接口eth0，等待Controller的指令 Image 1 - Example1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/2-Node.html":{"url":"md/2-Mininet/4-運作原理/2-Node.html","title":"Node","keywords":"","body":"Node Node是什麼？ 每個Host其實就是一個Node的物件，可以在node.py中看到此物件的定義 node.py class Node( object ): portBase = 0 # Nodes always start with eth0/port0, even in OF 1.0 def __init__( self, name, inNamespace=True, **params ): self.checkSetup() self.name = params.get( 'name', name ) self.privateDirs = params.get( 'privateDirs', [] ) self.inNamespace = params.get( 'inNamespace', inNamespace ) ... # Start command interpreter shell self.startShell() self.mountPrivateDirs() inToNode = {} # mapping of input fds to nodes outToNode = {} # mapping of output fds to nodes 初始時，會有一個變數inNamespace用來決定此Host是否要透過network namespaces來達到network isolation的功能 當變數都初始化後，就會呼叫startShell()來啟動此Host node.py def startShell( self, mnopts=None ): \"Start a shell process for running commands\" if self.shell: error( \"%s: shell is already running\\n\" % self.name ) return # mnexec: (c)lose descriptors, (d)etach from tty, # (p)rint pid, and run in (n)amespace opts = '-cd' if mnopts is None else mnopts if self.inNamespace: opts += 'n' # bash -i: force interactive # -s: pass $* to shell, and make process easy to find in ps # prompt is set to sentinel chr( 127 ) cmd = [ 'mnexec', opts, 'env', 'PS1=' + chr( 127 ), 'bash', '--norc', '-is', 'mininet:' + self.name ] master, slave = pty.openpty() self.shell = self._popen( cmd, stdin=slave, stdout=slave,stderr=slave,close_fds=False ) ... 可以觀察到，mininet是透過一隻叫做mnexec的程式來執行，並且透過參數-n來將此process給轉換到network namespaces中 所以建立完Host以後，可以使用ip來看？ 理論上我們要可以透過ip netns show來看到這些network namespaces，實際上卻看不到 原因如同此篇所說，由於建立的為nameless network namespaces Host是Node，那Switch呢？ 建立Switch包含了四種選擇OVSLegacyKernelSwitch、UserSwitch、OVSSwitch，IVSSwitch 一般常用的就是OVSSwitch 這四種Switch都繼承自Switch物件，而Switch物件則繼承自Node © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/3-Link.html":{"url":"md/2-Mininet/4-運作原理/3-Link.html","title":"Link","keywords":"","body":"Link 接下來會根據拓墣的Link情況，去創建對應的Interface 首先，這邊使用到Link這個物件來表示每一條Link 每個Link實際上對應到的是兩個Node上面的Interface link.py class Link( object ): \"\"\"A basic link is just a veth pair. Other types of links could be tunnels, link emulators, etc..\"\"\" # pylint: disable=too-many-branches def __init__( self, node1, node2, port1=None, port2=None, intfName1=None, intfName2=None, addr1=None, addr2=None, intf=Intf, cls1=None, cls2=None, params1=None, params2=None, fast=True ): \"\"\"Create veth link to another node, making two new interfaces. node1: first node node2: second node port1: node1 port number (optional) port2: node2 port number (optional) intf: default interface class/constructor cls1, cls2: optional interface-specific constructors intfName1: node1 interface name (optional) intfName2: node2 interface name (optional) params1: parameters for interface 1 params2: parameters for interface 2\"\"\" # This is a bit awkward; it seems that having everything in # params is more orthogonal, but being able to specify # in-line arguments is more convenient! So we support both. if params1 is None: params1 = {} if params2 is None: params2 = {} # Allow passing in params1=params2 if params2 is params1: params2 = dict( params1 ) if port1 is not None: params1[ 'port' ] = port1 if port2 is not None: params2[ 'port' ] = port2 if 'port' not in params1: params1[ 'port' ] = node1.newPort() if 'port' not in params2: params2[ 'port' ] = node2.newPort() if not intfName1: intfName1 = self.intfName( node1, params1[ 'port' ] ) if not intfName2: intfName2 = self.intfName( node2, params2[ 'port' ] ) self.fast = fast if fast: params1.setdefault( 'moveIntfFn', self._ignore ) params2.setdefault( 'moveIntfFn', self._ignore ) self.makeIntfPair( intfName1, intfName2, addr1, addr2, node1, node2, deleteIntfs=False ) 這邊要觀察到的，Link物件會呼叫makeIntfPair此方法，此方法就可以將兩個Interface給串接起來 util.py def makeIntfPair( intf1, intf2, addr1=None, addr2=None, node1=None, node2=None, deleteIntfs=True, runCmd=None ): \"\"\"Make a veth pair connnecting new interfaces intf1 and intf2 intf1: name for interface 1 intf2: name for interface 2 addr1: MAC address for interface 1 (optional) addr2: MAC address for interface 2 (optional) node1: home node for interface 1 (optional) node2: home node for interface 2 (optional) deleteIntfs: delete intfs before creating them runCmd: function to run shell commands (quietRun) raises Exception on failure\"\"\" if not runCmd: runCmd = quietRun if not node1 else node1.cmd runCmd2 = quietRun if not node2 else node2.cmd if deleteIntfs: # Delete any old interfaces with the same names runCmd( 'ip link del ' + intf1 ) runCmd2( 'ip link del ' + intf2 ) # Create new pair netns = 1 if not node2 else node2.pid if addr1 is None and addr2 is None: cmdOutput = runCmd( 'ip link add name %s ' 'type veth peer name %s ' 'netns %s' % ( intf1, intf2, netns ) ) else: cmdOutput = runCmd( 'ip link add name %s ' 'address %s ' 'type veth peer name %s ' 'address %s ' 'netns %s' % ( intf1, addr1, intf2, addr2, netns ) ) if cmdOutput: raise Exception( \"Error creating interface pair (%s,%s): %s \" % ( intf1, intf2, cmdOutput ) ) 這邊可以看到，mininet實際上是透過系統中的ip link的方法，將兩個interface創造一條veth的Link 此時，我們的系統如下 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/2-Mininet/4-運作原理/4-Interface.html":{"url":"md/2-Mininet/4-運作原理/4-Interface.html","title":"Interface","keywords":"","body":"Interface 接下來我們要把這些interface給綁到特定的Node身上 在Link物件初始化後段，會去初始化兩個Interface真正的物件本體 link.py class Intf( object ): \"Basic interface object that can configure itself.\" def __init__( self, name, node=None, port=None, link=None, mac=None, **params ): \"\"\"name: interface name (e.g. h1-eth0) node: owning node (where this intf most likely lives) link: parent link if we're part of a link other arguments are passed to config()\"\"\" self.node = node self.name = name self.link = link self.mac = mac self.ip, self.prefixLen = None, None # if interface is lo, we know the ip is 127.0.0.1. # This saves an ifconfig command per node if self.name == 'lo': self.ip = '127.0.0.1' # Add to node (and move ourselves if necessary ) moveIntfFn = params.pop( 'moveIntfFn', None ) if moveIntfFn: node.addIntf( self, port=port, moveIntfFn=moveIntfFn ) else: node.addIntf( self, port=port ) # Save params for future reference self.params = params self.config( **params ) 這邊要觀察的重點是每個Interface都會去呼叫node.addIntf( self, port=port )來處理 node.py def addIntf( self, intf, port=None, moveIntfFn=moveIntf ): \"\"\"Add an interface. intf: interface port: port number (optional, typically OpenFlow port number) moveIntfFn: function to move interface (optional)\"\"\" if port is None: port = self.newPort() self.intfs[ port ] = intf self.ports[ intf ] = port self.nameToIntf[ intf.name ] = intf debug( '\\n' ) debug( 'added intf %s (%d) to node %s\\n' % ( intf, port, self.name ) ) if self.inNamespace: debug( 'moving', intf, 'into namespace for', self.name, '\\n' ) moveIntfFn( intf.name, self ) 此方法最後會呼叫moveIntf來將該interface給處理，moveIntf則會呼叫moveIntfNoRetry將Interface給綁入到每個Node中 util.py def moveIntf( intf, dstNode, printError=True, retries=3, delaySecs=0.001 ): \"\"\"Move interface to node, retrying on failure. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" retry( retries, delaySecs, moveIntfNoRetry, intf, dstNode, printError=printError ) def moveIntfNoRetry( intf, dstNode, printError=False ): \"\"\"Move interface to node, without retrying. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" intf = str( intf ) cmd = 'ip link set %s netns %s' % ( intf, dstNode.pid ) cmdOutput = quietRun( cmd ) # If ip link set does not produce any output, then we can assume # that the link has been moved successfully. if cmdOutput: if printError: error( '*** Error: moveIntf: ' + intf + ' not successfully moved to ' + dstNode.name + ':\\n', cmdOutput ) return False return True 可以看到，透過指令ip link set %s netns %s，將特定的interface塞入特定Node的namespace之中 此時，我們的系統如下 Image 1 - 拓墣 最後OVSSwitch透過ovs-vsctl add-port將Switch上面的Interface都給OVS控管 node.py def attach( self, intf ): \"Connect a data port\" self.vsctl( 'add-port', self, intf ) self.cmd( 'ifconfig', intf, 'up' ) self.TCReapply( intf ) def vsctl( self, *args, **kwargs ): \"Run ovs-vsctl command (or queue for later execution)\" if self.batch: cmd = ' '.join( str( arg ).strip() for arg in args ) self.commands.append( cmd ) else: return self.cmd( 'ovs-vsctl', *args, **kwargs ) © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/3-Docker/1-Basic/Readme.html":{"url":"md/3-Docker/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Docker tagsstop Introduction sudo docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb ubuntu:14.04 /bin/bash sudo docker exec -u root -it compassionate_snyder bash 'su' command in Docker returns 'must be run from terminal' When you are ssh-ing in or going in via php your session is not being allocated a pty. I have used each of the following solutions: ANSWER 3: use python to spawn a pty in your shell Quite a cute hack :) jenkins@e9fbe94d4c89:~$ su - su: must be run from a terminal $ echo \"import pty; pty.spawn('/bin/bash')\" > /tmp/asdf.py $ python /tmp/asdf.py $ su - Password: root@e9fbe94d4c89:~# 什麼是 Docker Docker 是一個開源專案，誕生於 2013 年初，最初是 dotCloud 公司內部的一個業餘專案。它基於 Google 公司推出的 Go 語言實作。 專案後來加入了 Linux 基金會，遵從了 Apache 2.0 協議，原始碼在 GitHub 上進行維護。 Docker 自開源後受到廣泛的關注和討論，以至於 dotCloud 公司後來都改名為 Docker Inc。Redhat 已經在其 RHEL6.5 中集中支援 Docker；Google 也在其 PaaS 產品中廣泛應用。 Docker 專案的目標是實作輕量級的作業系統虛擬化解決方案。 Docker 的基礎是 Linux 容器（LXC）等技術。 在 LXC 的基礎上 Docker 進行了進一步的封裝，讓使用者不需要去關心容器的管理，使得操作更為簡便。使用者操作 Docker 的容器就像操作一個快速輕量級的虛擬機一樣簡單。 下面的圖片比較了 Docker 和傳統虛擬化方式的不同之處，可見容器是在作業系統層面上實作虛擬化，直接使用本地主機的作業系統，而傳統方式則是在硬體層面實作。 Image 1 - 1 Image 2 - 2 How To Install and Use Docker on Ubuntu 16.04 sudo apt-get update sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D echo \"deb https://apt.dockerproject.org/repo ubuntu-xenial main\" | sudo tee /etc/apt/sources.list.d/docker.list sudo apt-get update apt-cache policy docker-engine docker-engine: Installed: (none) Candidate: 1.11.1-0~xenial Version table: 1.11.1-0~xenial 500 500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages 1.11.0-0~xenial 500 500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages sudo apt-get install -y docker-engine sudo systemctl status docker ● docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2016-05-01 06:53:52 CDT; 1 weeks 3 days ago Docs: https://docs.docker.com Main PID: 749 (docker) Install ubuntu oem@Alex:~$ sudo docker pull ubuntu [sudo] password for oem: Using default tag: latest latest: Pulling from library/ubuntu f069f1d21059: Pull complete ecbeec5633cf: Pull complete ea6f18256d63: Pull complete 54bde7b02897: Pull complete Digest: sha256:bbfd93a02a8487edb60f20316ebc966ddc7aa123c2e609185450b96971020097 Status: Downloaded newer image for ubuntu:latest 列出本機映像檔 $ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 12.04 74fe38d11401 4 weeks ago 209.6 MB ubuntu precise 74fe38d11401 4 weeks ago 209.6 MB ubuntu 14.04 99ec81b80c55 4 weeks ago 266 MB ubuntu latest 99ec81b80c55 4 weeks ago 266 MB ubuntu trusty 99ec81b80c55 4 weeks ago 266 MB 創造容器 sudo docker run -ti utuntu:14.04 bash 啟動容器 sudo docker start nostalgic_hypatia 進入容器 sudo docker exec -ti nostalgic_hypatia bash sudo docker attach nostalgic_hypatia 查看容器 oem@Alex:~$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8dd510fc3be5 ubuntu:14.04 \"/bin/bash\" About a minute ago Exited (0) About a minute ago happy_fermat 091a9c73d24e ubuntu:14.04 \"/bin/bash\" 57 minutes ago Up 57 minutes gigantic_knuth 刪除容器 oem@Alex:~$ sudo docker rm happy_fermat happy_fermat cp到容器內 sudo docker cp gstreamer_example/ gigantic_knuth:/ rename容器 sudo docker rename OLD_NAME NEW_NAME scratch -> debian -> busybox 如何進到docker container file system: start container get root if [ -z \"$1\" ] ; then echo 'docker-find-root $container_id_or_name ' exit 1 fi CID=$(docker inspect --format {{.Id}} $1) if [ -n \"$CID\" ] ; then if [ -f /var/lib/docker/image/aufs/layerdb/mounts/$CID/mount-id ] ; then F1=$(cat /var/lib/docker/image/aufs/layerdb/mounts/$CID/mount-id) d1=/var/lib/docker/aufs/mnt/$F1 fi if [ ! -d \"$d1\" ] ; then d1=/var/lib/docker/aufs/diff/$CID fi echo $d1 3, cd root path © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/9-IDE/1-Xcode/Readme.html":{"url":"md/9-IDE/1-Xcode/Readme.html","title":"Xcode","keywords":"","body":"Xcode tagsstart IDE Xcode Mac Software tagsstop 快捷鍵 CTRL+I：格式化程式碼 command + /：註解單行 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/9-IDE/2-Eclipse/Readme.html":{"url":"md/9-IDE/2-Eclipse/Readme.html","title":"Eclipse","keywords":"","body":"Eclipse tagsstart IDE Eclipse Software tagsstop 快捷鍵 ctrl+o：快速outline F3: 打开申明（Open declaration） Ctrl+Shift+F 格式化当前代码 Ctrl + Shift + O: 引入imports语句 ALT+/ 提示 Alt+←】、【Alt+→】 后退历史记录和前进历 Ctrl+M窗口最大化和还原 Ctrl + D : 删除本行 Ctrl + / : 注释本行 cmake -G\"Eclipse CDT4 - Unix Makefiles\" -D CMAKE_BUILD_TYPE=Debug -D CMAKE_ECLIPSE_VERSION=4.6 . Initializer Format(line wrapping) constructor initializer list in Eclipse CDT Click on: Window -> Preferences Go to: C/C++ -> Code Style -> Formatter Here, as first thing you have to create a new profile. Select tab: Line Wrapping Go to: Function declarations -> Constructor initializer list On the bottom, you have to set: Line wrapping policy: Wrap all elements, every element on a new line. check \"Force split, even if line is shorter than maximum\" Indentation policy: indent on column © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/93-Gstreamer/1-Basic/Readme.html":{"url":"md/93-Gstreamer/1-Basic/Readme.html","title":"Basic","keywords":"","body":"GStreamer tagsstart GStreamer Voice Video tagsstop 前言 pipeline Bins elements source pads sink pads GstBuffer from sources to sinks ((downstream) GstEvent upstream and downstream , 可以從application to element queries messages Image 1 - 1 Image 2 - 2 Image 3 - 3 code $(CC) --silent --tag=CC --mode=link -o $@ -lrt -ldl gst_init (&argc, &argv); gst_version (&major, &minor, &micro, &nano); GST_VERSION_MAJOR GST_VERSION_MINOR GST_VERSION_MICRO GstElement *element; element = gst_element_factory_make (\"fakesrc\", \"source\"); gst_object_unref (GST_OBJECT (element)); gchar *name; g_object_get (G_OBJECT (element), \"name\", &name, NULL); g_free (name); gst_pipeline_new gst_pipeline_get_bus gst_bus_add_watch g_main_loop_new g_main_loop_run gst_pipeline_new bus/message pipeline message handler - mainloop gchar *debug; GError *error; gst_message_parse_error (msg, &error, &debug); g_free (debug); g_printerr (\"Error: %s\\n\", error->message); g_error_free (error); End-of-stream Error Tags State-changes Buffering Element messages Application-specific messages gst_bin_add_many gst_element_link gst_element_link_many g_warning bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline); gst_bus_add_signal_watch (bus); g_signal_connect (bus, \"message::error\", G_CALLBACK (cb_message_error), NULL); g_signal_connect (bus, \"message::eos\", G_CALLBACK (cb_message_eos), NULL); gst_element_get_static_pad (decoder, \"sink\"); gst_pad_link (pad, sinkpad); pad = always sometimes未知來源 ,on request聚合器 ＆Tee elements（複製） gst_element_link (source, demuxer); gst_element_link_many (decoder, conv, sink, NULL); g_signal_connect (demuxer, \"pad-added\", G_CALLBACK (on_pad_added), decoder); pad = gst_element_get_request_pad (tee, \"src%d\"); name = gst_pad_get_name (pad); gst_element_get_pad_list() 調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。 gst_element_get_compatible_pad (mux, tolink_pad); gst_pad_link (tolinkpad, pad); gst_element_set_state GST_STATE_NULL GST_STATE_READY GST_STATE_PAUSED GST_STATE_PLAYING Capabilities 目標 Autoplugging Compatibility detection Metadata Filtering ：audioconvert, audioresample, ffmpegcolorspace or videoscale const GstStructure *str; str = gst_caps_get_structure (caps, 0); if (!gst_structure_get_int (str, \"width\", &width) || !gst_structure_get_int (str, \"height\", &height)) { g_print (\"No width/height available\\n\"); return; } gst_element_link_filtered (demuxer, decoder, caps); struct _GstCaps { gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ }; gst_caps_get_name (cap), gst_caps_get_mime (cap)); 在GStreamer應用程序中使用的箱櫃主要有兩種類型： GstPipeline管道是最常用到的容器，對於一個GStreamer應用程序來講，其頂層箱櫃必須是一條管道。 GstThread線程的作用在於能夠提供同步處理能力，如果GStreamer應用程序需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。 GstElement *thread, *pipeline; //創建線程對象，同時為其指定唯一的名稱。 thread = gst_element_factory_make (\"thread\", NULL); //根據給出的名稱，創建一個特定的管道對象。 pipeline = gst_pipeline_new (\"pipeline_name\"); 箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對象，但由於其自身也是一個GstElement對象 而要從箱櫃中找到特定的元件也很容易，可以藉助gst_bin_get_by_name()函數實現： GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), \"decoder\"); gst_bin_remove() 由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況 具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程序中能夠像使用元件一樣使用這類箱櫃。下面的代碼示範瞭如何為箱櫃添加一個精靈襯墊： GstElement *bin; GstElement *element; element = gst_element_factory_create (\"mad\", \"decoder\"); bin = gst_bin_new (\"bin_name\"); gst_bin_add (GST_BIN (bin), element); gst_element_add_ghost_pad (bin, gst_element_get_pad (element, \"sink\"), \"sink\"); 示範瞭如何將兩個元件通過襯墊連接起來 //連接 gst_pad_link (srcpad, sinkpad); //斷開 gst_pad_unlink (srcpad, sinkpad); 別：初級 肖文鵬,自由軟件愛好者 2004年6月01日 GStreamer是GNOME桌面環境下用來構建流媒體應用的編程框架（framework），其目標是要簡化音/視頻應用程序的開發，目前已經能夠被用來處理像MP3、Ogg、MPEG1、MPEG2、AVI、 Quicktime等多種格式的多媒體數據。 一、基本概念 GStreamer作為GNOME桌面環境推薦的流媒體應用框架，採用了基於插件（plugin）和管道（pipeline）的體系結構，框架中的所有的功能模塊都被實現成可以插拔的組件（component），並且在需要的時候能夠很方便地安裝到任意一個管道上，由於所有插件都通過管道機制進行統一的數據交換，因此很容易利用已有的各種插件“組裝”出一個功能完善的多媒體應用程序。 1.1元件處理 對於需要應用GStreamer框架的程序員來講，GstElement是一個必須理解的概念，因為它是組成管道的基本構件，也是框架中所有可用組件的基礎，這也難怪GStreamer框架中的大部分函數都會涉及到對GstElement對象的操作。從GStreamer自身的觀點來看，GstElement可以描述為一個具有特定屬性的黑盒子，它通過連接點（link point）與外界進行交互，向框架中的其餘部分錶徵自己的特性或者功能。 按照各自功能上的差異，GStreamer又將GstElement細分成如下幾類： Source Element數據源元件只有輸出端，它僅能用來產生供管道消費的數據，而不能對數據做任何處理。一個典型的數據源元件的例子是音頻捕獲單元，它負責從聲卡讀取原始的音頻數據，然後作為數據源提供給其它模塊使用。 Filter Element過濾器元件既有輸入端又有輸出端，它從輸入端獲得相應的數據，並在經過特殊處理之後傳遞給輸出端。一個典型的過濾器元件的例子是音頻編碼單元，它首先從外界獲得音頻數據，然後根據特定的壓縮算法對其進行編碼，最後再將編碼後的結果提供給其它模塊使用。 Sink Element接收器元件只有輸入端，它僅具有消費數據的能力，是整條媒體管道的終端。一個典型的接收器元件的例子是音頻回放單元，它負責將接收到的數據寫到聲卡上，通常這也是音頻處理過程中的最後一個環節。 圖1將有助於你更好地理解數據源元件、過濾器元件和接收器元件三者的區別，同時也不難看出它們是如何相互配合形成管道的： 圖1 需要注意的是，過濾器元件的具體形式是非常靈活的，GStreamer並沒有嚴格規定輸入端和輸出端的數目，事實上它們都可以是一個或者多個。圖2是一個AVI分離器的基本結構，它能夠將輸入數據分離成單獨的音頻信息和視頻信息，用於實現該功能的過濾器元件很明顯只具有一個輸入端，但卻需要有兩個輸出端。 圖2 要想在應用程序中創建GstElement對象，唯一的辦法是藉助於工廠對象GstElementFactory。由於GStreamer框架提供了多種類型的GstElement對象，因此對應地提供了多種類型的GstElementFactory對象，它們是通過特定的工廠名稱來進行區分的。例如，下面的代碼通過gst_element_factory_find()函數獲得了一個名為mad的工廠對象，它之後可以用來創建與之對應的MP3解碼器元件： GstElementFactory *factory; factory = gst_element_factory_find (\"mad\"); 成功獲得工廠對象之後，接下來就可以通過gst_element_factory_create()函數來創建特定的GstElement對象了，該函數在調用時有兩個參數，分別是需要用到的工廠對象，以及即將創建的元件名稱。元件名稱可以用查詢的辦法獲得，也可以通過傳入空指針（NULL）來生成工廠對象的默認元件。下面的代碼示範瞭如何利用已經獲得的工廠對象，來創建名為decoder的MP3解碼器元件： GstElement *element; element = gst_element_factory_create (factory, \"decoder\"); 當創建的GstElement不再使用的時候，還必須調用gst_element_unref()函數釋放其占用的內存資源： gst_element_unref (element); GStreamer使用了與GObject相同的機制來對屬性（property）進行管理，包括查詢（query）、設置（set）和讀取（get）等。所有的GstElement對像都需要從其父對象GstObject那裡繼承名稱（name）這一最基本的屬性，這是因為像gst_element_factory_make()和gst_element_factory_create()這樣的函數在創建工廠對象和元件對象時都會用到名稱屬性，通過調用gst_object_set_name()和gst_object_get_name()函數可以設置和讀取GstElement對象的名稱屬性。 1.2襯墊處理 襯墊（pad）是GStreamer框架引入的另外一個基本概念，它指的是元件（element）與外界的連接通道，對於框架中的某個特定元件來說，其能夠處理的媒體類型正是通過襯墊暴露給其它元件的。成功創建GstElement對象之後，可以通過gst_element_get_pad()獲得該元件的指定襯墊。例如，下面的代碼將返回element元件中名為src的襯墊： GstPad *srcpad; srcpad = gst_element_get_pad (element, \"src\"); 如果需要的話也可以通過gst_element_get_pad_list()函數，來查詢指定元件中的所有襯墊。例如，下面的代碼將輸出element元件中所有襯墊的名稱： GList *pads; pads = gst_element_get_pad_list (element); while (pads) { GstPad *pad = GST_PAD (pads->data); g_print (\"pad name is: %s\\n\", gst_pad_get_name (pad)); pads = g_list_next (pads); } 與元件一樣，襯墊的名稱也能夠動態設置或者讀取，這是通過調用gst_pad_get_name ()和gst_pad_set_name()函數來完成的。所有元件的襯墊都可以細分成輸入襯墊和輸出襯墊兩種，其中輸入襯墊只能接收數據但不能產生數據，而輸出襯墊則正好相反，只能產生數據但不能接收數據，利用函數gst_pad_get_direction()可以獲得指定襯墊的類型。 GStreamer框架中的所有襯墊都必然依附於某個元件之上，調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。襯墊從某種程度上可以看成是元件的代言人，因為它要負責向外界描述該元件所具有的能力。 GStreamer框架提供了統一的機制來讓襯墊描述元件所具有的能力（capability），這是藉助數據結構_GstCaps來實現的： struct _GstCaps { gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ }; 以下是對mad元件的能力描述，不難看出該元件中實際包含sink和src兩個襯墊，並且每個襯墊都帶有特定的功能信息。名為sink的襯墊是mad元件的輸入端，它能夠接受MIME類型為audio/mp3的媒體數據，此外還具有layer、bitrate和framed三種屬性。名為src的襯墊是mad元件的輸出端，它負責產生MIME類型為audio/raw媒體數據，此外還具有format、depth、rate和channels等多種屬性。 Pads: SINK template: ’sink’ Availability: Always Capabilities: ’mad_sink’: MIME type: ’audio/mp3’: SRC template: ’src’ Availability: Always Capabilities: ’mad_src’: MIME type: ’audio/raw’: format: String: int endianness: Integer: 1234 width: Integer: 16 depth: Integer: 16 channels: Integer range: 1 - 2 law: Integer: 0 signed: Boolean: TRUE rate: Integer range: 11025 - 48000 準確地說，GStreamer框架中的每個襯墊都可能對應於多個能力描述，它們能夠通過函數gst_pad_get_caps()來獲得。例如，下面的代碼將輸出pad襯墊中所有能力描述的名稱及其MIME類型： GstCaps *caps; caps = gst_pad_get_caps (pad); g_print (\"pad name is: %s\\n\", gst_pad_get_name (pad)); while (caps) { g_print (\" Capability name is %s, MIME type is %s\\n\", gst_caps_get_name (cap), gst_caps_get_mime (cap)); caps = caps->next; } 1.3箱櫃 箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對象，但由於其自身也是一個GstElement對象，因此實際上也能夠被用來容納其它的箱櫃對象。利用箱櫃可以將需要處理的多個元件組合成一個邏輯元件，由於不再需要對箱櫃中的元件逐個進行操作，因此能夠很容易地利用它來構造更加複雜的管道。在GStreamer框架中使用箱櫃還有另外一個優點，那就是它會試著對數據流進行優化，這對於多媒體應用來講是很具吸引力的。 圖3描述了箱櫃在GStreamer框架中的典型結構： 圖3 在GStreamer應用程序中使用的箱櫃主要有兩種類型： GstPipeline管道是最常用到的容器，對於一個GStreamer應用程序來講，其頂層箱櫃必須是一條管道。 GstThread線程的作用在於能夠提供同步處理能力，如果GStreamer應用程序需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。 GStreamer框架提供了兩種方法來創建箱櫃：一種是藉助工廠方法，另一種則是使用特定的函數。下面的代碼示範瞭如何使用工廠方法創建線程對象，以及如何使用特定函數來創建管道對象： GstElement *thread, *pipeline; //創建線程對象，同時為其指定唯一的名稱。 thread = gst_element_factory_make (\"thread\", NULL); //根據給出的名稱，創建一個特定的管道對象。 pipeline = gst_pipeline_new (\"pipeline_name\"); 箱櫃成功創建之後，就可以調用gst_bin_add()函數將已經存在的元件添加到其中來了： GstElement *element; GstElement *bin; bin = gst_bin_new (\"bin_name\"); element = gst_element_factory_make (\"mpg123\", \"decoder\"); gst_bin_add (GST_BIN (bin), element); 而要從箱櫃中找到特定的元件也很容易，可以藉助gst_bin_get_by_name()函數實現： GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), \"decoder\"); 由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況，gst_bin_get_by_name()函數在查找元件時會對嵌套的箱櫃作遞歸查找。元件有添加到箱櫃之中以後，在需要的時候還可以從中移出，這是通過調用gst_bin_remove()函數來完成的： GstElement *element; gst_bin_remove (GST_BIN (bin), element); 如果仔細研究一下圖3中描述的箱櫃，會發現它沒有屬於自己的輸入襯墊和輸出襯墊，因此顯然是無法作為一個邏輯整體與其它元件交互的。為了解決這一問題，GStreamer引入了精靈襯墊（ghost pad）的概念，它是從箱櫃裡面所有元件的襯墊中推舉出來的，通常來講會同時選出輸入襯墊和輸出襯墊，如圖4所示： 圖4 具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程序中能夠像使用元件一樣使用這類箱櫃。下面的代碼示範瞭如何為箱櫃添加一個精靈襯墊： GstElement *bin; GstElement *element; element = gst_element_factory_create (\"mad\", \"decoder\"); bin = gst_bin_new (\"bin_name\"); gst_bin_add (GST_BIN (bin), element); gst_element_add_ghost_pad (bin, gst_element_get_pad (element, \"sink\"), \"sink\"); 回頁首 二、元件連接 在引入了元件和襯墊的概念之後，GStreamer對多媒體數據的處理過程就變得非常清晰了：通過將不同元件的襯墊依次連接起來構成一條媒體處理管道，使數據在流經管道的過程能夠被各個元件正常處理，最終實現特定的多媒體功能。 圖１就描述了一條很簡單的管道，它由三個基本元件構成：數據源元件只負責產生數據，它的輸出襯墊與過濾器元件的輸入襯墊相連；過濾器元件負責從自己的輸入襯墊中獲取數據，並在經過特定的處理之後，將結果通過輸出襯墊傳給與之相連的接收器元件；接收器元件只負責接收數據，它的輸入襯墊與過濾器元件的輸出襯墊相連，負責對最終結果進行相應的處理。 GStreamer框架中的元件是通過各自的襯墊連接起來的，下面的代碼示範瞭如何將兩個元件通過襯墊連接起來，以及如何在需要的時候斷開它們之間的連接： GstPad *srcpad, *sinkpad; srcpad = gst_element_get_pad (element1, \"src\"); sinpad = gst_element_get_pad (element2, \"sink\"); //連接 gst_pad_link (srcpad, sinkpad); //斷開 gst_pad_unlink (srcpad, sinkpad); 如果需要建立起連接的元件都只有一個輸入襯墊和一個輸出襯墊，那麼更簡單的做法是調用gst_element_link()函數直接在它們之間建立起連接，或者調用gst_element_unlink()函數斷開它們之間的連接： //連接 gst_element_link (element1, element2); //斷開 gst_element_unlink (element1, element2); NULL這是所有元件的默認狀態，表明它剛剛創建，還沒有開始做任何事情。 READY表明元件已經做好準備，隨時可以開始處理流程。 PAUSED表明元件因某種原因暫時停止處理數據。 PLAYING表明元件正在進行數據處理。 所有的元件都從NULL狀態開始，依次經歷NULL、READY、PAUSED、PLAYING等狀態間的轉換。元件當前所處的狀態可以通過調用gst_element_set_state()函數進行切換： GstElement *bin; /*創建元件，並將其連接成箱櫃bin */ gst_element_set_state (bin, GST_STATE_PLAYING); 默認情況下，管道及其包含的所有元件在創建之後將處於NULL狀態，此時它們不會進行任何操作。當管道使用完畢之後，不要忘記重新將管道的狀態切換回NULL狀態，讓其中包含的所有元件能夠有機會釋放它們正在佔用的資源。 管道真正的處理流程是從第一次將其切換到READY狀態時開始的，此時管道及其包含的所有元件將做好相應的初始化工作，來為即將執行的數據處理過程做好準備。對於一個典型的元件來講，處於READY狀態時需要執行的操作包括打開媒體文件和音頻設備等，或者試圖與位於遠端的媒體服務器建立起連接。 處於READY狀態的管道一旦切換到PLAYING狀態，需要處理的多媒體數據就開始在整個管道中流動，並依次被管道中包含的各個元件進行處理，從而最終實現管道預先定義好的某種多媒體功能。 GStreamer框架也允許將管道直接從NULL狀態切換到PLAYING狀態，而不必經過中間的READY狀態。 正處於播放狀態的管道能夠隨時切換到PAUSED狀態，暫時停止管道中所有數據的流動，並能夠在需要的時候再次切換回PLAYING狀態。如果需要插入或者更改管道中的某個元件，必須先將其切換到PAUSED或者NULL狀態，元件在處於PAUSED狀態時並不會釋放其占用的資源。 由於沒有用到線程，因此必須通過不斷調用gst_bin_iterate()函數的辦法，來判斷管道的處理過程會在何時結束： while (gst_bin_iterate (GST_BIN (pipeline))); 只要管道內還會繼續有新的事件產生，gst_bin_iterate()函數就會一直返回TRUE，只有當整個處理過程都結束的時候，該函數才會返回FALSE，此時就該終止管道並釋放佔用的資源了： Manually adding or removing data from/to a pipeline synchronization, thread-safety and other things fakesink fakesrc - old version appsrc appsink - new version cap:is-live min-latency max-latency format = GST_FORMAT_TIME non-live format = GST_FORMAT_TIME or GST_FORMAT_BYTES event : SEGMENT (appsrc will push) 計算接收了多少時間用 gst_app_src_push_buffer \"max-bytes\" property “enough-data” signal “need-data” signal 錄wav gst-launch alsasrc ! audioconvert ! audio/x-raw-int,channel s=1,depth=16,width=16,rate=16000 !audioresample ! wavenc ! filesink location=mic .wav 測試播放 gst-launch audiotestsrc ! audioconvert ! audioresample ! alsasink 播放檔案 gst-launch filesrc location=toto.ogg ! decodebin ! audioconvert ! audioresample ! alsasink 即時播放錄音 gst-launch -v alsasrc ! alsasink sync=FALSE 播放mp3 gst-launch-0.10 -v filesrc location=/response.mp3 ! flump3dec ! alsasink 播放url gst-launch-0.10 playbin2 uri=http://kiis-fm.akacast.akamaistream.net/7/572/19773/v1/auth.akacast.akamaistream.net/kiis-fm null->ready->pause->playing playing->pause>ready->null Sources : filesrc | alsasrc | appsrc Sink: filesink | alsasink | appsink Encoder: Decnoder: decodebin Converter: Bin: playbin Gobject © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"md/95-Git/1-Basic/Readme.html":{"url":"md/95-Git/1-Basic/Readme.html","title":"Basic","keywords":"","body":"Basic tagsstart Git tagsstop Introduction git config --global user.name \"\" git config --global user.email \"\" git config --global alias.co checkout git config --global core.editor vim git init 使用 git status 來檢視所有檔案的狀態 使用 git add 來告知 git，哪些是我們即將要提交（commit）的檔案 git rm 使用 git commit 來提交一個 patch，並且使用 vim 編輯提交訊息（包含標題及內容） git mv 使用 git log 檢視提交的歷史訊息 --oneline使用 git show 檢視最後一次提交的 patch 所修改內容 git add --all 不論檔案狀態是 Untracked files 或是 Changes not staged for commit（紅色），都會一口氣變成 Changes to be committed（綠色） git add -u # 一次加入所有被更動的檔案，包含 modified 及 deleted Changes not staged for commit（紅色），都會一口氣變成 Changes to be committed（綠色） git add -f 強制 add 被忽略的檔案 第一行為 commit message 的標題（僅限一行） 第二行保留空白 第三行以後是 commit message 的內容（可略過不寫） git diff 只能檢視 Changes not staged for commit 區塊（紅色）的修改內容 git diff hello_world.txt git diff --cached # 檢視Changes to be committed(綠色)部分的內容 git reset git reset HEAD 使用 git reset HEAD 來還原 \"檔案狀態\" 使用 git checkout -- 來還原 \"檔案內容\" 使用 git reset --soft HEAD^ 使 patch 回到上一個階段的 Changes to be committed git reset --soft HEAD@{1} git reset --hard HEAD 可以一次將 Changes not staged for commit 和 Changes to be committed 的區域清空，但不包含Untracked files git reset HEAD^ 回到前一個 patch，且恢復檔案的狀態 git reset --soft HEAD^ 回到前一個 patch，但保持檔案狀態為 Changes to be committed git reset --hard HEAD^ 回到前一個 patch，且強制清除檔案的修改內容 忽略Untracked files .gitignore *.exe # 忽略所有 xxx.exe 的檔案 接著我們可以透過 git checkout -- 來還原檔案的內容 $ git checkout -- num.txt 組合記 $git add -A # 把所有檔案加到 Changes to be committed $git reset --hard HEAD # 一次還原所有檔案的內容 組合記的組合記 $git submodule foreach --recursive git add -A $git submodule foreach --recursive git reset --hard HEAD HEAD^ 或 HEAD~1 可以用來表示上一個 patch HEAD^^ 或 HEAD~2 可以用來表示上兩個 patch HEAD^^^ 或 HEAD~3 可以用來表示上三個 patch git show HEAD~2 在 git 的世界裡，凡事 HEAD 發生改變都會被記錄下來 哪些時候 HEAD 會發生改變呢？ git commit 提交一份新的 patch，HEAD 會轉移到新的 patch git reset --hard 切換 patch 的時候 git cherry-pick/revert ... 挑入/挑出 patch 的時候 git checkout 切換分支的時候 git merge/rebase ... 合併分支的時候 git reflog 用來看Head的移動 git log -g 查看 reflog 的詳細內+ git commit --amend 的注意事項（非常雷 x 2） 使用指令 git commit --amend 後，會馬上進入 vim 的文字編輯模式 git 不論你是否有修改 commit message 或是用 :q! 不存檔直接離開 vim 都會為你重新產生新的 commit id 有時候這並不一定是我們想要的結果，要特別留意！ 例如說，我們從 server 上抓了最新的 code 下來，準備要新增一個功能再上傳至 server 但是你好死不死的手殘按到 git commit --amend 先改到了最新的 patch（P0） 這時候儘管你按 :q! 退出 vim，但是 commit id 早就已經被改掉了（P0'） 然後我們基於 P0' 來開發新功能，並且 commit 了一個新的 patch（P1） 這時候我們要上傳 patch 的時候，會遇到被 git server 拒絕的情形 被拒絕的原因是，server 認為你提交的 patch 跟 server 的 code 並沒有兩樣 但其實主要原因是，server 認為你上傳了兩個的 patch，分別是 P0' 跟 P1 server 先用 P0' 跟 P0 最比對，發現兩個 patch 根本就一模一樣，就直接拒絕了 當你絞盡腦汁的想要找出 P1 哪裡有問題的時候，其實是被 git commit --amend 背後默默捅了一刀 因此上傳 patch 前請確保 parent id 正確無誤 git commit --amend # 使用後會進入 vim 文字編輯模式。把標題改成 \"Add 77\" 然後存檔離開 $ git reset --hard edb3d9c # 回到 P3 $ git cherry-pick b2dbf88 # 挑入 P5 → P5' $ git cherry-pick 8cb205e # 挑入 P6 → P6' 解完衝突請執行 git cherry-pick --continue 若要放棄請執行 git cherry-pick --abort $ git rebase -i # 啟動 rebase 互動模式 如果不想要有 git reflog 的紀錄的話，就要將把 TODO 的內容清空或是註解掉 git rebase --skip git rebase --continue git rebase --abort 全部取消，並且回到 rebase 前的狀態 patch 多沒有關係，但 patch 改的內容要越細越好 git branch git branch git checkout 切換分支 git clone -b RB14.12 https://git.allseenalliance.org/gerrit/core/alljoyn.git git checkout -b $ git checkout git branch -f git branch -D 刪除分支 我們必須切到其它分支上，才能把 feature 分支刪除 git checkout 移動 HEAD 的位置 git push (遠端倉庫名ex:orginal) (分支名ex:master) Git 除了可以用 cherry-pick 和 rebase 的方式來合併分支之外 還可以用 merge 指令來合併分支 git merge bugFix git stash git stash list git config --global core.editor vim git add submoudle git submoudle add subdir git clone submoudle git clone --recurse-submodules https://github.com/schnell18/dotvim.git update submoudle git submodule foreach git pull origin Merge detached HEAD back to origin/master – Git $git checkout c2744f95d $git checkout –b temp #makes a new branch from current detached HEAD $git branch –f master temp #update master to point to the new branch $git branch –d temp #delete the branch $git push origin master #push the re-established history git pull --rebase 加上 rebase 的意思是，會先 1.把本地 repo. 從上次 pull 之後的變更暫存起來 2. 回復到上次 pull 時的情況 3. 套用遠端的變更 4. 最後再套用剛暫存下來的本地變更。詳細說明可以參考 pull with rebase。 git push origin HEAD:master If you want to stash only specific files, do the following: Stage the files you don't want to stash And the following command: git stash save --keep-index For example # On branch develop # Changes to be committed: # (use \"git reset HEAD ...\" to unstage) # # modified: fileA # modified: fileB # # Changes not staged for commit: # (use \"git add ...\" to update what will be committed) # (use \"git checkout -- ...\" to discard changes in working directory) # # modified: fileC # modified: fileD git stash save --keep-index © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 02:07:58 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2017-09-04 03:47:18 mininet 什麼是 mininet 什麼是 SDN mininet 實戰 SDN 什麼是 SDN Docker Basic IDE Xcode Eclipse Xcode Xcode Mac Xcode Software Xcode Eclipse Eclipse Eclipse GStreamer Basic Voice Basic Video Basic Git Basic "}}